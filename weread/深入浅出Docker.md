# 深入浅出Docker

 **奈吉尔·波尔顿**


## 划线部分


### 第2章 走进Docker

* 虽然竞争是一件好事，但是标准的竞争通常不是。因为它会导致困扰，降低用户接受度，对谁都无益。


### 第4章 纵观Docker

* 如果读者是一名开发者，可以将镜像比作类（Class）。

* 按Ctrl-PQ组合键，可以在退出容器的同时还保持容器运行。


### 第二部分 Docker技术

* 这一计划遵循了在UNIX中得以实践并验证过的一种软件哲学：小而专的工具可以组装为大型工具。


### 第6章 Docker镜像

* 如果读者是一名研发人员，可以将镜像理解为类（Class）。

* 标签为latest的镜像没有什么特殊魔力！标有latest标签的镜像不保证这是仓库中最新的镜像！

* 在docker image pull命令中指定-a参数来拉取仓库中的全部镜像。

* latest是一个非强制标签，不保证指向仓库中最新的镜像！

* 另一种查看镜像分层的方式是通过docker image inspect命令。

* docker history命令显示了镜像的构建历史记录，但其并不是严格意义上的镜像分层。例如，有些Dockerfile中的指令并不会创建新的镜像层。比如ENV、EXPOSE、CMD以及ENTRY- POINT。不过，这些命令会在镜像中添加元数据。

* 在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重要。

* 这就是所谓的内容散列（Content Hash）。到目前为止，事情都很简单。但是接下来的内容就有点儿复杂了。在推送和拉取镜像的时候，都会对镜像层进行压缩来节省网络带宽以及仓库二进制存储空间。但是压缩会改变镜像内容，这意味着镜像的内容散列值在推送或者拉取操作之后，会与镜像内容不相符！这显然是个问题。例如，在推送镜像层到Docker Hub的时候，Docker Hub会尝试确认接收到的镜像没有在传输过程中被篡改。为了完成校验，Docker Hub会根据镜像层重新计算散列值，并与原散列值进行比较。因为镜像在传输过程中被压缩（发生了改变），所以散列值的校验也会失败。为避免该问题，每个镜像层同时会包含一个分发散列值（Distribution Hash）。这是一个压缩版镜像的散列值，当从镜像仓库服务拉取或者推送镜像的时候，其中就包含了分发散列值，该散列值会用于校验拉取的镜像是否被篡改过。这个内容寻址存储模型极大地提升了镜像的安全性，因为在拉取和推送操作后提供了一种方式来确保镜像和镜像层数据是一致的。该模型也解决了随机生成镜像和镜像层ID这种方式可能导致的ID冲突问题。

* Docker（镜像和镜像仓库服务）规范目前支持多架构镜像。这意味着某个镜像仓库标签（repository:tag）下的镜像可以同时支持64位Linux、PowerPC Linux、64位Windows和ARM等多种架构。简单地说，就是一个镜像标签之下可以支持多个平台和架构。

* 一种删除某Docker主机上全部镜像的快捷方式是在docker image rm命令中传入当前系统的全部镜像ID，可以通过dockerimage ls获取全部镜像ID（使用-q参数）。

* 可以看到docker image ls -q命令只返回了系统中本地拉取的全部镜像的ID列表。


### 第7章 Docker容器

* 从更高层面上来讲，Hypervisor是硬件虚拟化（Hardware Virtualization）——Hypervisor将硬件物理资源划分为虚拟资源；另外，容器是操作系统虚拟化（OS Virtualization）——容器将系统资源划分为虚拟资源。

* 唯一对容器启动时间有影响的就是容器内应用启动所花费的时间。

* 这使得Bash Shell成为容器中运行的且唯一运行的进程。

* 杀死容器中的主进程，则容器也会被杀死。

* 人们认为容器不擅长持久化工作或者持久化数据，很大程度上是因为容器在非持久化领域上表现得太出色。

* 总结一下容器的生命周期。可以根据需要多次停止、启动、暂停以及重启容器，并且这些操作执行得很快。但是容器及其数据是安全的。直至明确删除容器前，容器都不会丢弃其中的数据。就算容器被删除了，如果将容器数据存储在卷中，数据也会被保存下来。

* always策略是一种简单的方式。除非容器被明确停止，比如通过docker containerstop命令，否则该策略会一直尝试重启处于停止状态的容器。

* --restart always策略有一个很有意思的特性，当daemon重启的时候，停止的容器也会被重启。例如，新创建一个容器并指定--restart always策略，然后通过docker container stop命令停止该容器。现在容器处于Stopped (Exited)状态。但是，如果重启Docker daemon，当daemon启动完成时，该容器也会重新启动。

* on-failure策略会在退出容器并且返回值不是0的时候，重启容器。就算容器处于stopped状态，在Docker daemon重启的时候，容器也会被重启。

* 使用docker container ls命令可以查看当前运行的容器以及端口的映射情况。端口信息按照host-port:container-port的格式显示，明确这一点很重要。

* 在构建镜像时指定默认命令是一种很普遍的做法，因为这样可以简化容器的启动。这也为镜像指定了默认的行为，并且从侧面阐述了镜像的用途——可以通过Inspect镜像的方式来了解所要运行的应用。

* 接下来了解一种简单且快速的清理Docker主机上全部运行容器的方法。有言在先，这种处理方式会强制删除所有的容器，并且不会给容器完成清理的机会。这种操作一定不能在生产环境系统或者运行着重要容器的系统上执行。


### 第8章 应用的容器化

* 不要因Dockerfile就是一个描述文件而对其有所轻视！Dockerfile能实现开发和部署两个过程的无缝切换。同时Dockerfile还能帮助新手快速熟悉这个项目。Dockerfile对当前的应用及其依赖有一个清晰准确的描述，并且非常容易阅读和理解。因此，要像重视你的代码一样重视这个文件，并且将它纳入到源控制系统当中。

* 为镜像打标签命令的格式是docker image tag <current-tag> <new-tag>，其作用是为指定的镜像添加一个额外的标签，并且不需要覆盖已经存在的标签。

* -d参数的作用是让应用程序以守护线程的方式在后台运行。

* 如果指令的作用是向镜像中增添新的文件或者程序，那么这条指令就会新建镜像层；如果只是告诉Docker如何完成构建或者如何运行应用程序，那么就只会增加镜像的元数据。

* 可以通过docker image history来查看在构建镜像的过程中都执行了哪些指令。

* 基本的构建过程是，运行临时容器>在该容器中运行Dockerfile中的指令>将指令运行结果保存为一个新的镜像层>删除临时容器。

* 不同的Dockerfile写法就会对镜像的大小产生显著影响。常见的例子是，每一个RUN指令会新增一个镜像层。因此，通过使用&&连接多个命令以及使用反斜杠（\）换行的方法，将多个命令包含在一个RUN指令中，通常来说是一种值得提倡的方式。这并不难掌握，多加练习即可

* 多阶段构建能够在不增加复杂性的情况下优化构建过程。

* 重点在于COPY --from指令，它从之前的阶段构建的镜像中仅复制生产环境相关的应用代码，而不会复制生产环境不需要的构件。

* 一旦有指令在缓存中未命中（没有该指令对应的镜像层），则后续的整个构建过程将不再使用缓存。

* 当镜像中层数太多时，合并是一个不错的优化方式。例如，当创建一个新的基础镜像，以便基于它来构建其他镜像的时候，这个基础镜像就最好被合并为一层。
缺点是，合并的镜像将无法共享镜像层。这会导致存储空间的低效利用，而且push和pull操作的镜像体积更大。

* 使用no-install-recommends

* Dockerfile中的ENTRYPOINT指令用于指定镜像以容器方式启动后默认运行的程序。


### 第9章 使用Docker Compose部署应用

* 基于此，我们可以弥合开发与运维之间的隔阂。Compose文件应该被当作代码，因此应该将其保存在源控制库中。


### 第10章 Docker Swarm

* 在网络配置方面，请尽量明确指定相关参数，这是一种好的实践。

* 从技术上来说，Swarm实现了一种主从方式的多管理节点的HA。

* 因为Swarm使用了Raft共识算法的一种具体实现来支持管理节点的HA。关于HA，以下是两条最佳实践原则。
•部署奇数个管理节点。
•不要部署太多管理节点（建议3个或5个）。

* 考虑到这一点，最佳的实践原则是部署3个或5个节点用于HA。7个节点可以工作，但是通常认为3个或5个是更优的选择。当然绝对不要多于7个，因为需要花费更长的时间来达成共识。

* 这一特性功能强大，使得服务在面对节点宕机等问题时具有自愈能力。

* 强烈建议读者能够通读docker inspect命令的输出内容，其中不仅包含大量信息，也是了解底层运行机制的途径。

* 本质上说，覆盖网络是创建于底层异构网络之上的一个新的二层容器网络。

* 假设本次投票已经结束，而公司希望开启一轮新的投票。现在已经为下一轮投票构建了一个新镜像，并推送到了Docker Hub仓库，新镜像的tag由v1变更为v2。
此外还假设，本次升级任务在将新镜像更新到Swarm中时采用一种阶段性的方式——每次更新两个副本，并且中间间隔20s。那么就可以采用如下的docker service update命令来完成。

* Docker Swarm是使Docker规模化的关键方案。


### 第11章 Docker网络

* 推荐通篇阅读该规范，不过其实抽象来讲，CNM定义了3个基本要素：沙盒（Sandbox）、终端（Endpoint）和网络（Network）。

* CNM组件与容器进行关联

* docker network inspect命令就是一个信息宝藏。如果读者对底层细节的内容感兴趣，强烈推荐仔细阅读该命令的输出内容。

* Docker内置的Macvlan驱动（Windows上是Transparent）就是为此场景而生。通过为容器提供MAC和IP地址，让容器在物理网络上成为“一等公民”。

* 但是，Macvlan的缺点是需要将主机网卡（NIC）设置为混杂模式（Promiscuous Mode），这在大部分公有云平台上是不允许的。

* 可以通过docker container logs命令查看单独的容器日志，通过docker service logs可以查看Swarm服务日志。但是，Docker支持多种日志驱动，并不是每种都能通过docker logs命令查看的。

* 服务发现（Service Discovery）允许容器和Swarm服务通过名称互相定位。唯一的要求就是需要处于同一个网络当中。
其底层实现是利用了Docker内置的DNS服务器，为每个容器提供DNS解析功能。

* 通过Ingress模式发布的服务，可以保证从Swarm集群内任一节点（即使没有运行服务的副本）都能访问该服务；以Host模式发布的服务只能通过运行服务副本的节点来访问。

* 在底层，Ingress模式采用名为Service Mesh或者Swarm Mode Service Mesh的四层路由网络来实现。


### 第12章 Docker覆盖网络

* 这是因为只有当运行中的容器连接到覆盖网络的时候，该网络才变为可用状态。这种延迟生效策略通过减少网络梳理，提升了网络的扩展性。

* Docker使用VXLAN隧道技术创建了虚拟二层覆盖网络

* docker network create是创建新网络所使用的命令。-d参数允许用户指定所用驱动，常见的驱动是Overlay。也可以选择使用第三方驱动。对于覆盖网络，控制层默认是加密的。需要指定-o encrypted对数据层进行加密（会导致额外的性能开销）。


### 第13章 卷与持久化数据

* 每个Docker容器都有自己的非持久化存储。非持久化存储自动创建，从属于容器，生命周期与容器相同。这意味着删除容器也会删除全部非持久化数据。如果希望自己的容器数据保留下来（持久化），则需要将数据存储在卷上。卷与容器是解耦的，从而可以独立地创建并管理卷，并且卷并未与任意容器生命周期绑定。最终效果即用户可以删除一个关联了卷的容器，但是卷并不会被删除。

* 在容器中持久化数据的方式推荐采用卷。总体来说，用户创建卷，然后创建容器，接着将卷挂载到容器上。卷会挂载到容器文件系统的某个目录之下，任何写到该目录下的内容都会写到卷中。即使容器被删除，卷与其上面的数据仍然存在。

* Docker中卷属于一等公民。抛开其他原因，这意味着卷在API中拥有一席之地，并且有独立的docker volume子命令。

* 在Docker主机的终端上执行下面的命令。第一条命令会证明文件依然存在，第二条命令展示了文件的内容。

* 构建这样的环境需要外部存储系统的相关知识，并了解应用如何从共享存储读取或者写入数据。这种配置主要关注数据损坏（Data Corruption）。


### 第14章 使用Docker Stack部署应用

* 大规模场景下的多服务部署和管理是一件很难的事情。

* 简而言之，Docker适用于开发和测试。Docker Stack则适用于大规模场景和生产环境。

* Docker Stack和Docker Compose的一个区别是，Stack不支持构建。这意味着在部署Stack之前，所有镜像必须提前构建完成。


### 第15章 Docker安全

* 容器本质就是命名空间的有机组合


### 第16章 企业版工具

* 默认情况下，UCP管理节点不运行用户工作负载。推荐使用这种最佳实践，并建议用户在生产环境中强制使用。该方式使得管理节点只需关注控制平面职责。同时也能简化问题定位。

* 有一点是确认的：Window镜像会比Linux镜像稍大一些。所以规划时务必考虑该因素。


### 第17章 企业级特性

* 长话短说，DCT确保使用者能够得到他们想要的镜像。


### NO TITLE

* [插图]


## 个人笔记部分


### 第13章 卷与持久化数据

* 在Docker主机的终端上执行下面的命令。第一条命令会证明文件依然存在，第二条命令展示了文件的内容。  （个人笔记: 20210302: 目前在 Mac 系统上使用最新版的 Docker（Version: 3.1.0） 无法进入目录，根据链接 https://timonweb.com/docker/getting-path-and-accessing-persistent-volumes-in-docker-for-mac/ 猜测进入了个更深层次的坏境。 ）


### 第11章 Docker网络

* 服务发现（Service Discovery）允许容器和Swarm服务通过名称互相定位。唯一的要求就是需要处于同一个网络当中。
其底层实现是利用了Docker内置的DNS服务器，为每个容器提供DNS解析功能。  （个人笔记: 服务发现需要中心化的 DNS 解析器。）


### 第6章 Docker镜像

* 这就是所谓的内容散列（Content Hash）。到目前为止，事情都很简单。但是接下来的内容就有点儿复杂了。在推送和拉取镜像的时候，都会对镜像层进行压缩来节省网络带宽以及仓库二进制存储空间。但是压缩会改变镜像内容，这意味着镜像的内容散列值在推送或者拉取操作之后，会与镜像内容不相符！这显然是个问题。例如，在推送镜像层到Docker Hub的时候，Docker Hub会尝试确认接收到的镜像没有在传输过程中被篡改。为了完成校验，Docker Hub会根据镜像层重新计算散列值，并与原散列值进行比较。因为镜像在传输过程中被压缩（发生了改变），所以散列值的校验也会失败。为避免该问题，每个镜像层同时会包含一个分发散列值（Distribution Hash）。这是一个压缩版镜像的散列值，当从镜像仓库服务拉取或者推送镜像的时候，其中就包含了分发散列值，该散列值会用于校验拉取的镜像是否被篡改过。这个内容寻址存储模型极大地提升了镜像的安全性，因为在拉取和推送操作后提供了一种方式来确保镜像和镜像层数据是一致的。该模型也解决了随机生成镜像和镜像层ID这种方式可能导致的ID冲突问题。  （个人笔记: 多个散列保证安全性。）

