## Vue.js实战

 **梁灏**


### 2.1 Vue实例与数据绑定

* 过滤器应当用于处理简单的文本转换，如果要实现更为复杂的数据变换，应该使用计算属性


### 3.3 计算属性缓存

* 既然使用methods就可以实现，那么为什么还需要计算属性呢？原因就是计算属性是基于它的依赖缓存的。一个计算属性所依赖的数据发生变化时，它才会重新取值，所以text只要不改变，计算属性也就不更新


### 5.2 条件渲染指令

* v-if和v-show具有类似的功能，不过v-if才是真正的条件渲染，它会根据表达式适当地销毁或重建元素及绑定的事件或子组件。若表达式初始值为false，则一开始元素/组件并不会渲染，只有当条件第一次变为真时才开始编译。
而v-show只是简单的CSS属性切换，无论条件真与否，都会被编译。相比之下，v-if更适合条件不经常改变的场景，因为它切换开销相对较大，而v-show适用于频繁切换条件。


### 6.1 基本用法

* 事实上，v-model也是一个特殊的语法糖，只不过它会在不同的表单上智能处理。


### 6.3 修饰符

* 输入框中，v-model默认是在input事件中同步输入框的数据（除了提示中介绍的中文输入法情况外），使用修饰符．lazy会转变为在change事件中同步


### 7.2 使用props传递数据

* 组件不仅仅是要把模板的内容进行复用，更重要的是组件间要进行通信。通常父组件的模板中包含子组件，父组件要正向地向子组件传递数据或参数，子组件接收到后根据参数的不同来渲染不同的内容或执行操作。这个正向传递数据的过程就是通过props来实现的。

* 提示 注意，在JavaScript中对象和数组是引用类型，指向同一个内存空间，所以props是对象和数组时，在子组件内改变是会影响父组件的。


### 7.3 组件通信

* 我们已经知道，从父组件向子组件通信，通过props传递数据就可以了，但Vue组件通信的场景不止有这一种，归纳起来，组件之间通信可以用图7-2表示。

* 如果你了解过JavaScript的设计模式——观察者模式，一定知道dispatchEvent和addEventListener这两个方法。Vue组件也有与之类似的一套模式，子组件用$emit()来触发事件，父组件用$on()来监听子组件的事件。

* $emit()方法的第一个参数是自定义事件的名称，例如示例的increase和reduce后面的参数都是要传递的数据，可以不填或填写多个。

* Vue.js1.x中，除了$emit()方法外，还提供了$dispatch()和$broadcast()这两个方法。$dispatch()用于向上级派发事件，只要是它的父级（一级或多级以上），都可以在Vue实例的events选项内接收

* 同理，$broadcast()是由上级向下级广播事件的，用法完全一致，只是方向相反。
这两种方法一旦发出事件后，任何组件都是可以接收到的，就近原则，而且会在第一次接收到后停止冒泡，除非返回true。

* 尽管Vue允许这样操作，但在业务中，子组件应该尽可能地避免依赖父组件的数据，更不应该去主动修改它的数据，因为这样使得父子组件紧耦合，只看父组件，很难理解父组件的状态，因为它可能被任意组件修改，理想情况下，只有组件自己能修改它的状态。父子组件最好还是通过props和$emit来通信。


### 7.4 使用slot分发内容

* 当需要让组件组合使用，混合父组件的内容与子组件的模板时，就会用到slot，这个过程叫作内容分发（transclusion）。

* props传递数据、events触发事件和slot内容分发就构成了Vue组件的3个API来源，再复杂的组件也是由这3部分构成的。

* 给<slot>元素指定一个name后可以分发多个内容，具名Slot可以与单个Slot共存

* 作用域插槽是一种特殊的slot，使用一个可以复用的模板替换已渲染元素。

* $slots在业务中几乎用不到，在用render函数（进阶篇中将介绍）创建组件时会比较有用，但主要还是用于独立组件开发中。


### 7.6 其他

* 理论上，我们应该不用去主动操作DOM，因为Vue的核心思想就是数据驱动DOM，但在很多业务里，我们避免不了会使用一些第三方库，比如popper.js（https://popper.js.org/）、swiper（http://idangero.us/swiper/">http://idangero.us/swiper/）等，这些基于原生JavaScript的库都有创建和更新及销毁的完整生命周期，与Vue配合使用时，就要利用好$nextTick。

* 我们现在所创建的实例都是通过new Vue()的形式创建出来的。在一些非常特殊的情况下，我们需要动态地去创建Vue实例，Vue提供了Vue.extend和$mount两个方法来手动挂载一个实例。


### 8.1 基本用法

* ● update：被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新。

* ● el指令所绑定的元素，可以用来直接操作DOM


### 8.2 实战

* 该示例有两个特点，一是点击下拉菜单本身是不会关闭的，二是点击下拉菜单以外的所有区域都要关闭。点击所有区域可以在document上绑定click事件来实现，同时只要过滤出是否点击的是目标元素内部的元素即可。


### 第9章 Render函数

* Vue.js 2.x与Vue.js 1.x最大的区别就在于2.x使用了Virtual Dom（虚拟DOM）来更新DOM节点，提升渲染性能。


### 9.1 什么是Virtual Dom

* 与DOM操作相比，Virtual Dom是基于JavaScript计算的，所以开销会小很多。图9-1演示了Virtual Dom运行的过程。

* 在Vue.js2中，Virtual Dom就是通过一种VNode类表达的，每个DOM元素或组件都对应一个VNode对象，在Vue.js源码中是这样定义的


### 9.2 什么是Render函数

* Render函数通过createElement参数来创建Virtual Dom，结构精简了很多。在第7章组件中介绍slot时，有提到过访问slot的用法，使用场景就是在Render函数。
Render函数所有神奇的地方都在这个createElement里，下一节我们就来介绍它的详细配置和用法。


### 9.3 createElement用法

* 深度克隆slot的做法有点偏黑科技，不过在一般业务中几乎不会遇到这样的需求，主要还是运用在独立组件中。

* 一开始接触Render写法时，可能会有点不适应，毕竟这种用createElement创建DOM节点的方法不够直观和可读，而且受Vue内置指令的影响，有时会绕不过弯。不过只要把它当作JavaScript一个普通的函数来使用，写习惯后就没有那么难理解了，说到底，它只是JavaScript而已。比如下面的示例展示了JavaScript的if、else语句和数组map方法充分配合使用来渲染一个列表。


### 9.4 函数化组件

* 函数化组件在业务中并不是很常用，而且也有其他类似的方法来实现，比如上例也可以用组件的is特性来动态挂载。总结起来，函数化组件主要适用于以下两个场景：
● 程序化地在多个组件中选择一个。
● 在将children, props,data传递给子组件之前操作它们。


### 9.5 JSX

* JSX仍然是JavaScript而不是DOM，如果你的团队不是JSX强驱动的，建议还是以模板template的方式为主，特殊场景（比如锚点标题）使用Render的createElement辅助完成。



### 9.8 总结

* 本章两个实战的练习题中都有用template写法还原render函数，目的是充分理解render函数的使用场景。如果你已经做了还原，应该会发现使用template写法更简单、可读，尤其是第二个示例。的确，这两个实战示例都更适合用template来实现，在业务中，生产效率是第一位，所以绝大部分业务代码都应当用template来完成。你不用在意性能问题，如果使用了webpack做编译（后面章节会介绍）, template都会被预编译为render函数。

