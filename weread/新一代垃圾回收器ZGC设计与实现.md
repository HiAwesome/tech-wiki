## 新一代垃圾回收器ZGC设计与实现

 **彭成寒**


### 1.2.5 ZGC

* 看到这三大目标，是不是觉得不可思议，应该如何设计或者如何改进以前的垃圾回收器才能实现这些目标？ ZGC的设计思路借鉴了一款商业垃圾回收器——Azul的C4（关于C4的介绍，可以参考相关论文￼）。C4这款垃圾回收器号称无停顿时间，所以很多人认为ZGC也是完全无停顿时间的，即ZGC在执行垃圾回收时完全不需要暂停应用程序，这实际上是对无停顿时间的误解。

* 另外，在G1中可能存在FGC，如果发生了FGC，也可能导致停顿时间不可控。在目前的ZGC中，垃圾回收就是全量回收，也就是每发生一次垃圾回收就是一次FGC，而每次垃圾回收的停顿时间在10ms以下，所以FGC导致停顿时间不可控这一存在于G1中的问题也解决了。因为ZGC中每次垃圾回收都是全量回收（即每次都是FGC），那么大家可能会问，如果对象分配不成功，ZGC将如何处理这种情况呢？这里先留一个疑问，后文中将回答。
ZGC除了并发转移，还对整个垃圾回收进入STW的过程做了改进，把原来串行执行的动作也并发执行。在这里我们比较一下不同垃圾回收器在并发粒度上的区别，如表1-3所示。

* 最后对ZGC做一个简单的总结。除了并发执行这个显著特点之外，ZGC还有以下特点：
❑不分代的垃圾回收器，即垃圾回收时对全量内存进行标记，但是回收时仅针对部分内存回收，优先回收垃圾比较多的页面。
❑仅支持Linux 64位系统，不支持32位平台。
❑不支持使用压缩指针。
❑内存分区管理，且支持不同的分区粒度，在ZGC中分区称为页面（page），有小页面、中页面、大页面3种。
❑具有颜色指针（color pointer），通过设计不同的标记位区分不同的虚拟空间，而这些不同标记位指示的不同虚拟空间通过mmap映射在同一物理地址；颜色指针能够快速实现并发标记、转移和重定位。
❑设计了读屏障，实现了并发标记和并发转移的处理。

* 二 从JDK 12开始支持并发类卸载。
❑支持NUMA，尽量把对象分配在访问速度比较快的地方。


### 1.2.6 Shenandoah

* Shenandoah最初的目标是把垃圾回收停顿时间降到毫秒级别，并且对内存的支持扩展到太字节（TB）级别。为了降低停顿时间，回收器需要使用更多的线程来并行处理回收任务。如果要在降低停顿时间的同时支持更大的堆空间，那么CPU需要具备更好的多核处理能力。相比于CMS和G1, Shenandoah不仅进行并行的垃圾标记，在压缩堆空间时也是并发进行的。从这一点上看，Shenandoah和ZGC是非常类似的，都是解决了并发转移的问题，不过它们两者在实现上采用不同的方法。目前从效果来看，Shenandoah和ZGC存在竞争关系，当然竞争不是坏事，一方面可以促进社区的蓬勃发展，另外一方面这两个项目可以相互借鉴，这也是为什么在ZGC加入OpenJDK之后，Shenandoah也被整合到OpenJDK。



### 6.1 Xlog简介

* Xlog非常好用，这里给出几个大家在学习和工作中可能用到的选项：
❑-Xlog:gc*=trace：输出所有的垃圾回收日志，trace是最低日志级别。
❑-Xlog:all=trace：输出JVM相关所有的日志，trace是最低日志级别。
❑-Xlog:loggine=trace：输出日志系统所有的日志，trace是最低日志级别。


### 6.3 ZGC初始化信息

* ZGC适用于大内存的应用，如果系统内存空间比较大，建议打开该参数。在实际工作中，打开该参数可能还需要进一步调整Linux操作系统的参数，特别是当发现内存压力很大时，可以调整操作系统关于内存页面回收的速度和数量。具体可以参考其他的文献￼。


### 6.5 垃圾回收过程中每一步的信息

* ZGC提供了两个内部参数，且这两个参数不可以更改，分别为ZMarkProactive FlushMax（初始化值为10）和ZMarkTerminateFlushMax（初始化值为3）。这两个参数分别控制0号线程最多进行主动刷新的次数为10次，工作线程最多执行被动刷新的次数为3次。


### 6.6.2 竞争信息

* 那么这个平均值到底是多少？如何计算？实际上我们可以通过在执行程序的过程中使用日志选项-Xlog:gc*=trace输出详细的日志信息。
下面是一段关于并发标记SeqNum置位冲突的具体日志信息。这需要详细的统计数据，设置ZGC的参数ZStatisticsForceTrace为true（该参数为诊断参数，使用时需要打开-XX:+UnlockDiagnosticVMOptions）


### 第7章 ZGC参数和基准测试

* 垃圾回收器是基于新的算法和设计不断发展的，同时垃圾回收器的设计者希望能降低它的使用门槛，特别是减少垃圾回收相关的配置参数。这一趋势非常明显，众所周知的CMS提供的参数有上百个，而在G1中仅仅提供了43个生产参数，ZGC更进一步，一共提供19个参数，其中只有7个是与生产相关的参数，有11个是用于诊断的参数，还有1个是用于开发的参数。


### 7.1.1 ZGC新引入参数

* 在实际工作中，可能调整的参数有ZMarkStacksMax、ZCollectionInterval和ZStatistics Interval，分别控制并发标记过程中标记栈的大小、是否在固定间隔时间回收垃圾以及日志信息的输出频度。


### 7.2 测试评估

* ZGC作为一个最新的垃圾回收器，在和其他垃圾回收器进行比较时，其性能表现如何？要回答这个问题并不容易，原因在于首先我们必须设计一款基准测试的程序。然后使用不同的垃圾回收器运行基准测试程序，其次在运行不同的垃圾回收器的过程中要调整优化垃圾回收器的参数，保证垃圾回收器接近实际工作的情况。

* 目前Java中常用的基准测试有两个——SPECJbb￼和DaCapo￼。SPECJbb是一款商业基准测试软件，DaCapo是一款开源的基准测试软件。目前SPECJbb已经支持JDK 11，但是DaCapo还不支持JDK 11。ZGC的开发团队在最初提交提案时，给出了使用ZGC和G1运行SPECJbb的性能报告￼。性能测试从吞吐率和暂停时间两个方面来衡量，结果显示ZGC在这两个方面的运行效果均优于G1。注意测试是基于128GB的大内存进行的。下面我们简单看一下官方提供的报告。


### 7.2.1 测试准备

* 这个配置指在YCSB进行数据加载时，一共加载100万条数据。在测试时，共运行1000万次，其中读写比例分别为60%和40%。在运行的1000万次的数据中，读写请求按照ZipFian分布￼产生。


### 7.2.2 测试与测试报告

* 用例3在禁止TLAB后，吞吐率明显下降，但是垃圾回收时间和停顿时间也都下降了。为什么会出现这种现象？ZGC虽然支持两级对象内存分配（对象分配和页面分配），并且在两级分配时都使用了缓存，但是缓存的粒度比较粗，分别针对CPU和整个堆空间。而TLAB是针对线程的，所以对象分配时发生冲突的概率更小。理论上说，垃圾回收的停顿时间更短，应用程序获得执行的时间更多，吞吐率应该更高。但是在ZGC中，这两个指标并不存在正相关，最主要的原因是ZGC中并发执行的线程在标记、转移和重定位时消耗CPU资源，从而影响应用程序的吞吐率。
通过这3个简单的测试用例可以看出，虽然ZGC提供的参数不多，但在实际使用时也需要调整参数以便得到更好的效果。

* 我们知道ZGC更适用于大内存的情况，遗憾的是笔者也没有合适的大内存测试环境。在笔者的机器上，最大可用的物理内存为16GB，所以采用14GB作为最大堆空间，在有限的内存上运行更大的数据量来测试使用ZGC和G1的吞吐率和暂停时间。

* 在8GB的堆空间中，ZGC在吞吐率方面的表现稍有逊色，但与G1也相差无几，在14GB的堆空间中，ZGC在吞吐率方面的表现已经明显占优，这说明堆空间越大，使用ZGC的效果越好。


### 8.2 单代回收

* 目前ZGC把内存看成一个整体，回收时会扫描整个内存。但是我们知道对象的生命周期是不同的，据IBM的研究显示，98%的Java对象在创建之后不久就变成了非活跃对象；只有2%的对象会长时间处于活跃状态。实现分代垃圾回收，把容易死亡的对象放在一个区域（通常称为新生代），针对这个区域以更高频度触发垃圾回收，把长期处于活跃状态的对象放在另外一个区域（通常称为老生代），以更低的频率触发垃圾回收，这样可以提高垃圾回收的效率，有效地提高内存的利用率。


### 9.5 使用HSDB学习JVM中对象布局

* 部分读者可能不太熟悉GDB，不必担心，JDK本身提供了一个工具——HSDB（HotSpot Debugger）来分析JVM中Java对象的内存布局。在第8章介绍类回收时涉及Java对象在JVM中的布局，本节简单地介绍一下Java对象布局的设计以及如何通过HSDB分析Java对象的内存布局。
JVM是使用C++实现的，所以要理解这个问题，需要先回顾一下C++执行的原理。


### 9.5.3 用HSDB分析Java对象布局

* 首先对ObjectTest进行编译，通过编译之后就可以执行（这里没有指定垃圾回收器，主要原因是对象布局与垃圾回收器无关；执行时为了能准确地跟踪内存使用选项-XX:-UseCompressedOops，在对象头中使用64位地址，而不是压缩的32位地址），然后通过JDK中自带的jps命令找到对应的进程号，最后使用jhsdb hsdb打开调试器。


### 10.3.2 遍历回收算法

* 从Shenandoah的目标来看，它更适合用在大堆上。所以，如果CPU资源有限，内存也不大，比如小于20GB，那么就没有必要使用Shenandoah。而且Shenandoah功能还在不断地完善，从长远来看，机器配置越来越好，内存越来越大，性能要求也会越来越高，所以未来Shenandoah一定是主流的垃圾回收器之一。
Shenandoah会作为实验性项目合入JDK 12的主干分支中。虽然ZGC和Shenandoah有一样的目的，但是由于Shenandoah启动较早，并且支持的功能比ZGC完善，所以Shenandoah仍然是OpenJDK中热门的项目之一

