## Java核心技术·卷Ⅱ：高级特性（原书第10版）

 **凯S.霍斯特曼**


### 1.2 流的创建

* Java API中有大量方法都可以产生流。例如，Pattern类有一个splitAsStream方法，它会按照某个正则表达式来分割一个CharSequence对象。可以使用下面的语句来将一个字符串分割为一个个的单词


### 1.3 filter、map和flatMap方法

* 在流之外的类中你也会发现flatMap方法，因为它是计算机科学中的一种通用概念。假设我们有一个泛型G（例如Stream），以及将某种类型T转换为G<U>的函数f和将类型U转换为G<V>的函数g。然后，我们可以通过使用flatMap来组合它们，即首先应用f，然后应用g。这是单子论的关键概念。但是不必担心，我们无须了解任何有关单子的知识就可以使用flatMap。


### 1.6 简单约简

* Optional类型是一种更好的表示缺少返回值的方式。


### 1.7.4 用flatMap来构建Optional值的函数

* 注意：你已经在Stream接口中看到过flatMap方法（参见1.3节），当时这个方法被用来将可以产生流的两个方法组合起来，其实现方式是摊平由流构成的流。如果将可选值当作尺寸为0和1的流来解释，那么Optional.flatMap方法与其操作方式一样。



### 1.8 收集结果

* 如果想要将流的结果约简为总和、平均值、最大值或最小值，可以使用summarizing（Int|Long|Double）方法中的某一个。这些方法会接受一个将流对象映射为数据的函数，同时，这些方法会产生类型为（Int|Long|Double）SummaryStatistics的结果，同时计算总和、数量、平均值、最小值和最大值。


### 1.9 收集到映射表中

* 在通常情况下，值应该是实际的元素，因此第二个函数可以使用Function.identity（）。


* 如果有多个元素具有相同的键，那么就会存在冲突，收集器将会抛出一个Illegal-StateException对象。可以通过提供第3个函数引元来覆盖这种行为，该函数会针对给定的已有值和新值来解决冲突并确定键对应的值。这个函数应该返回已有值、新值或它们的组合。

* 如果想要得到TreeMap，那么可以将构造器作为第4个引元来提供。你必须提供一种合并函数。


### 1.10 群组和分区

* 将具有相同特性的值群聚成组是非常常见的，并且groupingBy方法直接就支持它。

* 当分类函数是断言函数（即返回boolean值的函数）时，流的元素可以分区为两个列表：该函数返回true的元素和其他的元素。在这种情况下，使用partitioningBy比使用groupingBy要更高效。


### 1.11 下游收集器

* groupingBy方法会产生一个映射表，它的每个值都是一个列表。如果想要以某种方式来处理这些列表，就需要提供一个“下游收集器”。

* mapping方法会产生将函数应用到下游结果上的收集器，并将函数值传递给另一个收集器。


### 1.12 约简操作

* reduce方法是一种用于从流中计算某个值的通用机制，其最简单的形式将接受一个二元函数，并从前两个元素开始持续应用它。如果该函数是求和函数，那么就很容易解释这种机制：

* 通常，会有一个幺元值e使得e op x=x，可以使用这个元素作为计算的起点。例如，0是加法的幺元值。然后，可以调用第2种形式的reduce

* 注意：有时reduce会显得并不够通用。例如，假设我们想要收集BitSet中的结果。如果收集操作是并行的，那么就不能直接将元素放到单个BitSet中，因为BitSet对象不是线程安全的。因此，我们不能使用reduce，因为每个部分都需要以其自己的空集开始，并且reduce只能让我们提供一个幺元值。此时，应该使用collect，它会接受单个引元


### 1.13 基本类型流

* 为了将基本类型流转换为对象流，需要使用boxed方法


### 1.14 并行流

* 只要在终结方法执行时，流处于并行模式，那么所有的中间流操作都将被并行化。

* 警告：传递给并行流操作的函数不应该被堵塞。并行流使用fork-join池来操作流的各个部分。如果多个流操作被阻塞，那么池可能就无法做任何事情了。

* 当放弃排序需求时，有些操作可以被更有效地并行化。通过在流上调用unordered方法，就可以明确表示我们对排序不感兴趣。Stream.distinct就是从这种方式中获益的一种操作。在有序的流中，distinct会保留所有相同元素中的第一个，这对并行化是一种阻碍，因为处理每个部分的线程在其之前的所有部分都被处理完之前，并不知道应该丢弃哪些元素。如果可以接受保留唯一元素中任意一个的做法，那么所有部分就可以并行地处理（使用共享的集来跟踪重复元素）。

* 警告：不要修改在执行某项流操作后会将元素返回到流中的集合（即使这种修改是线程安全的）。

* 换句话说，不要将所有的流都转换为并行流。只有在对已经位于内存中的数据执行大量计算操作时，才应该使用并行流。


### 2.1.1 读写字节

* 当你完成对输入/输出流的读写时，应该通过调用close方法来关闭它，这个调用会释放掉十分有限的操作系统资源。如果一个应用程序打开了过多的输入/输出流而没有关闭，那么系统资源将被耗尽。关闭一个输出流的同时还会冲刷用于该输出流的缓冲区：所有被临时置于缓冲区中，以便用更大的包的形式传递的字节在关闭输出流时都将被送出。特别是，如果不关闭文件，那么写出字节的最后一个包可能将永远也得不到传递。当然，我们还可以用fush方法来人为地冲刷这些输出。


### 2.1.2 完整的流家族

* java.io.Closeable接口扩展了java.lang.AutoCloseable接口。因此，对任何Closeable进行操作时，都可以使用try-with-resource语句（try-with-resource语句是指声明了一个或多个资源的try语句——译者注）。为什么要有两个接口呢？因为Closeable接口的close方法只抛出IOException，而AutoCloseable.close方法可以抛出任何异常。


### 2.1.3 组合输入/输出流过滤器

* 所有在java.io中的类都将相对路径名解释为以用户工作目录开始，你可以通过调用System.getProperty（"user.dir"）来获得这个信息。

* Java使用了一种灵巧的机制来分离这两种职责。某些输入流（例如FileInputStream和由URL类的openStream方法返回的输入流）可以从文件和其他更外部的位置上获取字节，而其他的输入流（例如DataInputStream）可以将字节组装到更有用的数据类型中。Java程序员必须对二者进行组合。


### 2.2.1 如何写出文本输出

* println方法在行中添加了对目标系统来说恰当的行结束符（Windows系统是"\r\n"，UNIX系统是"\n"），也就是通过调用System.getProperty（"line.separator"）而获得的字符串。


### 2.2.4 字符编码方式

* 不存在任何可靠的方式可以自动地探测出字节流中所使用的字符编码方式。某些API方法让我们使用“默认字符集”，即计算机的操作系统首选的字符编码方式。这种字符编码方式与我们的字节源中所使用的编码方式相同吗？字节源中的字节可能来自世界上的其他国家或地区，因此，你应该总是明确指定编码方式。例如，在编写网页时，应该检查Content-Type头信息。

* 在不指定任何编码方式时，有些方法（例如String（byte[]）构造器）会使用默认的平台编码方式，而其他方法（例如Files.readAllLines）会使用UTF-8。


### 2.4.1 保存和加载序列化对象

* 你只有在写出对象时才能用writeObject/readObject方法，对于基本类型值，你需要使用诸如writeInt/readInt或writeDouble/readDouble这样的方法。（对象流类都实现了DataInput/DataOutput接口。）


### 2.4.3 修改默认的序列化机制

* Java拥有一种很简单的机制来防止这种域被序列化，那就是将它们标记成是transient的。如果这些域属于不可序列化的类，你也需要将它们标记成transient的。瞬时的域在对象被序列化时总是被跳过的。

* readObject和writeObject方法是私有的，并且只能被序列化机制调用。与此不同的是，readExternal和writeExternal方法是公共的。特别是，readExternal还潜在地允许修改现有对象的状态。


### 2.4.4 序列化单例和类型安全的枚举

* 请记住向遗留代码中所有类型安全的枚举以及向所有支持单例设计模式的类中添加readResolve方法。


### 2.4.5 版本管理

* 我们可以使用JDK中的单机程序serialver来获得这个数字

* 如果这两部分数据域之间名字匹配而类型不匹配，那么对象输入流不会尝试将一种类型转换成另一种类型，因为这两个对象不兼容；如果被序列化的对象具有在当前版本中所没有的数据域，那么对象输入流会忽略这些额外的数据；如果当前版本具有在被序列化的对象中所没有的数据域，那么这些新添加的域将被设置成它们的默认值（如果是对象则是null，如果是数字则为0，如果是boolean值则是false）。

* 这种处理是安全的吗？视情况而定。丢掉数据域看起来是无害的，因为接收者仍旧拥有它知道如何处理的所有数据，但是将数据域设置为null却有可能并不那么安全。许多类都费尽心思地在其所有的构造器中将所有的数据域都初始化为非null的值，以使得其各个方法都不必去处理null数据。因此，这个问题取决于类的设计者是否能够在readObject方法中实现额外的代码去订正版本不兼容问题，或者是否能够确保所有的方法在处理null数据时都足够健壮。


### 2.5.1 Path

* 路径不必对应着某个实际存在的文件，它仅仅只是一个抽象的名字序列。你在接下来的小节中将要看到，当你想要创建文件时，首先要创建一个路径，然后才调用方法去创建对应的文件。

* 偶尔，你可能需要与遗留系统的API交互，它们使用的是File类而不是Path接口。Path接口有一个toFile方法，而File类有一个toPath方法。


### 2.5.2 读写文件

* 这些便捷方法可以将你从处理FileInputStream、FileOutputStream、BufferedReader和BufferedWriter的繁复操作中解脱出来。


### 2.6.3 文件加锁机制

* 如果shared标志为false，则锁定文件的目的是读写，而如果为true，则这是一个共享锁，它允许多个进程从文件中读入，并阻止任何进程获得独占的锁。并非所有的操作系统都支持共享锁，因此你可能会在请求共享锁的时候得到的是独占的锁。调用FileLock类的isShared方法可以查询你所持有的锁的类型。


### 2.7 正则表达式

* 字符串cab匹配[a-z]*ab，但是不匹配[a-z]*+ab。在第一种情况中，表达式[a-z]*只匹配字符c，使得字符ab匹配该模式的剩余部分；但是贪婪版本[a-z]*+将匹配字符cab，模式的剩余部分将无法匹配。

* 如果想要在集合或流中匹配元素，那么可以将模式转换为谓词

* 如果有多个标记，那么可以惰性地获取它们


### 4.4.1 URL和URI

* URI是个纯粹的语法结构，包含用来指定Web资源的字符串的各种组成部分。URL是URI的一个特例，它包含了用于定位Web资源的足够信息。


### 4.4.2 使用URLConnection获取信息

* 最后我们再介绍一个总览全局的方法：setRequestProperty，它可以用来设置对特定协议起作用的任何“名-值（name/value）对”。关于HTTP请求头的格式，请参见RFC 2616，其中的某些参数没有很好地建档，它们通常在程序员之间口头传授。例如，如果你想访问一个有密码保护的Web页，那么就必须按如下步骤操作


### 4.4.3 提交表单数据

* 正如你所看到的，可以使用Java库的类来与网页交互，但是用起来并非特别方便。可以考虑使用其他的库，例如Apach HttpClient


### 5.2 结构化查询语言

* 注意：有些数据库供应商的产品支持在进行不等于比较时使用！=。这不符合标准SQL的语法，所以我们建议不要使用这种方法。


### 5.3 JDBC配置

* 注意：包含在JDK中的Apache Derby版本官方名称为JavaDB，我们认为这个名字没什么特别用处，因此我们在本章中称其为Derby。


### 5.3.5 连接到数据库

* 提示：调试与JDBC相关的问题时，有种方法是启用JDBC的跟踪特性。调用DriverManager.setLogWriter方法可以将跟踪信息发送给PrintWriter，而PrintWriter将输出JDBC活动的详细列表。大多数JDBC驱动程序的实现都提供了用于跟踪的附加特性，例如，在使用Derby时，可以在JDBC的URL中添加traceFile选项，如jdbc：derby：//localhost：1527/COREJAVA；create=true；traceFile=trace.out。


### 5.4.1 执行SQL语句

* 警告：与数组的索引不同，数据库的列序号是从1开始计算的。


### 5.4.4 组装数据库

* 注意：你的数据库可能也包含直接从SQL文件读取的工具


### 5.5.1 预备语句

* 提示：许多程序员都不喜欢使用如此复杂的SQL语句。比较常见的方法是使用大量的Java代码来迭代多个结果集，但是这种方法效率非常低。通常，使用数据库的查询代码要比使用Java程序好得多——这是数据库的一个重要优点。一般而言，可以使用SQL解决的问题，就不要使用Java程序。


### 5.11 Web与企业应用中的连接管理

* 解决上述问题的方法是建立数据库连接池（pool）。这意味着数据库连接在物理上并未被关闭，而是保留在一个队列中并被反复重用。连接池是一种非常重要的服务，JDBC规范为实现者提供了用以实现连接池服务的手段。不过，JDK本身并未实现这项服务，数据库供应商提供的JDBC驱动程序中通常也不包含这项服务。相反，Web容器和应用服务器的开发商通常会提供连接池服务的实现。


### 6.1 时间线

* 为了得到两个时刻之间的时间差，可以使用静态方法Duration.between。例如，下面的代码展示了如何度量算法的运行时间


### 6.2 本地时间

* 回忆一下，两个Instant之间的时长是Duration，而用于本地日期的等价物是Period，它表示的是流逝的年、月或日的数量。


### 6.3 日期调整器

* 对于日程安排应用来说，经常需要计算诸如“每个月的第一个星期二”这样的日期。TemporalAdjusters类提供了大量用于常见调整的静态方法。你可以将调整方法的结果传递给with方法。


### 6.4 本地时间

* LocalTime自身并不关心AM/PM。这种愚蠢的设计将问题抛给格式器去解决


### 6.5 时区时间

* 时区，可能是因为完全是人为创造的原因，它们甚至比地球不规则的转动引发的复杂性还要麻烦。在理性的世界中，我们都会遵循格林尼治时间，有些人在02：00吃午饭，而有些人却在22：00吃午饭。我们的胃能弄明白这是怎么回事。这就是中国的做法，中国横跨了4个时区，但是使用了同一个时间。在其他地方，时区显得并不规则，并且还有国际日期变更线，而夏令时则使事情变得更糟了。

* 注意：UTC代表“协调世界时”，这是英文“Coordinated Universal Time”和法文“Temps Universel Coordiné”首字母缩写的折中，它与这两种语言中的缩写都不一致。UTC是不考虑夏令时的格林威治皇家天文台时间。


### 6.6 格式化和解析

* DateTimeFormatter类提供了三种用于打印日期/时间值的格式器：
·预定义的格式器（参见表6-6）
·Locale相关的格式器
·带有定制模式的格式器


### 8.3 使用注解

* 为了能够受益于注解，你需要选择一个处理工具，然后向你的处理工具可以理解的代码中插入注解，之后运用该处理工具处理代码。


### 8.3.1 注解简介

* @Test注解自身并不会做任何事情，它需要工具支持才会有用。例如，当测试一个类的时候，JUnit4测试工具（可以从http://junit.org处获得）可能会调用所有标识为@Test的方法。另一个工具可能会删除一个类文件中的所有测试方法，以便在对这个类测试完毕后，不会将这些测试方法与程序装载在一起。


### 8.4.1 注解接口

* 所有的注解接口都隐式地扩展自java.lang.annotation.Annotation接口。这个接口是一个常规接口，不是一个注解接口。


### 8.4.2 注解

* 另外一种快捷方式是单值注解。如果一个元素具有特殊的名字value，并且没有指定其他元素，那么你就可以忽略掉这个元素名以及等号。


### 8.4.3 注解各类声明

* 泛化类或方法中的类型参数可以像下面这样被注解


### 8.5.1 用于编译的注解

* Generated注解的目的是供代码生成工具来使用。任何生成的源代码都可以被注解，从而与程序员提供的代码区分开。例如，代码编辑器可以隐藏生成的代码，或者代码生成器可以移除生成代码的旧版本。每个注解都必须包含一个表示代码生成器的唯一标识符，而日期字符串（ISO8601格式）和注释字符串是可选的。


### 8.5.3 元注解

* 注意：将一个注解应用到它自身上是合法的。例如，@Documented注解被它自身注解为@Documented。因此，针对注解的Javadoc文档表明了它们是否可以归档。

* 警告：在处理可重复注解时必须非常仔细。如果调用getAnnotation来查找某个可重复注解，而该注解又确实重复了，那么就会得到null。这是因为重复注解被包装到了容器注解中。


### 8.6.1 注解处理

* 编译器会定位源文件中的注解。每个注解处理器会依次执行，并得到它表示感兴趣的注解。如果某个注解处理器创建了一个新的源文件，那么将重复执行这个处理过程。如果某次处理循环没有再产生任何新的源文件，那么就编译所有的源文件。


### 8.6.3 使用注解来生成源码

* 我们不能将这些方法放到原来的类中，因为注解处理器只能产生新的类，而不能修改已有类。

* 提示：要想查看轮次，可以用-XprintRounds标记来运行javac命令

* 但是，这些方法需要被添加到同一个类中。这需要编辑源文件而不是产生另一个文件，而这超出了注解处理器的能力范围。我们可以为实现此目的而构建另一个工具，但是这种工具超出了注解的职责范围。注解被设计为对代码项的描述，而不是添加或修改代码的指令。


### 8.7.1 修改类文件

* 注解可以用来向程序中添加一些指示，而字节码编辑工具则可以提取这些指示，然后修改虚拟机指令。


### 9.1.3 将类加载器作为命名空间

* 然而，令人惊奇的是，在同一个虚拟机中，可以有两个类，它们的类名和包名都是相同的。

* 注意：这种技术还有其他用处，例如servlets和EJB的“热部署”。详细信息请访问http://zeroturnaround.com/labs/rjc301。


### 9.1.5 字节码校验

* 根据Gödel的定理，你无法设计相应的算法，使其能够处理程序文件，并决定输入程序是否有特定的属性（比如不出现堆栈溢出问题）。这是否属于Oracle公司的公共关系部门和逻辑法则之间的矛盾呢？不——事实上，校验器并非是一个Gödel意义上的决策算法。

* 然而，类文件中使用的字节码格式是有很好的文档记录的，对于具有汇编程序设计经验并且拥有十六进制编辑器的人来说，要手工地创建一个对Java虚拟机来说，由合法的但是不安全的指令构成的类文件，是一件非常容易的事情。再次提醒你，要记住，校验器总是在防范被故意篡改的类文件，而不仅仅只是检查编译器产生的类文件。

* 加载受损类文件将会产生一个方法校验错误


### 9.2.1 权限检查

* 注意：实现并安装自己的安全管理器是可行的，但是你不应该进行这种尝试，除非你是计算机安全方面的专家。配置标准的安全管理器更加安全。


### 9.2.3 安全策略文件

* 实际上，我们的测试结果是file：////C：/dir/filename.ext也是允许的，对此我们无法解释。


### 9.2.5 实现权限类

* 警告：务必要把你的权限类设为public。策略文件加载器不能加载包可视性超出引导类路径之外的类，并且它会悄悄忽略其无法找到的所有类。


### 12.2 数值参数与返回值

* 当在C和Java之间传递数字时，应该知道它们彼此之间的对应类型。例如，C也有int和long的数据类型，但是它们的实现却是取决于平台的。在一些平台上，int类型是16位的，在另外一些平台上是32位的。然而，在Java平台上int类型总是32位的整数。基于这个原因，Java本地接口定义了jint、jlong等类型。

