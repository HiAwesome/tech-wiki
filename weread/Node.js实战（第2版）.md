## Node.js实战（第2版）

 **亚历克斯·杨 布拉德利·马克等**


### 1.1 一个典型的Node Web应用程序

* 大体上来说，Node和JavaScript的优势之一是它们的单线程编程模型。

* 在Node程序员看来，非阻塞I/O是个底层术语。它的意思是说，你的程序可以在做其他事情时发起一个请求来获取网络资源，然后当网络操作完成时，将会运行一个回调函数来处理这个操作的结果。

* Node中的网络访问是非阻塞的，它用了一个名为libuv的库来访问操作系统的非阻塞网络调用。

* 即便你只有一个单线程、单进程的Node Web应用，它也可以同时处理上千个网站访客发起的连接。要想知道Node是如何做到的，得先研究一下事件轮询。


### 1.2 ES2015、Node和V8

* 我应该用const还是let
在决定是用const还是用let时，几乎都可以用const。因为你的大部分代码都是在用你自己的类实例、对象常量或不会变的值，所以大部分情况下都可以用const。即便是有可修改属性的对象，也是可以用const声明的，因为const的意思是引用是只读的，而不是值是不可变的。

* 因此，Node中能用的JavaScript特性都可以追溯到V8对该特性的支持。这一支持是通过特性组来管理的。


### 1.4 Node自带的工具

* 在用npm安装这些包时，你要决定是装在你的项目中还是装在全局。要全局安装的包一般是工具

* 如果你现在用带有参数--save的npm命令从npm网站上安装一个包，它会自动更新你的package.json文件。

* 你也可以用--global参数做全局安装。应尽可能地将包安装在项目里，但对于用在Node JavaScript代码之外的命令行工具，全局安装更合适。比如用npm安装命令行工具ESLint时，我们采用全局安装。

* Node不仅有文件系统库（fs、path）、TCP客户端和服务端库（net）、HTTP库（http和https）和域名解析库（dns），还有一个经常用来写测试的断言库（assert），以及一个用来查询平台信息的操作系统库（os）。

* 用Node的http模块写的Hello World

* Node自带的调试器支持单步执行和REPL（读取-计算-输出-循环）。这个调试器在工作时会用一个网络协议跟你的程序对话。带着debug参数运行程序，就可以对这个程序开启调试器。

* 交互式调试
Node支持Chrome调试协议。如果要用Chrome的开发者工具调试一段脚本，可以在运行程序时加上--inspect参数：
￼           node --inspect --debug-brk
这样Node就会启动调试器，并停在第一行。它会输出一个URL到控制台，你可以在Chrome中打开这个URL，然后用Chrome的调试器进行调试。Chrome的调试器可以一行行地执行代码，还能显示每个变量和对象的值。这要比在代码里敲console.log好得多。


### 1.5 三种主流的Node程序

* 你可以通过创建一个新目录，然后在里面安装Express模板，来快速创建一个Express Web应用程序

* 在前端开发的世界中，Node也在发挥着重要作用，因为它是进行语言转译的主要工具，比如从TypeScript到JavaScript。转译器将一种高级语言编译成另外一种高级语言，传统的编译器则将一种高级语言编译成一种低级语言。

* 比如说，大量使用流作为通用API的命令行工具，而流处理是Node最强大的功能之一。

* 如果你现在就想试一下，可以复制Electron的存储库并启动一个应用程序

* Node还能做一些用其他语言很难做到的事情。它是基于JavaScript的，所以在Node中能运行浏览器中的JavaScript。复杂的客户端应用可以经过改造在Node服务器上运行，让服务器进行预渲染，从而加快页面在浏览器中的渲染速度，也有利于搜索引擎进行索引。


### 2.1 Node功能的组织及重用

* Node模块允许从被引入文件中选择要暴露给程序的函数和变量。如果模块返回的函数或变量不止一个，那它可以通过设定exports对象的属性来指明它们。但如果模块只返回一个函数或变量，则可以设定module.exports属性。


### 2.2 开始一个新的Node项目

* require是Node中少数几个同步I/O操作之一。因为经常用到模块，并且一般都是在文件顶端引入，所以把require做成同步的有助于保持代码的整洁、有序，还能增强可读性。
但在I/O密集的地方尽量不要用require。所有同步调用都会阻塞Node，直到调用完成才能做其他事情。比如你正在运行一个HTTP服务器，如果在每个进入的请求上都用了require，就会遇到性能问题。所以require和其他同步操作通常放在程序最初加载的地方。


### 2.3 用module.exports微调模块的创建

* 为了让前面那个模块的代码能用，需要把exports换成module.exports。用module. exports可以对外提供单个变量、函数或者对象。如果你创建了一个既有exports又有module.exports的模块，那它会返回module.exports，而exports会被忽略。


### 2.6 使用异步编程技术

* 回调通常用来定义一次性响应的逻辑。比如对于数据库查询，可以指定一个回调函数来确定如何处理查询结果。这个回调函数可能会显示数据库查询结果，根据这些结果做些计算，或者以查询结果为参数执行另一个回调函数。

* 一个Node HTTP服务器实例就是一个事件发射器，一个可以继承、能够添加事件发射及处理能力的类（EventEmitter）。Node的很多核心功能都继承自EventEmitter，你也能创建自己的事件发射器。


### 2.7 用回调处理一次性事件

* Node的异步回调惯例
Node中的大多数内置模块在使用回调时都会带两个参数：第一个用来放可能会发生的错误，第二个用来放结果。错误参数经常缩写为err。


### 2.8 用事件发射器处理重复性事件

* echo服务器就是一个处理重复性事件的简单例子，当你给它发送数据时，它会把数据发回来

* 监听器可以被定义成持续不断地响应事件，如前面例子所示，也能被定义成只响应一次。下面的代码用了once方法，对前面那个echo服务器做了修改，让它只回应第一次发送过来的数据。

* 事件名称 事件是可以具有任意字符串值的键：data、join或某些长的让人发疯的事件名都行。只有一个事件是特殊的，那就是error，我们马上就会看到它

* 错误处理
在错误处理上有个常规做法，你可以创建发出error类型事件的事件发射器，而不是直接抛出错误。这样就可以为这一事件类型设置一个或多个监听器，从而定义定制的事件响应逻辑。


### 2.9 异步开发的难题

* 在创建异步程序时，你必须密切关注程序的执行流程，并瞪大眼睛盯着程序的状态：事件轮询的条件、程序变量，以及其他随着程序逻辑执行而发生变化的资源。

* 闭包 要了解闭包的详细信息，请参见Mozilla JavaScript文档：https://developer.mozilla.org/zh-CN/docs/JavaScript/Guide/Closures。



### 2.10 异步逻辑的顺序化

* 让一组异步任务顺序执行的概念被Node社区称为流程控制。这种控制分为两类：串行和并行

* 跟踪串行和并行的流程控制要做编程记账的工作。在实现串行化流程控制时，需要跟踪当前执行的任务，或维护一个尚未执行任务的队列。实现并行化流程控制时需要跟踪有多少个任务要执行完成了。
有一些可以帮你记账的流程控制工具，它们能让组织异步的串行或并行化任务变得很容易。尽管社区创建了很多序列化异步逻辑的辅助工具，但亲自动手实现流程控制可以让你看透其中的玄机，让你对如何应对异步编程中的挑战有更深的认识


### 2.12 实现串行化流程控制

* 串行化流程控制本质上是在需要时让回调进场，而不是简单地把它们嵌套起来。


### 2.13 实现并行化流程控制

* 为了让异步任务并行执行，仍然是要把任务放到数组中，但任务的存放顺序无关紧要。每个任务都应该调用处理器函数增加已完成任务的计数值。当所有任务都完成后，处理器函数应该执行后续的逻辑。


### 2.14 利用社区里的工具

* 社区中有流程控制能力的附加模块 要了解更多与社区中有流程控制能力的附加模块相关的内容，请阅读Werner Schuster和Dio Synodinos在InfoQ上发表的文章“虚拟座谈：如何从JavaScript异步编程中活下来”。

