# Java核心技术·卷Ⅰ：基础知识（原书第10版）

 **凯S.霍斯特曼**


## 划线部分


### 3.1 一个简单的Java应用程序

* 从Java 7开始，加上前缀0b或0B就可以写二进制数。例如，0b1001就是9。另外，同样是从Java 7开始，还可以为数字字面量加下划线，如用1_000_00（0或0b1111_0100_0010_0100_0000）表示一百万。这些下划线只是为了让人更易读。Java编译器会去除这些下划线

* Java没有任何无符号（unsigned）形式的int、long、short或byte类型

* double表示这种类型的数值精度是float类型的两倍（有人称之为双精度数值）。绝大部分应用程序都采用double类型。在很多情况下，float类型的精度很难满足需求。实际上，只有很少的情况适合使用float类型，例如，需要单精度数据的库，或者需要存储大量数据。

* 浮点数值不适用于无法接受舍入误差的金融计算中。例如，命令System.out.println（2.0-1.1）将打印出0.8999999999999999，而不是人们想象的0.9。这种舍入误差的主要原因是浮点数值采用二进制系统表示，而在二进制系统中无法精确地表示分数1/10。这就好像十进制无法精确地表示分数1/3一样。如果在数值计算中不允许有任何舍入误差，就应该使用BigDecimal类

* 十分遗憾，经过一段时间，不可避免的事情发生了。Unicode字符超过了65536个，其主要原因是增加了大量的汉语、日语和韩语中的表意文字。现在，16位的char类型已经不能满足描述所有Unicode字符的需要了

* 我们强烈建议不要在程序中使用char类型，除非确实需要处理UTF-16代码单元。最好将字符串作为抽象数据类型处理

* 尽管$是一个合法的Java字符，但不要在你自己的代码中使用这个字符。它只用在Java编译器或其他工具生成的名字中

* 在Java中，变量的声明尽可能地靠近变量第一次使用的地方，这是一种良好的程序编写风格。

* const是Java保留的关键字，但目前并没有使用。在Java中，必须使用final定义常量

* 移植性是Java语言的设计目标之一。无论在哪个虚拟机上运行，同一运算应该得到同样的结果。对于浮点数的算术运算，实现这样的可移植性是相当困难的。double类型使用64位存储一个数值，而有些处理器使用80位浮点寄存器。这些寄存器增加了中间过程的计算精度。例如，以下运算：
￼
很多Intel处理器计算x * y，并且将结果存储在80位的寄存器中，再除以z并将结果截断为64位。这样可以得到一个更加精确的计算结果，并且还能够避免产生指数溢出。但是，这个结果可能与始终在64位机器上计算的结果不一样。因此，Java虚拟机的最初规范规定所有的中间计算都必须进行截断。这种行为遭到了数值计算团体的反对。截断计算不仅可能导致溢出，而且由于截断操作需要消耗时间，所以在计算速度上实际上要比精确计算慢。为此，Java程序设计语言承认了最优性能与理想结果之间存在的冲突，并给予了改进。在默认情况下，虚拟机设计者允许对中间计算结果采用扩展的精度。但是，对于使用strictfp关键字标记的方法必须使用严格的浮点计算来生成可再生的结果。例如，可以把main方法标记为
￼
于是，在main方法中的所有指令都将使用严格的浮点计算。如果将一个类标记为strictfp，这个类中的所有方法都要使用严格的浮点计算。
实际的计算方式将取决于Intel处理器的行为。在默认情况下，中间结果允许使用扩展的指数，但不允许使用扩展的尾数（Intel芯片在截断尾数时并不损失性能）。因此，这两种方式的区别仅仅在于采用默认的方式不会产生溢出，而采用严格的计算有可能产生溢出。
如果没有仔细阅读这个注释，也没有什么关系。对大多数程序来说，浮点溢出不属于大问题。在本书中，将不使用strictfp关键字。

* 在Math类中，为了达到最快的性能，所有的方法都使用计算机浮点单元中的例程。如果得到一个完全可预测的结果比运行速度更重要的话，那么就应该使用StrictMath类。它使用“自由发布的Math库”（fdlibm）实现算法，以确保在所有平台上得到相同的结果。有关这些算法的源代码请参看www.netlib.org/fdlibm（当fdlibm为一个函数提供了多个定义时，StrictMath类就会遵循IEEE 754版本，它的名字将以“e”开头）

* 后缀和前缀形式都会使变量值加1或减1。但用在表达式中时，二者就有区别了。前缀形式会先完成加1；而后缀形式会使用变量原来的值。

* 建议不要在表达式中使用++，因为这样的代码很容易让人困惑，而且会带来烦人的bug。

* 如果需要把多个字符串放在一起，用一个定界符分隔，可以使用静态join方法

* 总而言之，Java的设计者认为共享带来的高效率远远胜过于提取、拼接字符串所带来的低效率。

* 从表面上看，这种bug很像随机产生的间歇性错误。

* 语言的设计者本应该像对+那样也进行特殊处理，即重定义==运算符。当然，每一种语言都会存在一些不太一致的地方。

* 因为输入是可见的，所以Scanner类不适用于从控制台读取密码。Java SE 6特别引入了Console类实现这个目的。

* 每一个以%字符开始的格式说明符都用相应的参数替换。格式说明符尾部的转换符将指示被格式化的数值类型：f表示浮点数，s表示字符串，d表示十进制整数。表3-5列出了所有转换符。
表3-5 用于printf的转换符
￼

* 表3-7 日期和时间的转换符
￼

* 如果需要多次对日期操作才能实现对每一部分进行格式化的目的就太笨拙了。为此，可以采用一个格式化的字符串指出要被格式化的参数索引。

* 还可以选择使用<标志。它指示前面格式说明中的参数将被再次使用。

* 如果省略字符编码，则会使用运行这个Java程序的机器的“默认编码”。这不是一个好主意，如果在不同的机器上运行这个程序，可能会有不同的表现。

* 当采用命令行方式启动一个程序时，可以利用Shell的重定向语法将任意文件关联到System.in和System.out

* 其中else部分是可选的。else子句与最邻近的if构成一组。

* 与C++一样，尽管Java允许在for循环的各个部分放置任何表达式，但有一条不成文的规则：for语句的3个部分应该对同一个计数器变量进行初始化、检测和更新。若不遵守这一规则，编写的循环常常晦涩难懂

* 在循环中，检测两个浮点数是否相等需要格外小心

* 有可能触发多个case分支。如果在case分支语句的末尾没有break语句，那么就会接着执行下一个case分支语句。这种情况相当危险，常常会引发错误。为此，我们在程序中从不使用switch语句。

* 与C++不同，Java还提供了一种带标签的break语句，用于跳出多重嵌套的循环语句。有时候，在嵌套很深的循环语句中会发生一些不可预料的事情。此时可能更加希望跳到嵌套的所有循环语句之外。通过添加一些额外的条件判断实现各层循环的检测很不方便。

* 事实上，可以将标签应用到任何语句中，甚至可以应用到if语句或者块语句中

* 许多程序员容易混淆break和continue语句。这些语句完全是可选的，即不使用它们也可以表达同样的逻辑含义。在本书中，将不使用break和continue

* 要想快速地打印一个二维数组的数据元素列表，可以调用：
￼

* Java实际上没有多维数组，只有一维数组。多维数组被解释为“数组的数组。


### 4.1 面向对象程序设计概述

* 传统的结构化程序设计通过设计一系列的过程（即算法）来求解问题。一旦确定了这些过程，就要开始考虑存储数据的方式。这就是Pascal语言的设计者Niklaus Wirth将其著作命名为《算法+数据结构=程序》（Algorithms+Data Structures=Programs,Prentice Hall,1975）的原因。需要注意的是，在Wirth命名的书名中，算法是第一位的，数据结构是第二位的，这就明确地表述了程序员的工作方式。首先要确定如何操作数据，然后再决定如何组织数据，以便于数据操作。而OOP却调换了这个次序，将数据放在第一位，然后再考虑操作数据的算法。

* 从形式上看，封装不过是将数据和行为组合在一个包中，并对对象的使用者隐藏了数据的实现方式。对象中的数据称为实例域（instance field），操纵数据的过程称为方法（method）。对于每个特定的类实例（对象）都有一组特定的实例域值。这些值的集合就是这个对象的当前状态（state）。无论何时，只要向对象发送一个消息，它的状态就有可能发生改变。

* 要想使用OOP，一定要清楚对象的三个主要特性：
● 对象的行为（behavior）——可以对对象施加哪些操作，或可以对对象施加哪些方法？
● 对象的状态（state）——当施加那些方法时，对象如何响应？
● 对象标识（identity）——如何辨别具有相同行为与状态的不同对象？

* 在类之间，最常见的关系有
● 依赖（“uses-a”）
● 聚合（“has-a”）
● 继承（“is-a”）

* 如果类设计的不完善，其他的操作员可以很容易地编写自己的类，以便增强或替代（replace）系统提供的类（作为这个问题的印证：Java的日期类库有些混乱，已经重新设计了两次）。

* 所有的Java对象都存储在堆中。当一个对象包含另一个对象变量时，这个变量依然包含着指向另一个堆对象的指针。

* 类库设计者决定将保存时间与给时间点命名分开。所以标准Java类库分别包含了两个类：一个是用来表示时间点的Date类；另一个是用来表示大家熟悉的日历表示法的LocalDate类。

* 可以用public标记实例域，但这是一种极为不提倡的做法。public数据域允许程序中的任何方法对其进行读取和修改。这就完全破坏了封装。任何类的任何方法都可以修改public域，从我们的经验来看，某些代码将使用这种存取权限，而这并不我们所希望的，因此，这里强烈建议将实例域标记为private。

* 请注意，不要在构造器中定义与实例域重名的局部变量。

* 在Java中，所有的方法都必须在类的内部定义，但并不表示它们是内联方法。是否将某个方法设置为内联方法是Java虚拟机的任务。即时编译器会监视调用那些简洁、经常被调用、没有被重载以及可优化的方法。

* 注意不要编写返回引用可变对象的访问器方法。

* 凭经验可知，如果需要返回一个可变数据域的拷贝，就应该使用clone。

* 在绝大多数的面向对象程序设计语言中，静态域被称为类域。术语“static”只是沿用了C++的叫法，并无实际意义。

* 如果查看一下System类，就会发现有一个setOut方法，它可以将System.out设置为不同的流。读者可能会感到奇怪，为什么这个方法可以修改final变量的值。原因在于，setOut方法是一个本地方法，而不是用Java语言实现的。本地方法可以绕过Java语言的存取控制机制。这是一种特殊的方法，在自己编写程序时，不应该这样处理。

* 可以使用对象调用静态方法。例如，如果harry是一个Employee对象，可以用harry.getNextId( )代替Employee.getNextId( )。不过，这种方式很容易造成混淆，其原因是getNextId方法计算的结果与harry毫无关系。我们建议使用类名，而不是对象来调用静态方法。

* 术语“static”有一段不寻常的历史。起初，C引入关键字static是为了表示退出一个块后依然存在的局部变量。在这种情况下，术语“static”是有意义的：变量一直存在，当再次进入该块时仍然存在。随后，static在C中有了第二种含义，表示不能被其他文件访问的全局变量和函数。为了避免引入一个新的关键字，关键字static被重用了。最后，C++第三次重用了这个关键字，与前面赋予的含义完全不一样，这里将其解释为：属于类且不属于类对象的变量和函数。这个含义与Java相同。

* 为什么NumberFormat类不利用构造器完成这些操作呢？这主要有两个原因：
● 无法命名构造器。构造器的名字必须与类名相同。但是，这里希望将得到的货币实例和百分比实例采用不用的名字。
● 当使用构造器时，无法改变所构造的对象类型。而Factory方法将返回一个DecimalFormat类对象，这是NumberFormat的子类

* Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容

* Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。

* C++有值调用和引用调用。引用参数标有&符号。例如，可以轻松地实现void tripleValue(double& x)方法或void swap(Employee& x, Employee& y)方法实现修改它们的引用参数的目的。

* Java允许重载任何方法，而不只是构造器方法。因此，要完整地描述一个方法，需要指出方法名以及参数类型。这叫做方法的签名（signature）。例如，String类有4个称为indexOf的公有方法。它们的签名是
￼
返回类型不是方法签名的一部分。也就是说，不能有两个名字相同、参数类型也相同却返回不同类型值的方法

* 有个名为System.runFinalizersOnExit(true)的方法能够确保finalizer方法在Java关闭前被调用。不过，这个方法并不安全，也不鼓励大家使用。有一种代替的方法是使用方法Runtime.addShutdownHook添加“关闭钩”（shutdown hook），详细内容请参看API文档。

* JAR文件使用ZIP格式组织文件和子目录。可以使用所有ZIP实用程序查看内部的rt.jar以及其他的JAR文件。

* 在UNIX环境中，类路径中的不同项目之间采用冒号（:）分隔：
￼
而在Windows环境中，则以分号（;）分隔：
￼
在上述两种情况中，句点（.）表示当前目录

* 如果文档中有到其他文件的链接，例如，图像文件（用户界面的组件的图表或图像等），就应该将这些文件放到子目录doc-files中。javadoc实用程序将从源目录拷贝这些目录及其中的文件到文档目录中。在链接中需要使用doc-files目录，例如：<img src=“doc-files/uml.png”alt=“UML diagram”>。


### 5.1 类、超类和子类

* 有些人认为super与this引用是类似的概念，实际上，这样比较并不太恰当。这是因为super不是一个对象的引用，不能将super赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。

* 一个对象变量（例如，变量e）可以指示多种实际类型的现象被称为多态（polymorphism）。在运行时能够自动地选择调用哪个方法的现象称为动态绑定（dynamic binding）。

* 每次调用方法都要进行搜索，时间开销相当大。因此，虚拟机预先为每个类创建了一个方法表（method table），其中列出了所有方法的签名和实际调用的方法。这样一来，在真正调用方法的时候，虚拟机仅查找这个表就行了。

* 有些程序员认为：除非有足够的理由使用多态性，应该将所有的方法都声明为final。事实上，在C++和C#中，如果没有特别地说明，所有的方法都不具有多态性。这两种做法可能都有些偏激。我们提倡在设计类层次时，仔细地思考应该将哪些方法和类声明为final。

* 在标准Java库中包含150多个equals方法的实现，包括使用instanceof检测、调用getClass检测、捕获ClassCastException或者什么也不做。可以查看java.sql. Timestamp类的API文档，在这里实现人员不无尴尬地指出，他们使自己陷入了困境。Timestamp类继承自java.util.Date，而后者的equals方法使用了一个instanceof测试，这样一来就无法覆盖实现equals使之同时做到对称且正确。

* 如果重新定义equals方法，就必须重新定义hashCode方法，以便用户可以将对象插入到散列表中（有关散列表的内容将在第9章中讨论）。
hashCode方法应该返回一个整型数值（也可以是负数），并合理地组合实例域的散列码，以便能够让各个不同的对象产生的散列码更加均匀。

*  static int hash(Object... objects)
返回一个散列码，由提供的所有对象的散列码组合而得到。

* 令人烦恼的是，数组继承了object类的toString方法，数组类型将按照旧的格式打印。

* 一旦能够确认数组列表的大小不再发生变化，就可以调用trimToSize方法。这个方法将存储区域的大小调整为当前元素数量所需要的存储空间数目。垃圾回收器将回收多余的存储空间。
一旦整理了数组列表的大小，添加新元素就需要花时间再次移动存储块，所以应该在确认不会添加任何元素时，再调用trimToSize。


* 一旦能确保不会造成严重的后果，可以用@SuppressWarnings("unchecked")标注来标记这个变量能够接受类型转换

* 自动装箱规范要求boolean、byte、char≤127，介于-128～127之间的short和int被包装到固定的对象中。例如，如果在前面的例子中将a和b初始化为100，对它们进行比较的结果一定成立。

* 请注意，一个Class对象实际上表示的是一个类型，而这个类型未必一定是一种类。例如，int不是类，但int.class是一个Class类型的对象。

* 将forName与newInstance配合起来使用，可以根据存储在字符串中的类名创建一个对象。


* 程序清单5-13显示了如何打印一个类的全部信息的方法。这个程序将提醒用户输入类名，然后输出类中所有的方法和构造器的签名，以及全部域名。

* 实际上，这段代码存在一个问题。由于name是一个私有域，所以get方法将会抛出一个IllegalAccessException。只有利用get方法才能得到可访问域的值。除非拥有访问权限，否则Java安全机制只允许查看任意对象有哪些域，而不允许读取它们的值。
反射机制的默认行为受限于Java的访问控制。然而，如果一个Java程序没有受到安全管理器的控制，就可以覆盖访问控制。为了达到这个目的，需要调用Field、Method或Constructor对象的setAccessible方法

* 这是一种公认的提供toString方法的手段，在编写程序时会发现，它是非常有用的。

* 其中最关键的是Array类中的静态方法newInstance，它能够构造新数组。在调用它时必须提供两个参数，一个是数组的元素类型，一个是数组的长度。

* 上述程序清楚地表明，可以使用method对象实现C（或C#中的委派）语言中函数指针的所有操作。同C一样，这种程序设计风格并不太简便，出错的可能性也比较大。如果在调用方法的时候提供了一个错误的参数，那么invoke方法将会抛出一个异常。


### 6.1 接口

* 在Java程序设计语言中，接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。

* 当然，接口中还有一个没有明确说明的附加要求：在调用x.compareTo(y)的时候，这个compareTo方法必须确实比较两个对象的内容，并返回比较的结果。当x小于y时，返回一个负数；当x等于y时，返回0；否则返回一个正数。

* 当然，这些方法不能引用实例域——接口没有实例。

* 目前为止，通常的做法都是将静态方法放在伴随类中。在标准库中，你会看到成对出现的接口和实用工具类，如Collection/Collections或Path/Paths。

* 在Java API中，你会看到很多接口都有相应的伴随类，这个伴随类中实现了相应接口的部分或所有方法，如Collection/AbstractCollection或MouseListener/MouseAdapter。在Java SE 8中，这个技术已经过时。现在可以直接在接口中实现方法。

* 为接口增加一个非默认方法不能保证“源代码兼容”（source compatible）。

* “类优先”规则可以确保与Java SE 7的兼容性。如果为一个接口增加默认方法，这对于有这个默认方法之前能正常工作的代码不会有任何影响。

* 标准库中只有不到5%的类实现了clone。

* 所有数组类型都有一个public的clone方法

* 如果一个lambda表达式只在某些分支返回一个值，而在另外一些分支不返回值，这是不合法的。例如，(int x) -> { if (x >= 0) return 1; }就不合法。

* 实际上，在Java中，对lambda表达式所能做的也只是能转换为函数式接口。

* Java API在java.util.function包中定义了很多非常通用的函数式接口。其中一个接口BiFunction<T, U, R>描述了参数类型为T和U而且返回类型为R的函数。可以把我们的字符串比较lambda表达式保存在这个类型的变量中

* 流库利用构造器引用解决了这个问题。

* lambda表达式的代码可能会在repeatMessage调用返回很久以后才运行，而那时这个参数变量已经不存在了。如何保留text变量呢？


* 在一个lambda表达式中使用this关键字时，是指创建这个lambda表达式的方法的this参数。

* 使用lambda表达式的重点是延迟执行（deferred execution）。

* 表6-1 常用函数式接口
￼

* 表6-2列出了基本类型int、long和double的34个可能的规范。最好使用这些特殊化规范来减少自动装箱。

* 大多数标准函数式接口都提供了非抽象方法来生成或合并函数。

* 如果设计你自己的接口，其中只有一个抽象方法，可以用@FunctionalInterface注解来标记这个接口。

* 这些方法有很多变体形式。可以为comparing和thenComparing方法提取的键指定一个比较器。例如，可以如下根据人名长度完成排序：


* 如果键函数可以返回null，可能就要用到nullsFirst和nullsLast适配器。这些静态方法会修改现有的比较器，从而在遇到null值时不会抛出异常，而是将这个值标记为小于或大于正常值。

* 外围类的引用在构造器中设置。编译器修改了所有的内部类的构造器，添加一个外围类引用的参数。

* 内部类不能有static方法。Java语言规范对这个限制没有做任何解释。

* 内部类是一种编译器现象，与虚拟机无关。编译器将会把内部类翻译成用$（美元符号）分隔外部类名与内部类名的常规类文件，而虚拟机则对此一无所知

* 总而言之，如果内部类访问了私有数据域，就有可能通过附加在外围类所在包中的其他类访问它们，但做这些事情需要高超的技巧和极大的决心。程序员不可能无意之中就获得对类的访问权限，而必须刻意地构建或修改类文件才有可能达到这个目的。

* 局部类有一个优势，即对外部世界可以完全地隐藏起来。

* 多年来，Java程序员习惯的做法是用匿名内部类实现事件监听器和其他回调。

* 下面的技巧称为“双括号初始化”（double brace initialization），这里利用了内部类语法。

* 在这里，new Object(){}会建立Object的一个匿名子类的一个匿名对象，getEnclosingClass则得到其外围类，也就是包含这个静态方法的类。

* 当然，只有内部类可以声明为static。静态内部类的对象除了没有对生成它的外围类对象的引用特权外，与其他所有内部类完全一样。

* ￼注释：与常规内部类不同，静态内部类可以有静态域和方法。
￼注释：声明在接口中的内部类自动成为static和public类。

* 需要记住，代理类是在程序运行过程中创建的。然而，一旦被创建，就变成了常规类，与虚拟机中的任何其他类没有什么区别。


### 7.1 处理错误

* 异常处理的任务就是将控制权从错误产生的地方转移给能够处理这种情况的错误处理器。

* C++注释：如果熟悉标准C++类库中的异常层次结构，就一定会感到有些困惑。C++有两个基本的异常类，一个是runtime_error；另一个是logic_error。logic_error类相当于Java中的RuntimeException，它表示程序中的逻辑错误；runtime_error类是所有由于不可预测的原因所引发的异常的基类。它相当于Java中的非RuntimeException异常。

* ￼C++注释：在C++与Java中，抛出异常的过程基本相同，只有一点微小的差别。在Java中，只能抛出Throwable子类的对象，而在C++中，却可以抛出任何类型的值。

* 不过，可以有一种更好的处理方法，并且将原始异常设置为新异常的“原因”

* 这里，强烈建议解耦合try/catch和try/finally语句块。这样可以提高代码的清晰度。

* 一种更灵活的方法是使用getStackTrace方法，它会得到StackTraceElement对象的一个数组，可以在你的程序中分析这个对象数组。

* 可以看出，与执行简单的测试相比，捕获异常所花费的时间大大超过了前者，因此使用异常的基本规则是：只在异常情况下使用异常机制。

* 断言机制允许在测试期间向代码中插入一些检查语句。当代码发布时，这些插入的检测语句将会被自动地移走。

* “表达式”部分的唯一目的是产生一个消息字符串。AssertionError对象并不存储表达式的值，因此，不可能在以后得到它。正如JDK文档所描述的那样：如果使用表达式的值，就会鼓励程序员试图从断言中恢复程序的运行，这不符合断言机制的初衷。

* 断言检查只用于开发和测阶段（这种做法有时候被戏称为“在靠近海岸时穿上救生衣，但在海中央时就把救生衣抛掉吧”）。

* 提示：未被任何变量引用的日志记录器可能会被垃圾回收。为了防止这种情况发生，要像上面的例子中一样，用一个静态变量存储日志记录器的一个引用。

* 不一定要通过捕获异常来生成堆栈轨迹。只要在代码的任何位置插入下面这条语句就可以获得堆栈轨迹：
￼

* -Xlint选项告诉编译器对一些普遍容易出现的代码问题进行检查。例如，如果使用下面这条命令编译：
￼
当switch语句中缺少break语句时，编译器就会给出报告（术语“lint”最初用来描述一种定位C程序中潜在问题的工具，现在通常用于描述查找可疑但不违背语法规则的代码问题的工具。）


### 8.1 为什么要使用泛型程序设计

* 类型变量使用大写形式，且比较短，这是很常见的。在Java库中，使用变量E表示集合的元素类型，K和V分别表示表的关键字与值的类型。T（需要时还可以用临近的字母U和S）表示“任意类型”。

* 这个方法是在普通类中定义的，而不是在泛型类中定义的。然而，这是一个泛型方法，可以从尖括号和类型变量看出这一点。注意，类型变量放在修饰符（这里是public static）的后面，返回类型的前面。

* 如果想知道编译器对一个泛型方法调用最终推断出哪种类型，Peter von der Ahé推荐了这样一个窍门：有目的地引入一个错误，并研究所产生的错误消息。

* 读者或许会感到奇怪——在此为什么使用关键字extends而不是implements？毕竟，Comparable是一个接口。下面的记法
￼
表示T应该是绑定类型的子类型（subtype）。T和绑定类型可以是类，也可以是接口。选择关键字extends的原因是更接近子类的概念，并且Java的设计者也不打算在语言中再添加一个新的关键字（如sub）。

* 读者可能想要知道切换限定：class Interval<T extends Serializable & Comparable>会发生什么。如果这样做，原始类型用Serializable替换T，而编译器在必要时要向Comparable插入强制类型转换。为了提高效率，应该将标签（tagging）接口（即没有方法的接口）放在边界列表的末尾。

* 可以使用@SafeVarargs标注来消除创建泛型数组的有关限制

* makePair方法接收一个Supplier<T>，这是一个函数式接口，表示一个无参数而且返回类型为T的函数

* 因此，禁止使用带有类型变量的静态域和方法。

* 既不能抛出也不能捕获泛型类对象。实际上，甚至泛型类扩展Throwable都是不合法的。

* 通过使用泛型类、擦除和@SuppressWarnings注解，就能消除Java类型系统的部分基本限制。

* 直观地讲，带有超类型限定的通配符可以向泛型对象写入，带有子类型限定的通配符可以从泛型对象读取。

* 如果是一名库程序员，一定要习惯于通配符，否则，就会受到用户的责备，还要在代码中随意地添加强制类型转换直至代码可以编译。

* 通配符捕获只有在有许多限制的情况下才是合法的。编译器必须能够确信通配符表达的是单个、确定的类型。例如，ArrayList<Pair<T>>中的T永远不能捕获ArrayList<Pair<? >>中的通配符。数组列表可以保存两个Pair<? >，分别针对？的不同类型。


### 9.1 Java集合框架

* 如果需要一个循环数组队列，就可以使用ArrayDeque类。

* 编程老手会注意到：Iterator接口的next和hasNext方法与Enumeration接口的nextElement和hasMoreElements方法的作用一样。Java集合类库的设计者可以选择使用Enumeration接口。但是，他们不喜欢这个接口累赘的方法名，于是引入了具有较短方法名的新接口。

* 不过还可以做得更好。merge方法可以简化这个常见的操作。如果键原先不存在，下面的调用：
￼
将把word与1关联，否则使用Integer::sum函数组合原值和1（也就是将原值与1求和）。

* 原先这是访问所有映射条目的最高效的方法。如今，只需要使用forEach方法

* 链接散列映射将用访问顺序，而不是插入顺序，对映射条目进行迭代。每次调用get或put，受到影响的条目将从当前的位置删除，并放到条目链表的尾部（只有条目在链表中的位置会受影响，而散列表中的桶不会受影响

* EnumSet类没有公共的构造器。可以使用静态工厂方法构造这个集

* 是否应该将“可选”方法这一技术扩展到用户的设计中呢？我们认为不应该。尽管集合被频繁地使用，其实现代码的风格也未必适用于其他问题领域。集合类库的设计者必须解决一组特别严格且又相互冲突的需求。用户希望类库应该易于学习、使用方便，彻底泛型化，面向通用性，同时又与手写算法一样高效。要同时达到所有目标的要求，或者尽量兼顾所有目标完全是不可能的。但是，在自己的编程问题中，很少遇到这样极端的局限性。应该能够找到一种不必依靠极端衡量“可选的”接口操作来解决这类问题的方案。

* 然而，Java程序设计语言并不是这样实现的。它直接将所有元素转入一个数组，对数组进行排序，然后，再将排序后的序列复制回列表。

* 属性映射（property map）是一个类型非常特殊的映射结构。它有下面3个特性：
● 键与值都是字符串。
● 表可以保存到一个文件中，也可以从文件中加载。
● 使用一个默认的辅助表。


### 14.1 什么是线程

* 但是，更普遍的情况是，线程将简单地将中断作为一个终止的请求。

* 守护线程有时会被初学者错误地使用，他们不打算考虑关机（shutdown）动作。但是，这是很危险的。守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断。

* 但是，这一线程刚刚获得了对bankLock的排它性访问，因此别的线程没有进行存款操作的机会。这就是为什么我们需要条件对象的原因。

* Java设计者以不是很精确的方式采用了监视器概念，Java中的每一个对象有一个内部的锁和内部的条件。如果一个方法用synchronized关键字声明，那么，它表现的就像是一个监视器方法。通过调用wait/notifyAll/notify来访问条件变量。

* Brian Goetz给出了下述“同步格言”:“如果向一个变量写入值，而这个变量接下来可能会被另一个线程读取，或者，从一个变量读值，而这个变量可能是之前被另一个线程写入的，此时必须使用同步”。

* 如果有大量线程要访问相同的原子值，性能会大幅下降，因为乐观更新需要太多次重试。Java SE 8提供了LongAdder和LongAccumulator类来解决这个问题。

* 遗憾的是，Java编程语言中没有任何东西可以避免或打破这种死锁现象。必须仔细设计程序，以确保不会出现死锁。

* 这些集合使用复杂的算法，通过允许并发地访问数据结构的不同部分来使竞争极小化。
与大多数集合不同，size方法不必在常量时间内操作。确定这样的集合当前的大小通常需要遍历。

* 首次增加一个键时通常需要做些特殊的处理。利用merge方法可以非常方便地做到这一点。这个方法有一个参数表示键不存在时使用的初始值。否则，就会调用你提供的函数来结合原值与初始值。（与compute不同，这个函数不处理键。）

* 例如，假设我们希望找出第一个出现次数超过1000次的单词。需要搜索键和值

* 第二种形式还有一个转换器函数，这个函数要先提供，其结果会传递到消费者：

* 乍一看，这些方法名中的parallel可能有些奇怪，因为用户不用关心排序具体怎样完成。不过，API设计者希望清楚地指出排序是并行化的。这样一来，用户就会注意避免使用有副作用的比较器。

* 这个方法的缺点是如果第一个任务恰巧花去了很多时间，则可能不得不进行等待。将结果按可获得的顺序保存起来更有实际意义。可以用ExecutorCompletionService来进行排列。

* Java SE 8的CompletableFuture类提供了一种候选方法。与事件处理器不同，“可完成future”可以“组合”（composed）。

* java.util.concurrent包包含了几个能帮助人们管理相互合作的线程集的类见表14-5。这些机制具有为线程之间的共用集结点模式（common rendezvous patterns）提供的“预置功能”（canned functionality）。如果有一个相互合作的线程集满足这些行为模式之一，那么应该直接重用合适的库类而不要试图提供手工的锁与条件的集合。


## 个人笔记部分


### 3.1 一个简单的Java应用程序

* 千万不要使用这个程序安排退休计划。这里忽略了通货膨胀和所期望的生活水准。  （个人笔记: 哈哈哈）

