# JavaScript高级程序设计（第4版）

 **马特·弗里斯比**


## 划线部分


### 前言

* 他说JavaScript并不是一门真正有内聚力的编程语言，至少形式上不是。

* 浏览器以合规的方式运行绝大多数JavaScript，但Web上随处可见迎合各种浏览器偏好的页面。因此，对JavaScript更准确的定位应该是一组浏览器实现。


### 第1章 什么是JavaScript

* 1995年，JavaScript问世。当时，它的主要用途是代替Perl等服务器端语言处理输入验证。


### 1.1 简短的历史回顾

* 1997年，JavaScript 1.1作为提案被提交给欧洲计算机制造商协会（Ecma）。第39技术委员会（TC39）承担了“标准化一门通用、跨平台、厂商中立的脚本语言的语法和语义”的任务（参见TC39-ECMAScript）。


### 1.2 JavaScript实现

* ECMA-262第6版，俗称ES6、ES2015或ES Harmony（和谐版），于2015年6月发布。这一版包含了大概这个规范有史以来最重要的一批增强特性。ES6正式支持了类、模块、迭代器、生成器、箭头函数、期约、反射、代理和众多新的数据类型。

* ECMA-262第8版，也称为ES8、ES2017，完成于2017年6月。这一版主要增加了异步函数（async/await）、SharedArrayBuffer及Atomics API，以及Object.values()/Object.entries()/Object. getOwnPropertyDescriptors()和字符串填充方法，另外明确支持对象字面量最后的逗号。

* 注意 DOM并非只能通过JavaScript访问，而且确实被其他很多语言实现了。不过对于浏览器来说，DOM就是使用ECMAScript实现的，如今已经成为JavaScript语言的一大组成部分。

* Mozilla开发团队的目标是打造百分之百兼容标准的浏览器，他们的工作也得到了应有的回报。


### 1.3 JavaScript版本

* 作为网景的继承者，Mozilla是唯一仍在延续最初JavaScript版本编号的浏览器厂商。


### 2.1 <script>元素

* 另外，使用了src属性的<script>元素不应该再在<script>和</script>标签中再包含其他JavaScript代码。如果两者都提供的话，则浏览器只会下载并执行脚本文件，从而忽略行内代码。

* <script>元素的一个最为强大、同时也备受争议的特性是，它可以包含来自外部域的JavaScript文件。

* 异步脚本保证会在页面的load事件前执行，但可能会在DOMContentLoaded（参见第17章）之前或之后。Firefox 3.6、Safari 5和Chrome 7支持异步脚本。使用async也会告诉页面你不会使用document.write，不过好的Web开发实践根本就不推荐使用这个方法。

* 自1995年Netscape 2发布以来，所有浏览器都将JavaScript作为默认的编程语言。


### 2.2 行内代码与外部文件

* 虽然可以直接在HTML文件中嵌入JavaScript代码，但通常认为最佳实践是尽可能将JavaScript代码放在外部文件中。不过这个最佳实践并不是明确的强制性规则。


### 2.4 <noscript>元素

* 这个例子是在脚本不可用时让浏览器显示一段话。如果浏览器支持脚本，则用户永远不会看到它。


### 第3章 语言基础

* 任何语言的核心所描述的都是这门语言在最基本的层面上如何工作，涉及语法、操作符、数据类型以及内置功能，在此基础之上才可以构建复杂的解决方案。


### 3.1 语法

* ECMAScript的语法很大程度上借鉴了C语言和其他类C语言，如Java和Perl。熟悉这些语言的开发者，应该很容易理解ECMAScript宽松的语法。

* 按照惯例，ECMAScript标识符使用驼峰大小写形式，即第一个单词的首字母小写，后面每个单词的首字母大写

* 虽然这种写法并不是强制性的，但因为这种形式跟ECMAScript内置函数和对象的命名方式一致，所以算是最佳实践。

* ECMAScript 5增加了严格模式（strict mode）的概念。严格模式是一种不同的JavaScript解析和执行模型，ECMAScript 3的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。

* 即使语句末尾的分号不是必需的，也应该加上。记着加分号有助于防止省略造成的问题，比如可以避免输入内容不完整。此外，加分号也便于开发者通过删除空行来压缩代码（如果没有结尾的分号，只删除空行，则会导致语法错误）。加分号也有助于在某些情况下提升性能，因为解析器会尝试在合适的位置补上分号以纠正语法错误。

* 在控制语句中使用代码块可以让内容更清晰，在需要修改代码时也可以减少出错的可能性。


### 3.3 变量

* ECMAScript变量是松散类型的，意思是变量可以用于保存任何类型的数据。每个变量只不过是一个用于保存任意值的命名占位符。有3个关键字可以声明变量：var、const和let。其中，var在ECMAScript的所有版本中都可以使用，而const和let只能在ECMAScript 6及更晚的版本中使用。

* 关键的问题在于，使用var操作符定义的变量会成为包含它的函数的局部变量。

* 不过，在函数内定义变量时省略var操作符，可以创建一个全局变量

* 注意 虽然可以通过省略var操作符定义全局变量，但不推荐这么做。在局部作用域中定义的全局变量很难维护，也会造成困惑。这是因为不能一下子断定省略var是不是有意而为之。在严格模式下，如果像这样给未声明的变量赋值，则会导致抛出ReferenceError。

* 使用var时，下面的代码不会报错。这是因为使用这个关键字声明的变量会自动提升到函数作用域顶部

* 这就是所谓的“提升”（hoist），也就是把所有变量声明都拉到函数作用域的顶部。此外，反复多次使用var声明同一个变量也没有问题

* let跟var的作用差不多，但有着非常重要的区别。最明显的区别是，let声明的范围是块作用域，而var声明的范围是函数作用域

* let与var的另一个重要的区别，就是let声明的变量不会在作用域中被提升。

* 与var关键字不同，使用let在全局作用域中声明的变量不会成为window对象的属性（var声明的变量则会）。

* 注意 不能使用let进行条件式声明是件好事，因为条件声明是一种反模式，它让程序变得更难理解。如果你发现自己在使用这个模式，那一定有更好的替代方式。

* 在let出现之前，for循环定义的迭代变量会渗透到循环体外部

* 改成使用let之后，这个问题就消失了，因为迭代变量的作用域仅限于for循环块内部

* 在使用var的时候，最常见的问题就是对迭代变量的奇特声明和修改

* 这种每次迭代声明一个独立变量实例的行为适用于所有风格的for循环，包括for-in和for-of循环。

* const的行为与let基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改const声明的变量会导致运行时错误

* const声明的限制只适用于它指向的变量的引用。换句话说，如果const变量引用的是一个对象，那么修改这个对象内部的属性并不违反const的限制

* JavaScript引擎会为for循环中的let声明分别创建独立的变量实例，虽然const变量跟let变量很相似，但是不能用const来声明迭代变量（因为迭代变量会自增）

* 不过，如果你只想用const声明一个不会被修改的for循环变量，那也是可以的。也就是说，每次迭代只是创建一个新变量。这对for-of和for-in循环特别有意义

* ECMAScript 6增加let和const从客观上为这门语言更精确地声明作用域和语义提供了更好的支持。行为怪异的var所造成的各种问题，已经让JavaScript社区为之苦恼了很多年。随着这两个新关键字的出现，新的有助于提升代码质量的最佳实践也逐渐显现。

* 不使用var

* const优先，let次之


### 3.4 数据类型

* ECMAScript有6种简单数据类型（也称为原始类型）: Undefined、Null、Boolean、Number、String和Symbol。

* 因为ECMAScript的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型。typeof操作符就是为此而生的。

* 注意typeof在某些情况下返回的结果可能会让人费解，但技术上讲还是正确的。比如，调用typeof null返回的是"object"。这是因为特殊值null被认为是一个对空对象的引用。

* 注意 严格来讲，函数在ECMAScript中被认为是对象，并不代表一种数据类型。可是，函数也有自己特殊的属性。为此，就有必要通过typeof操作符来区分函数和其他对象。

* 注意 一般来说，永远不用显式地给某个变量设置undefined值。字面值undefined主要用于比较，而且在ECMA-262第3版之前是不存在的。增加这个特殊值的目的就是为了正式明确空对象指针（null）和未初始化变量的区别。

* 在对未初始化的变量调用typeof时，返回的结果是"undefined"，但对未声明的变量调用它时，返回的结果还是"undefined"，这就有点让人看不懂了。

* 注意 即使未初始化的变量会被自动赋予undefined值，但我们仍然建议在声明变量的同时进行初始化。这样，当typeof返回"undefined"时，你就会知道那是因为给定的变量尚未声明，而不是声明了但未初始化。

* 逻辑上讲，null值表示一个空对象指针，这也是给typeof传一个null会返回"object"的原因

* 在定义将来要保存对象值的变量时，建议使用null来初始化，不要使用其他值。这样，只要检查这个变量的值是不是null就可以知道这个变量是否在后来被重新赋予了一个对象的引用

* undefined值是由null值派生而来的，因此ECMA-262将它们定义为表面上相等

* 即使null和undefined有关系，它们的用途也是完全不一样的。如前所述，永远不必显式地将变量值设置为undefined。但null不是这样的。任何时候，只要变量要保存对象，而当时又没有那个对象可保存，就要用null来填充该变量。这样就可以保持null是空对象指针的语义，并进一步将其与undefined区分开来。

* 虽然布尔值只有两个，但所有其他ECMAScript类型的值都有相应布尔值的等价形式。要将一个其他类型的值转换为布尔值，可以调用特定的Boolean()转型函数

* 理解以上转换非常重要，因为像if等流控制语句会自动执行其他类型值到布尔值的转换

* 整数也可以用八进制（以8为基数）或十六进制（以16为基数）字面量表示。对于八进制字面量，第一个数字必须是零（0），然后是相应的八进制数字（数值0~7）。如果字面量中包含的数字超出了应有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数

* 使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值。

* 注意 由于JavaScript保存数值的方式，实际中可能存在正零（+0）和负零（-0）。正零和负零在所有情况下都被认为是等同的，这里特地说明一下。

* 因为存储浮点值使用的内存空间是存储整数值的两倍，所以ECMAScript总是想方设法把值转换为整数。在小数点后面没有数字的情况下，数值就会变成整数。类似地，如果数值本身就是整数，只是小数点后面跟着0（如1.0），那它也会被转换为整数

* 对于非常大或非常小的数值，浮点值可以用科学记数法来表示。科学记数法用于表示一个应该乘以10的给定次幂的数值。ECMAScript中科学记数法的格式要求是一个数值（整数或浮点数）后跟一个大写或小写的字母e，再加上一个要乘的10的多少次幂。

* 浮点值的精确度最高可达17位小数，但在算术计算中远不如整数精确。例如，0.1加0.2得到的不是0.3，而是0.30000000000000004。由于这种微小的舍入错误，导致很难测试特定的浮点值。

* 注意 之所以存在这种舍入错误，是因为使用了IEEE 754数值，这种错误并非ECMAScript所独有。其他使用相同格式的语言也有这个问题。

* 由于内存的限制，ECMAScript并不支持表示这个世界上的所有数值。ECMAScript可以表示的最小数值保存在Number.MIN_VALUE中，这个值在多数浏览器中是5e-324；可以表示的最大数值保存在Number.MAX_VALUE中，这个值在多数浏览器中是1.797693134862315 7e+308。如果某个计算得到的数值结果超出了JavaScript可以表示的范围，那么这个数值会被自动转换为一个特殊的Infinity（无穷）值。任何无法表示的负数以-Infinity（负无穷大）表示，任何无法表示的正数以Infinity（正无穷大）表示

* 要确定一个值是不是有限大（即介于JavaScript能表示的最小值和最大值之间），可以使用isFinite()函数

* 有一个特殊的数值叫NaN，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作失败了（而不是抛出错误）。比如，用0除任意数值在其他语言中通常都会导致错误，从而中止代码执行。但在ECMAScript中，0、+0或-0相除会返回NaN

* NaN有几个独特的属性。首先，任何涉及NaN的操作始终返回NaN（如NaN/10），在连续多步计算时这可能是个问题。其次，NaN不等于包括NaN在内的任何值。

* ECMAScript提供了isNaN()函数。该函数接收一个参数，可以是任意数据类型，然后判断这个参数是否“不是数值”。把一个值传给isNaN()后，该函数会尝试把它转换为数值。某些非数值的值可以直接转换成数值，如字符串"10"或布尔值。

* 注意 虽然不常见，但isNaN()可以用于测试对象。此时，首先会调用对象的valueOf()方法，然后再确定返回的值是否可以转换为数值。如果不能，再调用toString()方法，并测试其返回值。这通常是ECMAScript内置函数和操作符的工作方式

* Number()函数基于如下规则执行转换

* 考虑到用Number()函数转换字符串时相对复杂且有点反常规，通常在需要得到整数时可以优先使用parseInt()函数。parseInt()函数更专注于字符串是否包含数值模式。字符串最前面的空格会被忽略，从第一个非空格字符开始转换。如果第一个字符不是数值字符、加号或减号，parseInt()立即返回NaN。

* 因为不传底数参数相当于让parseInt()自己决定如何解析，所以为避免解析出错，建议始终传给它第二个参数。

* 注意 多数情况下解析的应该都是十进制数，此时第二个参数就要传入10。

* parseFloat()函数的另一个不同之处在于，它始终忽略字符串开头的零。这个函数能识别前面讨论的所有浮点格式，以及十进制格式（开头的零始终被忽略）。十六进制数值始终会返回0。因为parseFloat()只解析十进制值，因此不能指定底数。最后，如果字符串表示整数（没有小数点或者小数点后面只有一个零），则parseFloat()返回整数。

* 字符串数据类型包含一些字符字面量，用于表示非打印字符或有其他用途的字符

* 字符串的长度可以通过其length属性获取

* 这里，变量lang一开始包含字符串"Java"。紧接着，lang被重新定义为包含"Java"和"Script"的组合，也就是"JavaScript"。整个过程首先会分配一个足够容纳10个字符的空间，然后填充上"Java"和"Script"。最后销毁原始的字符串"Java"和字符串"Script"，因为这两个字符串都没有用了。所有处理都是在后台发生的，而这也是一些早期的浏览器（如Firefox 1.0之前的版本和IE6.0）在拼接字符串时非常慢的原因。这些浏览器在后来的版本中都有针对性地解决了这个问题。

* 多数情况下，toString()不接收任何参数。不过，在对数值调用这个方法时，toString()可以接收一个底数参数，即以什么底数来输出数值的字符串表示。

* 如果你不确定一个值是不是null或undefined，可以使用String()转型函数，它始终会返回表示相应类型值的字符串。

* ECMAScript 6新增了使用模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量保留换行字符，可以跨行定义字符串

* 技术上讲，模板字面量不是字符串，而是一种特殊的JavaScript句法表达式，只不过求值后得到的是字符串。模板字面量在定义时立即求值并转换为字符串实例，任何插入的变量也会从它们最接近的作用域中取值。

* 所有插入的值都会使用toString()强制转型为字符串，而且任何JavaScript表达式都可以用于插值。嵌套的模板字符串无须转义

* 将表达式转换为字符串时会调用toString()

* 在插值表达式中可以调用函数和方法

* 标签函数本身是一个常规函数，通过前缀到模板字面量来应用自定义行为，如下例所示。标签函数接收到的参数依次是原始字符串数组和对每个表达式求值的结果。这个函数的返回值是对模板字面量求值得到的字符串。

* 如果你想把这些字符串和对表达式求值的结果拼接起来作为默认返回的字符串，可以这样做

* 使用模板字面量也可以直接获取原始的模板字面量内容（如换行符或Unicode字符），而不是被转换后的字符表示。为此，可以使用默认的String.raw标签函数

* Symbol（符号）是ECMAScript 6新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。

* 凡是可以使用字符串或数值作为属性的地方，都可以使用符号。这就包括了对象字面量属性和Object.defineProperty()/Object.defineProperties()定义的属性。对象字面量只能在计算属性语法中使用符号作为属性。

* 注意 在提到ECMAScript规范时，经常会引用符号在规范中的名称，前缀为@@。比如，@@iterator指的就是Symbol.iterator。

* Symbol.asyncIterator是ES2018规范定义的，因此只有版本非常新的浏览器支持它。

* ECMAScript中的对象其实就是一组数据和功能的集合。对象通过new操作符后跟对象类型的名称来创建。

* 注意 严格来讲，ECMA-262中对象的行为不一定适合JavaScript中的其他对象。比如浏览器环境中的BOM和DOM对象，都是由宿主环境定义和提供的宿主对象。而宿主对象不受ECMA-262约束，所以它们可能会也可能不会继承Object。


### 3.5 操作符

* 无论使用前缀递增还是前缀递减操作符，变量的值都会在语句被求值之前改变。（在计算机科学中，这通常被称为具有副作用。）

* 这4个操作符可以作用于任何值，意思是不限于整数——字符串、布尔值、浮点值，甚至对象都可以。递增和递减操作符遵循如下规则。

* 注意 默认情况下，ECMAScript中的所有整数都表示为有符号数。不过，确实存在无符号整数。对无符号整数来说，第32位不表示符号，因为只有正值。无符号整数比有符号整数的范围更大，因为符号位被用来表示数值了。

* 如果将位操作符应用到非数值，那么首先会使用Number()函数将该值转换为数值（这个过程是自动的），然后再应用位操作。最终结果是数值。

* 实际上，尽管两者返回的结果一样，但位操作的速度快得多。这是因为位操作是在数值的底层表示上完成的。

* 对于负数，有时候差异会非常大。与有符号右移不同，无符号右移会给空位补0，而不管符号位是什么。对正数来说，这跟有符号右移效果相同。但对负数来说，结果就差太多了。无符号右移操作符将负数的二进制表示当成正数的二进制表示来处理。因为负数是其绝对值的二补数，所以右移之后结果变得非常之大

* 对于编程语言来说，布尔操作符跟相等操作符几乎同样重要。如果没有能力测试两个值的关系，那么像if-else和循环这样的语句也没什么用了。

* 逻辑非操作符由一个叹号（!）表示，可应用给ECMAScript中的任何值。这个操作符始终返回布尔值，无论应用到的是什么数据类型。逻辑非操作符首先将操作数转换为布尔值，然后再对其取反。换句话说，逻辑非操作符会遵循如下规则。

* 逻辑与操作符是一种短路操作符，意思就是如果第一个操作数决定了结果，那么永远不会对第二个操作数求值。对逻辑与操作符来说，如果第一个操作数是false，那么无论第二个操作数是什么值，结果也不可能等于true。

* ECMAScript定义了3个乘性操作符：乘法、除法和取模。这些操作符跟它们在Java、C语言及Perl中对应的操作符作用一样，但在处理非数值时，它们也会包含一些自动的类型转换。如果乘性操作符有不是数值的操作数，则该操作数会在后台被使用Number()转型函数转换为数值。这意味着空字符串会被当成0，而布尔值true会被当成1。

* 判断两个变量是否相等是编程中最重要的操作之一。在比较字符串、数值和布尔值是否相等时，过程都很直观。但是在比较两个对象是否相等时，情形就比较复杂了。ECMAScript中的相等和不相等操作符，原本在比较之前会执行类型转换，但很快就有人质疑这种转换是否应该发生。最终，ECMAScript提供了两组操作符。第一组是等于和不等于，它们在比较之前执行转换。第二组是全等和不全等，它们在比较之前不执行转换。

* 注意 由于相等和不相等操作符存在类型转换问题，因此推荐使用全等和不全等操作符。这样有助于在代码中保持数据类型的完整性。

* 在一条语句中同时声明多个变量是逗号操作符最常用的场景。不过，也可以使用逗号操作符来辅助赋值。在赋值时使用逗号操作符分隔值，最终会返回表达式中最后一个值


### 3.6 语句

* 这种多功能性使得for语句在这门语言中使用非常广泛。

* ECMAScript中对象的属性是无序的，因此for-in语句不能保证返回对象属性的顺序。换句话说，所有可枚举的属性都会返回一次，但返回的顺序可能会因浏览器而异。

* 如果for-in循环要迭代的变量是null或undefined，则不执行循环体。

* for-of语句是一种严格的迭代语句，用于遍历可迭代对象的元素

* 使用with语句的主要场景是针对一个对象反复操作，这时候将代码作用域设置为该对象能提供便利

* 警告 由于with语句影响性能且难于调试其中的代码，通常不推荐在产品代码中使用with语句。

* switch语句是与if语句紧密相关的一种流控制语句，从其他语言借鉴而来。ECMAScript中switch语句跟C语言中switch语句的语法非常相似

* 虽然switch语句是从其他语言借鉴过来的，但ECMAScript为它赋予了一些独有的特性。首先，switch语句可以用于所有数据类型（在很多语言中，它只能用于数值），因此可以使用字符串甚至对象。其次，条件的值不需要是常量，也可以是变量或表达式。

* 注意 switch语句在比较每个条件的值时会使用全等操作符，因此不会强制转换数据类型（比如，字符串"10"不等于数值10）。


### 3.7 函数

* ECMAScript中的函数不需要指定是否返回值。任何函数在任何时间都可以使用return语句来返回函数的值，用法是后跟要返回的值。

* 要注意的是，只要碰到return语句，函数就会立即停止执行并退出。

* return语句也可以不带返回值。这时候，函数会立即停止执行并返回undefined。这种用法最常用于提前终止函数执行，并不是为了返回值。

* 注意 最佳实践是函数要么返回值，要么不返回值。只在某个条件下返回值的函数会带来麻烦，尤其是调试时。


### 第4章 变量、作用域与内存

* 相比于其他语言，JavaScript中的变量可谓独树一帜。正如ECMA-262所规定的，JavaScript变量是松散类型的，而且变量不过就是特定时间点一个特定值的名称而已。由于没有规则定义变量必须包含什么数据类型，变量的值和数据类型在脚本生命期内可以改变。这样的变量很有意思，很强大，当然也有不少问题。


### 4.1 原始值与引用值

* 保存原始值的变量是按值（by value）访问的，因为我们操作的就是存储在变量中的实际值。

* 为此，保存引用值的变量是按引用（by reference）访问的。

* 注意 在很多语言中，字符串是使用对象表示的，因此被认为是引用类型。ECMAScript打破了这个惯例。

* 注意，原始类型的初始化可以只使用原始字面量形式。如果使用的是new关键字，则JavaScript会创建一个Object类型的实例，但其行为类似原始值。

* ECMAScript中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。对很多开发者来说，这一块可能会不好理解，毕竟变量有按值和按引用访问，而传参则只有按值传递。

* 结果就是，即使对象是按值传进函数的，obj也会通过引用访问对象。当函数内部给obj设置了name属性时，函数外部的对象也会反映这个变化，因为obj指向的对象保存在全局作用域的堆内存上。

* 当obj在函数内部被重写时，它变成了一个指向本地对象的指针。而那个本地对象在函数执行结束时就被销毁了

* 注意 ECMAScript中函数的参数就是局部变量。

* 按照定义，所有引用值都是Object的实例，因此通过instanceof操作符检测任何引用值和Object构造函数都会返回true。类似地，如果用instanceof检测原始值，则始终会返回false，因为原始值不是对象。


### 4.2 执行上下文与作用域

* 每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript程序的执行流就是通过这个上下文栈进行控制的。

* 代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符。（如果没有找到标识符，那么通常会报错。）

* 这个函数内部之所以能够访问变量color，就是因为可以在作用域链中找到它

* 内部上下文可以通过作用域链访问外部上下文中的一切，但外部上下文无法访问内部上下文中的任何东西。上下文之间的连接是线性的、有序的。每个上下文都可以到上一级上下文中去搜索变量和函数，但任何上下文都不能到下一级上下文中去搜索。

* 注意 函数参数被认为是当前上下文中的变量，因此也跟上下文中的其他变量遵循相同的访问规则。

* 虽然执行上下文主要有全局上下文和函数上下文两种（eval()调用内部存在第三种上下文），但有其他方式来增强作用域链。

* 注意 未经声明而初始化变量是JavaScript编程中一个非常常见的错误，会导致很多问题。为此，读者在初始化变量之前一定要先声明变量。在严格模式下，未经声明就初始化变量会报错。

* ES6新增的let关键字跟var很相似，但它的作用域是块级的，这也是JavaScript中的新概念。块级作用域由最近的一对包含花括号{}界定。换句话说，if块、while块、function块，甚至连单独的块也是let声明变量的作用域。

* let的行为非常适合在循环中声明迭代变量。使用var声明的迭代变量会泄漏到循环外部，这种情况应该避免。

* 严格来讲，let在JavaScript运行时中也会被提升，但由于“暂时性死区”（temporal dead zone）的缘故，实际上不能在声明之前使用let变量。因此，从写JavaScript代码的角度说，let的提升跟var是不一样的。

* 如果想让整个对象都不能修改，可以使用Object.freeze()，这样再给属性赋值时虽然不会报错，但会静默失败

* 注意 开发实践表明，如果开发流程并不会因此而受很大影响，就应该尽可能地多使用const声明，除非确实需要一个将来会重新赋值的变量。这样可以从根本上保证提前发现重新赋值导致的bug。

* 当在特定上下文中为读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。搜索开始于作用域链前端，以给定的名称搜索对应的标识符。如果在局部上下文中找到该标识符，则搜索停止，变量确定；如果没有找到变量名，则继续沿作用域链搜索。（注意，作用域链中的对象也有一个原型链，因此搜索可能涉及每个对象的原型链。）这个过程一直持续到搜索至全局上下文的变量对象。如果仍然没有找到标识符，则说明其未声明

* 注意 标识符查找并非没有代价。访问局部变量比访问全局变量要快，因为不用切换作用域。不过，JavaScript引擎在优化标识符查找上做了很多工作，将来这个差异可能就微不足道了。


### 4.3 垃圾回收

* 垃圾回收过程是一个近似且不完美的方案，因为某块内存是否还有用，属于“不可判定的”问题，意味着靠算法是解决不了的。

* 如何标记未使用的变量也许有不同的实现方式。不过，在浏览器的发展史上，用到过两种主要的标记策略：标记清理和引用计数。

* JavaScript最常用的垃圾回收策略是标记清理（mark-and-sweep）。

* 给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现并不重要，关键是策略

* 引用计数最早由Netscape Navigator 3.0采用，但很快就遇到了严重的问题：循环引用。

* 这个例子在一个DOM对象（element）和一个原生JavaScript对象（myObject）之间制造了循环引用。myObject变量有一个名为element的属性指向DOM对象element，而element对象有一个someObject属性指回myObject对象。由于存在循环引用，因此DOM元素的内存永远不会被回收，即使它已经被从页面上删除了也是如此。

* 把变量设置为null实际上会切断变量与其之前引用值之间的关系。当下次垃圾回收程序运行时，这些值就会被删除，内存也会被回收。

* 比如，根据V8团队2016年的一篇博文的说法：“在一次完整的垃圾回收之后，V8的堆增长策略会根据活跃对象的数量外加一些余量来确定何时再次垃圾回收。”

* 警告在某些浏览器中是有可能（但不推荐）主动触发垃圾回收的。在IE中，window. CollectGarbage()方法会立即触发垃圾回收。在Opera 7及更高版本中，调用window. opera.collect()也会启动垃圾回收程序。

* 不过要注意，解除对一个值的引用并不会自动导致相关内存被回收。解除引用的关键在于确保相关的值已经不在上下文里了，因此它在下次垃圾回收时会被回收。

* 根据JavaScript所在的运行环境，有时候需要根据浏览器使用的JavaScript引擎来采取不同的性能优化策略。截至2017年，Chrome是最流行的浏览器，使用V8 JavaScript引擎。V8在将解释后的JavaScript代码编译为实际的机器码时会利用“隐藏类”。如果你的代码非常注重性能，那么这一点可能对你很重要。

* 动态删除属性与动态添加属性导致的后果一样。最佳实践是把不想要的属性设置为null。这样可以保持隐藏类不变和继续共享，同时也能达到删除引用值供垃圾回收程序回收的效果。

* JavaScript中的内存泄漏大部分是由不合理的引用导致的。

* 定时器也可能会悄悄地导致内存泄漏。

* 使用JavaScript闭包很容易在不知不觉间造成内存泄漏。

* 浏览器决定何时运行垃圾回收程序的一个标准就是对象更替的速度。如果有很多对象被初始化，然后一下子又都超出了作用域，那么浏览器就会采用更激进的方式调度垃圾回收程序运行，这样当然会影响性能。

* 一个策略是使用对象池。在初始化的某一时刻，可以创建一个对象池，用来管理一组可回收的对象。应用程序可以向这个对象池请求一个对象、设置其属性、使用它，然后在操作完成后再把它还给对象池。由于没发生对象初始化，垃圾回收探测就不会发现有对象更替，因此垃圾回收程序就不会那么频繁地运行。

* 如果对象池只按需分配矢量（在对象不存在时创建新的，在对象存在时则复用存在的），那么这个实现本质上是一种贪婪算法，有单调增长但为静态的内存。这个对象池必须使用某种结构维护所有对象，数组是比较好的选择。不过，使用数组来实现，必须留意不要招致额外的垃圾回收。

* 要避免这种动态分配操作，可以在初始化时就创建一个大小够用的数组，从而避免上述先删除再创建的操作。不过，必须事先想好这个数组有多大。

* 注意 静态分配是优化的一种极端形式。如果你的应用程序被垃圾回收严重地拖了后腿，可以利用它提升性能。但这种情况并不多见。大多数情况下，这都属于过早优化，因此不用考虑。


### 第5章 基本引用类型

* 在ECMAScript中，引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”。

* 这行代码创建了引用类型Date的一个新实例，并将它保存在变量now中。Date()在这里就是构造函数，它负责创建一个只有默认属性和方法的简单对象。ECMAScript提供了很多像Date这样的原生引用类型，帮助开发者实现常见的任务。


### 5.1 Date

* ECMAScript的Date类型参考了Java早期版本中的java.util.Date。为此，Date类型将日期保存为自协调世界时（UTC, Universal Time Coordinated）时间1970年1月1日午夜（零时）至今所经过的毫秒数。

* ECMA-262第5版定义了Date.parse()应该支持的日期格式，填充了第3版遗留的空白。所有实现都必须支持下列日期格式

* 传给Date.UTC()的参数是年、零起点月数（1月是0,2月是1，以此类推）、日（1~31）、时（0~23）、分、秒和毫秒。

* ECMAScript还提供了Date.now()方法，返回表示方法执行时日期和时间的毫秒数。

* 现代浏览器在这两个方法的输出上已经趋于一致。在比较老的浏览器上，每个方法返回的结果可能在每个浏览器上都是不同的。这些差异意味着toLocaleString()和toString()可能只对调试有用，不能用于显示。


### 5.2 RegExp

* ECMAScript通过RegExp类型支持正则表达式。正则表达式使用类似Perl的简洁语法来创建

* source：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。

* 正则表达式的另一个方法是test()，接收一个字符串参数。如果输入的文本与模式匹配，则参数返回true，否则返回false。这个方法适用于只想测试模式是否匹配，而不需要实际匹配内容的情况。test()经常用在if语句中

* 注意 正则表达式的valueOf()方法返回正则表达式本身。

* RegExp构造函数本身也有几个属性。（在其他语言中，这种属性被称为静态属性。）这些属性适用于作用域中的所有正则表达式，而且会根据最后执行的正则表达式操作而变化。这些属性还有一个特点，就是可以通过两种不同的方式访问它们。换句话说，每个属性都有一个全名和一个简写。

* RegExp还有其他几个构造函数属性，可以存储最多9个捕获组的匹配项。这些属性通过RegExp.$1~RegExp.$9来访问，分别包含第1~9个捕获组的匹配项。在调用exec()或test()时，这些属性就会被填充

* 注意 RegExp构造函数的所有属性都没有任何Web标准出处，因此不要在生产环境中使用它们。


### 5.3 原始值包装类型

* 为了方便操作原始值，ECMAScript提供了3种特殊的引用类型：Boolean、Number和String。这些类型具有本章介绍的其他引用类型一样的特点，但也具有与各自原始类型对应的特殊行为。每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。

* 在以读模式访问字符串值的任何时候，后台都会执行以下3步：
（1）创建一个String类型的实例；
（2）调用实例上的特定方法；
（3）销毁实例。

* 虽然不推荐显式创建原始值包装类型的实例，但它们对于操作原始值的功能是很重要的。每个原始值包装类型都有相应的一套方法来方便数据操作

* 不过，Boolean对象在ECMAScript中用得很少。不仅如此，它们还容易引起误会，尤其是在布尔表达式中使用Boolean对象时

* 理解原始布尔值和Boolean对象之间的区别非常重要，强烈建议永远不要使用后者

* 与Boolean类型一样，Number类型重写了valueOf()、toLocaleString()和toString()方法。valueOf()方法返回Number对象表示的原始数值，另外两个方法返回数值字符串。toString()方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串

* toFixed()方法返回包含指定小数点位数的数值字符串

* toPrecision()方法会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法形式。这个方法接收一个参数，表示结果中数字的总位数（不包含指数）。

* 与Boolean对象类似，Number对象也为数值提供了重要能力。但是，考虑到两者存在同样的潜在问题，因此并不建议直接实例化Number对象。

* ES6新增了Number.isInteger()方法，用于辨别一个数值是否保存为整数。

* 为了鉴别整数是否在这个范围内，可以使用Number.isSafeInteger()方法

* 注意 要深入了解关于字符编码的内容，推荐Joel Spolsky写的博客文章：“The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses! )”。
另一个有用的资源是Mathias Bynens的博文：“JavaScript's Internal Character Encoding: UCS-2 or UTF-16? ”。

* 为正确解析既包含单码元字符又包含代理对字符的字符串，可以使用codePointAt()来代替charCodeAt()。跟使用charCodeAt()时类似，codePointAt()接收16位码元的索引并返回该索引位置上的码点（code point）。码点是Unicode中一个字符的完整标识。比如，"c"的码点是0x0063，而"☺"的码点是0x1F60A。码点可能是16位，也可能是32位，而codePointAt()方法可以从指定码元位置识别完整的码点。

* 迭代字符串可以智能地识别代理对的码点：
￼     console.log([..."ab☺de"]); // ["a", "b", "☺", "d", "e"]

* 比较操作符不在乎字符看起来是什么样的，因此这3个字符互不相等。

* 为解决这个问题，Unicode提供了4种规范化形式，可以将类似上面的字符规范化为一致的格式，无论底层字符的代码是什么。

* 选择同一种规范化形式可以让比较操作符返回正确的结果

* 对slice()和substring()而言，第二个参数是提取结束的位置（即该位置之前的字符会被提取出来）。对substr()而言，第二个参数表示返回的子字符串数量。任何情况下，省略第二个参数都意味着提取到字符串末尾。

* ECMAScript在所有字符串上都提供了trim()方法。这个方法会创建字符串的一个副本，删除前、后所有空格符，再返回结果

* 在for-of循环中可以通过这个迭代器按序访问每个字符

* String类型专门为在字符串中实现模式匹配设计了几个方法。

* 使用这些特殊的序列，可以在替换文本中使用之前匹配的内容

* let text = "cat, bat, sat, fat";￼     result=text.replace(/(.at)/g, "word($1)");￼     console.log(result);  //word(cat), word(bat), word(sat), word(fat)

* 使用函数作为第二个参数可以更细致地控制替换过程

* 最后一个方法是localeCompare()，这个方法比较两个字符串，返回如下3个值中的一个。

* localeCompare()的独特之处在于，实现所在的地区（国家和语言）决定了这个方法如何比较字符串。


### 5.4 单例内置对象

* Global对象是ECMAScript中最特别的对象，因为代码不会显式地访问它。

* encodeURI()和encodeURIComponent()方法用于编码统一资源标识符（URI），以便传给浏览器。有效的URI不能包含某些字符，比如空格。使用URI编码方法来编码URI可以让浏览器能够理解它们，同时又以特殊的UTF-8编码替换掉所有无效字符。

* 这两个方法的主要区别是，encodeURI()不会编码属于URL组件的特殊字符，比如冒号、斜杠、问号、井号，而encodeURIComponent()会编码它发现的所有非标准字符。

* 注意 一般来说，使用encodeURIComponent()应该比使用encodeURI()的频率更高，这是因为编码查询字符串参数比编码基准URI的次数更多。

* 注意 URI方法encodeURI()、encodeURIComponent()、decodeURI()和decodeURI-Component()取代了escape()和unescape()方法，后者在ECMA-262第3版中就已经废弃了。URI方法始终是首选方法，因为它们对所有Unicode字符进行编码，而原来的方法只能正确编码ASCII字符。不要在生产环境中使用escape()和unescape()。

* 最后一个方法可能是整个ECMAScript语言中最强大的了，它就是eval()。这个方法就是一个完整的ECMAScript解释器，它接收一个参数，即一个要执行的ECMAScript（JavaScript）字符串。

* 通过eval()定义的任何变量和函数都不会被提升，这是因为在解析代码的时候，它们是被包含在一个字符串中的。

* 注意 解释代码字符串的能力是非常强大的，但也非常危险。在使用eval()的时候必须极为慎重，特别是在解释用户输入的内容时。因为这个方法会对XSS利用暴露出很大的攻击面。恶意用户可能插入会导致你网站或应用崩溃的代码。

* 虽然ECMA-262没有规定直接访问Global对象的方式，但浏览器将window对象实现为Global对象的代理。因此，所有全局作用域中声明的变量和函数都变成了window的属性。

* 另一种获取Global对象的方式是使用如下的代码：
￼     let global = function() {￼       return this;￼     }();
这段代码创建一个立即调用的函数表达式，返回了this的值。如前所述，当一个函数在没有明确（通过成为某个对象的方法，或者通过call()/apply()）指定this值的情况下执行时，this值等于Global对象。因此，调用一个简单返回this的函数是在任何执行上下文中获取Global对象的通用方式。

* 注意 Math对象上提供的计算要比直接在JavaScript实现的快得多，因为Math对象上的计算使用了JavaScript引擎中更高效的实现和处理器指令。但使用Math计算的问题是精度会因浏览器、操作系统、指令集和硬件而异。

* 接下来是用于把小数值舍入为整数的4个方法：Math.ceil()、Math.floor()、Math.round()和Math.fround()。

* 很多时候，通过函数来算出可选总数和最小可能的值可能更方便

* 注意 Math.random()方法在这里出于演示目的是没有问题的。如果是为了加密而需要生成随机数（传给生成器的输入需要较高的不确定性），那么建议使用window.crypto. getRandomValues()。


### 5.5 小结

* JavaScript比较独特的一点是，函数实际上是Function类型的实例，也就是说函数也是对象。因为函数也是对象，所以函数也有方法，可以用于增强其能力。


### 6.1 Object

* 在最后一个属性后面加上逗号在非常老的浏览器中会导致报错，但所有现代浏览器都支持这种写法。

* 注意 在使用对象字面量表示法定义对象时，并不会实际调用Object构造函数。

* 实上，对象字面量已经成为给函数传递大量可选参数的主要方式

* 注意 这种模式非常适合函数有大量可选参数的情况。一般来说，命名参数更直观，但在可选参数过多的时候就显得笨拙了。最好的方式是对必选参数使用命名参数，再通过一个对象字面量来封装多个可选参数。

* 通常，点语法是首选的属性存取方式，除非访问属性时必须使用变量。


### 6.2 Array

* 但跟其他语言不同的是，数组中每个槽位可以存储任意类型的数据。这意味着可以创建一个数组，它的第一个元素是字符串，第二个元素是数值，第三个是对象。

* 另一种创建数组的方式是使用数组字面量（array literal）表示法。数组字面量是在中括号中包含以逗号分隔的元素列表

* Array构造函数还有两个ES6新增的用于创建数组的静态方法：from()和of()。from()用于将类数组结构转换为数组实例，而of()用于将一组参数转换为数组实例。

* Array.from()还接收第二个可选的映射函数参数。这个函数可以直接增强新数组的值，而无须像调用Array.from().map()那样先创建一个中间数组。还可以接收第三个可选参数，用于指定映射函数中this的值。但这个重写的this值在箭头函数中不适用。
￼     const a1 = [1, 2, 3, 4];￼     const a2 = Array.from(a1, x => x＊＊2);￼     const a3 = Array.from(a1, function(x) {return x＊＊this.exponent}, {exponent: 2});￼     console.log(a2);   // [1, 4, 9, 16]￼     console.log(a3);   // [1, 4, 9, 16]

* Array.of()可以把一组参数转换为数组。

* 使用数组字面量初始化数组时，可以使用一串逗号来创建空位（hole）。ECMAScript会将逗号之间相应索引位置的值当成空位，ES6规范重新定义了该如何处理这些空位。

* 注意 由于行为不一致和存在性能隐患，因此实践中要避免使用数组空位。如果确实需要空位，则可以显式地用undefined值代替。

* 如果把一个值设置给超过数组最大索引的索引，就像示例中的colors[3]，则数组长度会自动扩展到该索引值加1（示例中设置的索引3，所以数组长度变成了4）。

* 数组length属性的独特之处在于，它不是只读的。通过修改length属性，可以从数组末尾删除或添加元素。

* 使用length属性可以方便地向数组末尾添加元素

* 一个经典的ECMAScript问题是判断一个对象是不是数组。在只有一个网页（因而只有一个全局作用域）的情况下，使用instanceof操作符就足矣

* 为解决这个问题，ECMAScript提供了Array.isArray()方法。这个方法的目的就是确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的。

* 使用ES6的解构可以非常容易地在循环中拆分键/值对

* ES6新增了两个方法：批量复制方法copyWithin()，以及填充数组方法fill()。这两个方法的函数签名类似，都需要指定既有数组实例上的一个范围，包含开始索引，不包含结束索引。使用这个方法不会改变数组的大小。

* 使用fill()方法可以向一个已有的数组中插入全部或部分相同的值。开始索引用于指定开始填充的位置，它是可选的。如果不提供结束索引，则一直填充到数组末尾。负值索引从数组末尾开始计算。也可以将负索引想象成数组长度加上它得到的一个正索引

* 与fill()不同，copyWithin()会按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置。开始索引和结束索引则与fill()使用同样的计算方法

* toString()返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串。也就是说，对数组的每个值都会调用其toString()方法，以得到最终的字符串。

* 如果想使用不同的分隔符，则可以使用join()方法。join()方法接收一个参数，即字符串分隔符，返回包含所有项的字符串。

* 注意 如果数组中某一项是null或undefined，则在join()、toLocaleString()、toString()和valueOf()返回的结果中会以空字符串表示。

* ECMAScript给数组提供几个方法，让它看起来像是另外一种数据结构。

* 因为有了在数据末尾添加数据的push()方法，所以要模拟队列就差一个从数组开头取得数据的方法了。这个数组方法叫shift()，它会删除数组的第一项并返回它，然后数组长度减1。使用shift()和push()，可以把数组当成队列来使用

* ECMAScript也为数组提供了unshift()方法。顾名思义，unshift()就是执行跟shift()相反的操作：在数组开头添加任意多个值，然后返回新的数组长度。通过使用unshift()和pop()，可以在相反方向上模拟队列，即在数组开头添加新数据，在数组末尾取得数据

* 数组有两个方法可以用来对元素重新排序：reverse()和sort()。

* 默认情况下，sort()会按照升序重新排列数组元素，即最小的值在前面，最大的值在后面。为此，sort()会在每一项上调用String()转型函数，然后比较字符串来决定顺序。即使数组的元素都是数值，也会先把数组转换为字符串再比较、排序。

* 很明显，这在多数情况下都不是最合适的。为此，sort()方法可以接收一个比较函数，用于判断哪个值应该排在前面。

* 比较函数接收两个参数，如果第一个参数应该排在第二个参数前面，就返回负值；如果两个参数相等，就返回0；如果第一个参数应该排在第二个参数后面，就返回正值。

* 此外，这个比较函数还可简写为一个箭头函数：
￼     let values = [0, 1, 5, 10, 15];￼     values.sort((a, b) => a < b ? 1 : a > b ? -1 : 0);￼     alert(values); // 15,10,5,1,0

* 当然，如果只是想反转数组的顺序，reverse()更简单也更快。

* 注意 reverse()和sort()都返回调用它们的数组的引用。

* 如果数组的元素是数值，或者是其valueOf()方法返回数值的对象（如Date对象），这个比较函数还可以写得更简单，因为这时可以直接用第二个值减去第一个值

* concat()方法可以在现有数组全部元素基础上创建一个新数组。

* 打平数组参数的行为可以重写，方法是在参数数组上指定一个特殊的符号：Symbol.isConcat-Spreadable。这个符号能够阻止concat()打平参数数组。相反，把这个值设置为true可以强制打平类数组对象

* 注意 如果slice()的参数有负值，那么就以数值长度加上这个负值的结果确定位置。比如，在包含5个元素的数组上调用slice(-2, -1)，就相当于调用slice(3,4)。如果结束位置小于开始位置，则返回空数组。

* 或许最强大的数组方法就属splice()了，使用它的方式可以有很多种。splice()的主要目的是在数组中间插入元素，但有3种不同的方式使用这个方法。

* splice()方法始终返回这样一个数组，它包含从数组中被删除的元素（如果没有删除元素，则返回空数组）。

* ECMAScript提供两类搜索数组的方法：按严格相等搜索和按断言函数搜索。

* find()和findIndex()方法使用了断言函数。这两个方法都从数组的最小索引开始。find()返回第一个匹配的元素，findIndex()返回第一个匹配元素的索引。这两个方法也都接收第二个可选的参数，用于指定断言函数内部this的值。

* ECMAScript为数组定义了5个迭代方法。每个方法接收两个参数

* 在这些方法中，every()和some()是最相似的，都是从数组中搜索符合某个条件的元素。对every()来说，传入的函数必须对每一项都返回true，它才会返回true；否则，它就返回false。而对some()来说，只要有一项让传入的函数返回true，它就会返回true。

* 最后，再来看一看forEach()方法。这个方法只会对每一项运行传入的函数，没有返回值。本质上，forEach()方法相当于使用for循环遍历数组。

* ECMAScript为数组提供了两个归并方法：reduce()和reduceRight()。

* 可以使用reduce()函数执行累加数组中所有数值的操作，比如：
￼     let values = [1, 2, 3, 4, 5];￼     let sum = values.reduce((prev, cur, index, array) => prev + cur);￼     alert(sum);   // 15

* 究竟是使用reduce()还是reduceRight()，只取决于遍历数组元素的方向。除此之外，这两个方法没什么区别。


### 6.3 定型数组

* 定型数组（typed array）是ECMAScript新增的结构，目的是提升向原生库传输数据的效率。

* 注意 SharedArrayBuffer是ArrayBuffer的一个变体，可以无须复制就在执行上下文间传递它。

* ArrayBuffer()是一个普通的JavaScript构造函数，可用于在内存中分配特定数量的字节空间。

* ArrayBuffer一经创建就不能再调整大小。不过，可以使用slice()复制其全部或部分到一个新实例中

* 不能仅通过对ArrayBuffer的引用就读取或写入其内容。要读取或写入ArrayBuffer，就必须通过视图。视图有不同的类型，但引用的都是ArrayBuffer中存储的二进制数据。

* 第一种允许你读写ArrayBuffer的视图是DataView。这个视图专为文件I/O和网络I/O设计，其API支持对缓冲数据的高度控制，但相比于其他类型的视图性能也差一些。

* JavaScript运行时所在系统的原生字节序决定了如何读取或写入字节，但DataView并不遵守这个约定。对一段内存而言，DataView是一个中立接口，它会遵循你指定的字节序。DataView的所有API方法都以大端字节序作为默认值，但接收一个可选的布尔值参数，设置为true即可启用小端字节序。

* DataView完成读、写操作的前提是必须有充足的缓冲区，否则就会抛出RangeError

* DataView在写入缓冲里会尽最大努力把一个值转换为适当的类型，后备为0。如果无法转换，则抛出错误

* 设计定型数组的目的就是提高与WebGL等原生库交换二进制数据的效率。

* 定型数组的构造函数和实例都有一个BYTES_PER_ELEMENT属性，返回该类型数组中每个元素的大小

* 定型数组同样使用数组缓冲来存储数据，而数组缓冲无法调整大小。因此，下列方法不适用于定型数组

* 除了8种元素类型，还有一种“夹板”数组类型：Uint8ClampedArray，不允许任何方向溢出。超出最大值255的值会被向下舍入为255，而小于最小值0的值会被向上舍入为0。


### 6.4 Map

* 作为ECMAScript 6的新增特性，Map是一种新的集合类型，为这门语言带来了真正的键/值存储机制。Map的大多数特性都可以通过Object类型实现，但二者之间还是存在一些细微的差异。具体实践中使用哪一个，还是值得细细甄别。


* 与Object只能使用数值、字符串或符号作为键不同，Map可以使用任何JavaScript数据类型作为键。Map内部使用SameValueZero比较操作（ECMAScript规范内部定义，语言中不能使用），基本上相当于使用严格对象相等的标准来检查键的匹配性。与Object类似，映射的值是没有限制的。

* 注意 SameValueZero是ECMAScript规范新增的相等性比较算法。关于ECMAScript的相等性比较，可以参考MDN文档中的文章“Equality Comparisons and Sameness”。

* 与Object类型的一个主要差异是，Map实例会维护键值对的插入顺序，因此可以根据插入顺序执行迭代操作。

* 因为entries()是默认迭代器，所以可以直接对映射实例使用扩展操作，把映射转换为数组

* 如果不使用迭代器，而是使用回调方式，则可以调用映射的forEach(callback, opt_thisArg)方法并传入回调，依次迭代每个键/值对。传入的回调接收可选的第二个参数，这个参数用于重写回调内部this的值

* 键和值在迭代器遍历时是可以修改的，但映射内部的引用则无法修改。当然，这并不妨碍修改作为键或值的对象内部的属性，因为这样并不影响它们在映射实例中的身份

* 对于多数Web开发任务来说，选择Object还是Map只是个人偏好问题，影响不大。不过，对于在乎内存和性能的开发者来说，对象和映射之间确实存在显著的差别。

* 不同浏览器的情况不同，但给定固定大小的内存，Map大约可以比Object多存储50%的键/值对。

* 而对大多数浏览器引擎来说，Map的delete()操作都比插入和查找更快。如果代码涉及大量删除操作，那么毫无疑问应该选择Map。


### 6.5 WeakMap

* WeakMap中的“weak”（弱），描述的是JavaScript垃圾回收程序对待“弱映射”中键的方式。

* WeakMap实例之所以限制只能用对象作为键，是为了保证只有通过键对象的引用才能取得值。如果允许原始值，那就没办法区分初始化时使用的字符串字面量和初始化之后使用的一个相等的字符串了。


* WeakMap实例与现有JavaScript对象有着很大不同，可能一时不容易说清楚应该怎么使用它。这个问题没有唯一的答案，但已经出现了很多相关策略。

* 因为WeakMap实例不会妨碍垃圾回收，所以非常适合保存关联元数据。


### 6.6 Set

* ECMAScript 6新增的Set是一种新集合类型，为这门语言带来集合数据结构。Set在很多方面都像是加强的Map，这是因为它们的大多数API和行为都是共有的。


* 初始化之后，可以使用add()增加值，使用has()查询，通过size取得元素数量，以及使用delete()和clear()删除元素

* Set会维护值插入时的顺序，因此支持按顺序迭代。

* 不要修改已有的集合实例。union(a, b)或a.union(b)应该返回包含结果的新集合实例。


### 6.7 WeakSet

* 这样，只要WeakSet中任何元素从DOM树中被删除，垃圾回收程序就可以忽略其存在，而立即释放其内存（假设没有其他地方引用这个对象）。


### 6.8 迭代与扩展操作

* 这也意味着所有这些类型都兼容扩展操作符。扩展操作符在对可迭代对象执行浅复制时特别有用，只需简单的语法就可以复制整个对象：


### 7.1 理解迭代

* ES5新增了Array.prototype.forEach()方法，向通用迭代需求迈进了一步（但仍然不够理想）


### 7.2 迭代器模式

* 注意 迭代器维护着一个指向可迭代对象的引用，因此迭代器会阻止垃圾回收程序回收可迭代对象。


### 8.1 理解对象

* 注意 在ECMAScript 5以前，开发者会使用两个非标准的访问创建访问器属性：__define-Getter__()和__defineSetter__()。这两个方法最早是Firefox引入的，后来Safari、Chrome和Opera也实现了。

* 为改善这类情况，ECMAScript 6规范新增了Object.is()，这个方法与===很像，但同时也考虑到了上述边界情形。

* 在引入可计算属性之前，如果想使用变量的值作为属性，那么必须先声明对象，然后使用中括号语法来添加属性。换句话说，不能在对象字面量中直接动态命名属性。

* 有了可计算属性，就可以在对象字面量中完成动态属性赋值。中括号包围的对象属性键告诉运行时将其作为JavaScript表达式而不是字符串来求值

* 新的简写方法的语法遵循同样的模式，但开发者要放弃给函数表达式命名（不过给作为方法的函数命名通常没什么用）。相应地，这样也可以明显缩短方法声明。

* ECMAScript 6新增了对象解构语法，可以在一条语句中使用嵌套数据实现一个或多个赋值操作。

* 在函数参数列表中也可以进行解构赋值。对参数的解构赋值不会影响arguments对象，但可以在函数签名中声明在函数体内使用局部变量


### 8.2 创建对象

* 注意 不要误会：采用面向对象编程模式的JavaScript代码还是应该使用ECMAScript 6的类。但不管怎么说，理解ES6类出现之前的惯例总是有益无害的。特别是ES6的类定义本身就相当于对原有结构的封装。因此，在介绍ES6的类之前，本书会循序渐进地介绍被类取代的那些底层概念。

* 另外，要注意函数名Person的首字母大写了。按照惯例，构造函数名称的首字母都是要大写的，非构造函数则以小写字母开头。这是从面向对象编程语言那里借鉴的，有助于在ECMAScript中区分构造函数和普通函数。毕竟ECMAScript的构造函数就是能创建对象的函数。

* 构造函数与普通函数唯一的区别就是调用方式不同。除此之外，构造函数也是函数。并没有把某个函数定义为构造函数的特殊语法。任何函数只要使用new操作符调用就是构造函数，而不使用new操作符调用的函数就是普通函数。

* 警告 Object.setPrototypeOf()可能会严重影响代码性能。Mozilla文档说得很清楚：“在所有浏览器和JavaScript引擎中，修改继承关系的影响都是微妙且深远的。这种影响并不仅是执行Object.setPrototypeOf()语句那么简单，而是会涉及所有访问了那些修改过[[Prototype]]的对象的代码。”

* 虽然可以通过实例读取原型对象上的值，但不可能通过实例重写这些值。如果在实例上添加了一个与原型对象中同名的属性，那就会在实例上创建这个属性，这个属性会遮住原型对象上的属性。

* 要获得对象上所有可枚举的实例属性，可以使用Object.keys()方法。这个方法接收一个对象作为参数，返回包含该对象所有可枚举属性名称的字符串数组。

* for-in循环、Object.keys()、Object.getOwnPropertyNames()、Object.getOwnProperty-Symbols()以及Object.assign()在属性枚举顺序方面有很大区别。for-in循环和Object.keys()的枚举顺序是不确定的，取决于JavaScript引擎，可能因浏览器而异。
Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()和Object.assign()的枚举顺序是确定性的。先以升序枚举数值键，然后以插入顺序枚举字符串和符号键。在对象字面量中定义的键以它们逗号分隔的顺序插入。

* 在JavaScript有史以来的大部分时间内，迭代对象属性都是一个难题。ECMAScript 2017新增了两个静态方法，用于将对象内容转换为序列化的——更重要的是可迭代的——格式。这两个静态方法Object.values()和Object.entries()接收一个对象，返回它们内容的数组。Object.values()返回对象值的数组，Object.entries()返回键/值对的数组。

* 原型模式之所以重要，不仅体现在自定义类型上，而且还因为它也是实现所有原生引用类型的模式。所有原生引用类型的构造函数（包括Object、Array、String等）都在原型上定义了实例方法。

* 注意 尽管可以这么做，但并不推荐在产品环境中修改原生对象原型。这样做很可能造成误会，而且可能引发命名冲突（比如一个名称在某个浏览器实现中不存在，在另一个实现中却存在）。另外还有可能意外重写原生的方法。推荐的做法是创建一个自定义的类，继承原生类型。


### 8.3 继承

* 另一个要理解的重点是，以对象字面量方式创建原型方法会破坏之前的原型链，因为这相当于重写了原型链。

* ECMAScript 5通过增加Object.create()方法将原型式继承的概念规范化了。这个方法接收两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选）。在只有一个参数时，Object.create()与这里的object()方法效果相同

* 寄生式组合继承可以算是引用类型继承的最佳模式。


### 8.4 类

* 类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但这些都不是必需的。空的类定义照样有效。默认情况下，类定义中的代码都在严格模式下执行。

* 默认情况下，类构造函数会在执行之后返回this对象。构造函数返回的对象会被用作实例化的对象，如果没有什么引用新创建的this对象，那么这个对象会被销毁。不过，如果返回的不是this对象，而是其他对象，那么这个对象不会通过instanceof操作符检测出跟类有关联，因为这个对象的原型指针并没有被修改。

* 注意 类定义中之所以没有显式支持添加数据成员，是因为在共享目标（原型和类）上添加可变（可修改）数据成员是一种反模式。一般来说，对象实例应该独自拥有通过this引用的数据。

* 注意 extends关键字也可以在类表达式中使用，因此let Bar = class extends Foo {}是有效的语法。

* 注意 Object.assign()方法是为了混入对象行为而设计的。只有在需要混入类的行为时才有必要自己实现混入表达式。如果只是需要混入多个对象的属性，那么使用Object.assign()就可以了。

* 注意 很多JavaScript框架（特别是React）已经抛弃混入模式，转向了组合模式（把方法提取到独立的类和辅助对象中，然后把它们组合起来，但不使用继承）。这反映了那个众所周知的软件设计原则：“组合胜过继承（composition over inheritance）。”这个设计原则被很多人遵循，在代码设计中能提供极大的灵活性。


### 8.5 小结

* JavaScript的继承主要通过原型链来实现。原型链涉及把构造函数的原型赋值为另一个类型的实例。这样一来，子类就可以访问父类的所有属性和方法，就像基于类的继承那样。原型链的问题是所有继承的属性和方法都会在对象实例间共享，无法做到实例私有。盗用构造函数模式通过在子类构造函数中调用父类构造函数，可以避免这个问题。这样可以让每个实例继承的属性都是私有的，但要求类型只能通过构造函数模式来定义（因为子类不能访问父类原型上的方法）。目前最流行的继承模式是组合继承，即通过原型链继承共享的属性和方法，通过盗用构造函数继承实例属性。


### 第9章 代理与反射

* 注意 在ES6之前，ECMAScript中并没有类似代理的特性。由于代理是一种新的基础性语言能力，很多转译程序都不能把代理行为转换为之前的ECMAScript代码，因为代理的行为实际上是无可替代的。为此，代理和反射只在百分之百支持它们的平台上有用。可以检测代理是否存在，不存在则提供后备代码。不过这会导致代码冗余，因此并不推荐。


### 9.1 代理基础

* 注意 捕获器（trap）是从操作系统中借用的概念。在操作系统中，捕获器是程序流中的一个同步中断，可以暂停程序流，转而执行一段子例程，之后再返回原始程序流。

* 使用捕获器几乎可以改变所有基本方法的行为，但也不是没有限制。根据ECMAScript规范，每个捕获的方法都知道目标对象上下文、捕获函数签名，而捕获处理程序的行为必须遵循“捕获器不变式”（trap invariant）。捕获器不变式因方法不同而异，但通常都会防止捕获器定义出现过于反常的行为。


### 第10章 函数

* 函数是ECMAScript中最有意思的部分之一，这主要是因为函数实际上是对象。每个函数都是Function类型的实例，而Function也有属性和方法，跟其他引用类型一样。因为函数是对象，所以函数名就是指向函数对象的指针，而且不一定与函数本身紧密绑定。

* 还有一种定义函数的方式与函数表达式很像，叫作“箭头函数”

* 最后一个参数始终会被当成函数体，而之前的参数都是新函数的参数。

* 注意 这几种实例化函数对象的方式之间存在微妙但重要的差别，本章后面会讨论。无论如何，通过其中任何一种方式都可以创建函数。


### 10.1 箭头函数

* 如果只有一个参数，那也可以不用括号。只有没有参数，或者多个参数的情况下，才需要使用括号

* 箭头函数也可以不用大括号，但这样会改变函数的行为。使用大括号就说明包含“函数体”，可以在一个函数中包含多条语句，跟常规的函数一样。如果不使用大括号，那么箭头后面就只能有一行代码，比如一个赋值操作，或者一个表达式。而且，省略大括号会隐式返回这行代码的值

* 箭头函数虽然语法简洁，但也有很多场合不适用。箭头函数不能使用arguments、super和new.target，也不能用作构造函数。此外，箭头函数也没有prototype属性。


### 10.2 函数名

* 注意，使用不带括号的函数名会访问函数指针，而不会执行函数。

* ECMAScript 6的所有函数对象都会暴露一个只读的name属性，其中包含关于函数的信息。多数情况下，这个属性中保存的就是一个函数标识符，或者说是一个字符串化的变量名。即使函数没有名称，也会如实显示成空字符串。如果它是使用Function构造函数创建的，则会标识成"anonymous"


### 10.3 理解参数

* ECMAScript函数的参数跟大多数其他语言不同。ECMAScript函数既不关心传入的参数个数，也不关心这些参数的数据类型。定义函数时要接收两个参数，并不意味着调用时就传两个参数。你可以传一个、三个，甚至一个也不传，解释器都不会报错。

* 之所以会这样，主要是因为ECMAScript函数的参数在内部表现为一个数组。函数被调用时总会接收一个数组，但函数并不关心这个数组中包含什么。如果数组中什么也没有，那没问题；如果数组的元素超出了要求，那也没问题。事实上，在使用function关键字定义（非箭头）函数时，可以在函数内部访问arguments对象，从中取得传进来的每个参数值。

* arguments对象是一个类数组对象（但不是Array的实例），因此可以使用中括号语法访问其中的元素（第一个参数是arguments[0]，第二个参数是arguments[1]）。而要确定传进来多少个参数，可以访问arguments.length属性

* 与其他语言不同，在ECMAScript中的命名参数不会创建让之后的调用必须匹配的函数签名。这是因为根本不存在验证命名参数的机制。

* arguments对象的另一个有意思的地方就是，它的值始终会与对应的命名参数同步。

* 对于命名参数而言，如果调用函数时没有传这个参数，那么它的值就是undefined。这就类似于定义了变量而没有初始化。比如，如果只给doAdd()传了一个参数，那么num2的值就是undefined。


* 如果函数是使用箭头语法定义的，那么传给函数的参数将不能使用arguments关键字访问，而只能通过定义的命名参数访问。

* 注意 ECMAScript中的所有参数都按值传递的。不可能按引用传递参数。如果把对象作为参数传递，那么传递的值就是这个对象的引用。


### 10.4 没有重载

* ECMAScript函数不能像传统编程那样重载。在其他语言比如Java中，一个函数可以有两个定义，只要签名（接收参数的类型和数量）不同就行。如前所述，ECMAScript函数没有签名，因为参数是由包含零个或多个值的数组表示的。没有函数签名，自然也就没有重载。

* 如果在ECMAScript中定义了两个同名函数，则后定义的会覆盖先定义的。


### 10.5 默认参数值

* ECMAScript 6之后就不用这么麻烦了，因为它支持显式定义默认参数了。下面就是与前面代码等价的ES6写法，只要在函数定义中的参数后面用=就可以为参数赋一个默认值

* 给参数传undefined相当于没有传值，不过这样可以利用多个独立的默认值

* 函数的默认参数只有在函数被调用时才会求值，不会在函数定义时求值。而且，计算默认值的函数只有在调用函数但未传相应参数时才会被调用。

* 参数初始化顺序遵循“暂时性死区”规则，即前面定义的参数不能引用后面定义的。像这样就会抛出错误


### 10.6 参数扩展与收集

* ECMAScript 6新增了扩展操作符，使用它可以非常简洁地操作和组合集合数据。扩展操作符最有用的场景就是函数定义中的参数列表，在这里它可以充分利用这门语言的弱类型及参数长度可变的特点。扩展操作符既可以用于调用函数时传参，也可以用于定义函数参数。

* 因为数组的长度已知，所以在使用扩展操作符传参的时候，并不妨碍在其前面或后面再传其他的值，包括使用扩展操作符传其他参数

* arguments对象只是消费扩展操作符的一种方式。在普通函数和箭头函数中，也可以将扩展操作符用于命名参数，当然同时也可以使用默认参数


### 10.7 函数声明与函数表达式

* JavaScript引擎在任何代码执行之前，会先读取函数声明，并在执行上下文中生成函数定义。而函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义。

* 注意 在使用函数表达式初始化变量时，也可以给函数一个名称，比如let sum =function sum() {}。这一点在10.11节讨论函数表达式时会再讨论。


### 10.8 函数作为值

* 要注意的是，如果是访问函数而不是调用函数，那就必须不带括号，所以传给callSomeFunction()的必须是add10和getGreeting，而不能是它们的执行结果。

* 这个函数的语法乍一看比较复杂，但实际上就是在一个函数中返回另一个函数，注意那个return操作符。内部函数可以访问propertyName参数，并通过中括号语法取得要比较的对象的相应属性值。取得属性值以后，再按照sort()方法的需要返回比较值就行了。


### 10.9 函数内部

* 在ECMAScript 5中，函数内部存在两个特殊的对象：arguments和this。ECMAScript 6又新增了new.target属性。


* 虽然主要用于包含函数参数，但arguments对象其实还有一个callee属性，是一个指向arguments对象所在函数的指针。

* 这个重写之后的factorial()函数已经用arguments.callee代替了之前硬编码的factorial。这意味着无论函数叫什么名称，都可以引用正确的函数。

* 在标准函数中，this引用的是把函数当成方法调用的上下文对象，这时候通常称其为this值（在网页的全局上下文中调用函数时，this指向windows）。

* 定义在全局上下文中的函数sayColor()引用了this对象。这个this到底引用哪个对象必须到函数被调用时才能确定。因此这个值在代码执行的过程中可能会变。如果在全局上下文中调用sayColor()，这结果会输出"red"，因为this指向window，而this.color相当于window.color。而在把sayColor()赋值给o之后再调用o.sayColor(), this会指向o，即this.color相当于o.color，所以会显示"blue"。

* 在箭头函数中，this引用的是定义箭头函数的上下文。

* 有读者知道，在事件回调或定时回调中调用某个函数时，this值指向的并非想要的对象。此时将回调函数写成箭头函数就可以解决问题。这是因为箭头函数中的this会保留定义该函数时的上下文

* 注意 函数名只是保存指针的变量。因此全局定义的sayColor()函数和o.sayColor()是同一个函数，只不过执行的上下文不同。

* ECMAScript 5也会给函数对象上添加一个属性：caller。虽然ECMAScript 3中并没有定义，但所有浏览器除了早期版本的Opera都支持这个属性。这个属性引用的是调用当前函数的函数，或者如果是在全局作用域中调用的则为null。

* ECMAScript中的函数始终可以作为构造函数实例化一个新对象，也可以作为普通函数被调用。ECMAScript 6新增了检测函数是否使用new关键字调用的new.target属性。如果函数是正常调用的，则new.target的值是undefined；如果是使用new关键字调用的，则new.target将引用被调用的构造函数。


### 10.10 函数属性与方法

* 前面提到过，ECMAScript中的函数是对象，因此有属性和方法。每个函数都有两个属性：length和prototype。其中，length属性保存函数定义的命名参数的个数

* prototype属性也许是ECMAScript核心中最有趣的部分。prototype是保存引用类型所有实例方法的地方，这意味着toString()、valueOf()等方法实际上都保存在prototype上，进而由所有实例共享。

* 函数还有两个方法：apply()和call()。这两个方法都会以指定的this值来调用函数，即会设置调用函数时函数体内this对象的值。apply()方法接收两个参数：函数内this的值和一个参数数组。第二个参数可以是Array的实例，但也可以是arguments对象。

* call()方法与apply()的作用一样，只是传参的形式不同。第一个参数跟apply()一样，也是this值，而剩下的要传给被调用函数的参数则是逐个传递的。换句话说，通过call()向函数传参时，必须将参数一个一个地列出来

* apply()和call()真正强大的地方并不是给函数传参，而是控制函数调用上下文即函数体内this值的能力。

* ECMAScript 5出于同样的目的定义了一个新方法：bind()。bind()方法会创建一个新的函数实例，其this值会被绑定到传给bind()的对象。


### 10.11 函数表达式

* 函数表达式看起来就像一个普通的变量定义和赋值，即创建一个函数再把它赋值给一个变量functionName。这样创建的函数叫作匿名函数（anonymous funtion），因为function关键字后面没有标识符。（匿名函数有也时候也被称为兰姆达函数）。未赋值给其他变量的匿名函数的name属性是空字符串。


* 理解函数声明与函数表达式之间的区别，关键是理解提升。比如，以下代码的执行结果可能会出乎意料


### 10.12 递归

* 这里创建了一个命名函数表达式f()，然后将它赋值给了变量factorial。即使把函数赋值给另一个变量，函数表达式的名称f也不变，因此递归调用不会有问题。这个模式在严格模式和非严格模式下都可以使用。


### 10.13 尾调用优化

* 很明显，第一种情况下每多调用一次嵌套函数，就会多增加一个栈帧。而第二种情况下无论调用多少次嵌套函数，都只有一个栈帧。这就是ES6尾调用优化的关键：如果函数的逻辑允许基于尾调用将其销毁，则引擎就会那么做。

* 注意 现在还没有办法测试尾调用优化是否起作用。不过，因为这是ES6规范所规定的，兼容的浏览器实现都能保证在代码满足条件的情况下应用这个优化。


### 10.14 闭包

* 匿名函数经常被人误认为是闭包（closure）。闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。比如，下面是之前展示的createComparisonFunction()函数，注意其中加粗的代码

* 局部变量对象和全局变量对象。作用域链其实是一个包含指针的列表，每个指针分别指向一个变量对象，但物理上并不会包含相应的对象

* 函数内部的代码在访问变量时，就会使用给定的名称从作用域链中查找变量。函数执行完毕后，局部活动对象会被销毁，内存中就只剩下全局作用域。不过，闭包就不一样了。

* 注意 因为闭包会保留它们包含函数的作用域，所以比其他函数更占用内存。过度使用闭包可能导致内存过度占用，因此建议仅在十分必要时使用。V8等优化的JavaScript引擎会努力回收被闭包困住的内存，不过我们还是建议在使用闭包时要谨慎。

* 在闭包中使用this会让代码变复杂。如果内部函数没有使用箭头函数定义，则this对象会在运行时绑定到执行函数的上下文。如果在全局函数中调用，则this在非严格模式下等于window，在严格模式下等于undefined。如果作为某个对象的方法调用，则this等于这个对象。匿名函数在这种情况下不会绑定到某个对象，这就意味着this会指向window，除非在严格模式下this是undefined。不过，由于闭包的写法所致，这个事实有时候没有那么容易看出来。

* 前面介绍过，每个函数在被调用时都会自动创建两个特殊变量：this和arguments。内部函数永远不可能直接访问外部函数的这两个变量。但是，如果把this保存到闭包可以访问的另一个变量中，则是行得通的。

* 注意 this和arguments都是不能直接在内部函数中访问的。如果想访问包含作用域中的arguments对象，则同样需要将其引用先保存到闭包能访问的另一个变量中。

* 第三行执行了一次赋值，然后再调用赋值后的结果。因为赋值表达式的值是函数本身，this值不再与任何对象绑定，所以返回的是"The Window"。


* 由于IE在IE9之前对JScript对象和COM对象使用了不同的垃圾回收机制（第4章讨论过），所以闭包在这些旧版本IE中可能会导致问题。在这些版本的IE中，把HTML元素保存在某个闭包的作用域中，就相当于宣布该元素不能被销毁。


### 10.15 立即调用的函数表达式

* 立即调用的匿名函数又被称作立即调用的函数表达式（IIFE, Immediately Invoked Function Expression）。它类似于函数声明，但由于被包含在括号中，所以会被解释为函数表达式。紧跟在第一组括号后面的第二组括号会立即调用前面的函数表达式。


### 10.16 私有变量

* 严格来讲，JavaScript没有私有成员的概念，所有对象属性都公有的。不过，倒是有私有变量的概念。任何定义在函数或块中的变量，都可以认为是私有的，因为在这个函数或块的外部无法访问其中的变量。私有变量包括函数参数、局部变量，以及函数内部定义的其他函数。

* 注意 使用闭包和私有变量会导致作用域链变长，作用域链越长，则查找变量所需的时间也越多。


### 10.17 小结

* JavaScript中函数定义与调用时的参数极其灵活。arguments对象，以及ES6新增的扩展操作符，可以实现函数定义和调用的完全动态化。


### 第11章 期约与异步函数

* 注意 本章示例将大量使用异步日志输出的方式setTimeout(console.log, 0, ... params)，旨在演示执行顺序及其他异步行为。异步输出的内容看起来虽然像是同步输出的，但实际上是异步打印的。这样可以让期约等返回的值达到其最终状态。
此外，浏览器控制台的输出经常能打印出JavaScript运行中无法获取的对象信息（比如期约的状态）。这个特性在示例中广泛使用，以便辅助读者理解相关概念。


### 11.1 异步编程

* 重要的是，异步操作并不一定计算量大或要等很长时间。只要你不想为等待某个异步操作而阻塞线程执行，那么任何时候都可以使用。

* 显然，随着代码越来越复杂，回调策略是不具有扩展性的。“回调地狱”这个称呼可谓名至实归。嵌套回调的代码维护起来就是噩梦。


### 11.2 期约

* 期约是对尚不存在结果的一个替身。

* 同一时期的计算机科学家还使用了“终局”（eventual）、“期许”（future）、“延迟”（delay）和“迟付”（deferred）等术语指代同样的概念。所有这些概念描述的都是一种异步程序执行的机制。

* ECMAScript 6增加了对Promises/A+规范的完善支持，即Promise类型。一经推出，Promise就大受欢迎，成为了主导性的异步编程机制。所有现代浏览器都支持ES6期约，很多其他浏览器API（如fetch()和Battery Status API）也以期约为基础。

* 重要的是，期约的状态是私有的，不能直接通过JavaScript检测到。这主要是为了避免根据读取到的期约状态，以同步方式处理期约对象。另外，期约的状态也不能被外部JavaScript代码修改。这与不能读取该状态的原因是一样的：期约故意将异步行为封装起来，从而隔离外部的同步代码。

* 为了支持这两种用例，每个期约只要状态切换为兑现，就会有一个私有的内部值（value）。类似地，每个期约只要状态切换为拒绝，就会有一个私有的内部理由（reason）。无论是值还是理由，都是包含原始值或对象的不可修改的引用。二者都是可选的，而且默认值为undefined。在期约到达某个落定状态时执行的异步代码始终会收到这个值或理由。

* 为避免期约卡在待定状态，可以添加一个定时退出功能。比如，可以通过setTimeout设置一个10秒钟后无论如何都会拒绝期约的回调：

* 这个解决的期约的值对应着传给Promise.resolve()的第一个参数。使用这个静态方法，实际上可以把任何值都转换为一个期约：

* 对这个静态方法而言，如果传入的参数本身是一个期约，那它的行为就类似于一个空包装。因此，Promise.resolve()可以说是一个幂等方法，

* 注意，这个静态方法能够包装任何非期约值，包括错误对象，并将其转换为解决的期约。因此，也可能导致不符合预期的行为

* 关键在于，Promise.reject()并没有照搬Promise.resolve()的幂等逻辑。如果给它传一个期约对象，则这个期约会成为它返回的拒绝期约的理由

* 期约实例的方法是连接外部同步代码与内部异步代码之间的桥梁。这些方法可以访问异步操作返回的数据，处理期约成功和失败的结果，连续对期约求值，或者添加只有期约进入终止状态时才会执行的代码

* 注意，返回错误值不会触发上面的拒绝行为，而会把错误对象包装在一个解决的期约中

* Promise.prototype.catch()方法用于给期约添加拒绝处理程序。这个方法只接收一个参数：onRejected处理程序。事实上，这个方法就是一个语法糖，调用它就相当于调用Promise.prototype. then(null, onRejected)。

* Promise.prototype.finally()方法用于给期约添加onFinally处理程序，这个处理程序在期约转换为解决或拒绝状态时都会执行。这个方法可以避免onResolved和onRejected处理程序中出现冗余代码。但onFinally处理程序没有办法知道期约的状态是解决还是拒绝，所以这个方法主要用于添加清理代码。

* 这个新期约实例不同于then()或catch()方式返回的实例。因为onFinally被设计为一个状态无关的方法，所以在大多数情况下它将表现为父期约的传递。对于已解决状态和被拒绝状态都是如此。

* 当期约进入落定状态时，与该状态相关的处理程序仅仅会被排期，而非立即执行。跟在添加这个处理程序的代码之后的同步代码一定会在处理程序之前先执行。即使期约一开始就是与附加处理程序关联的状态，执行顺序也是这样的。这个特性由JavaScript运行时保证，被称为“非重入”（non-reentrancy）特性。

* 非重入适用于onResolved/onRejected处理程序、catch()处理程序和finally()处理程序。

* 如果给期约添加了多个处理程序，当期约状态变化时，相关处理程序会按照添加它们的顺序依次执行。无论是then()、catch()还是finally()添加的处理程序都是如此

* 在执行函数中，解决的值和拒绝的理由是分别作为resolve()和reject()的第一个参数往后传的。然后，这些值又会传给它们各自的处理程序，作为onResolved或onRejected处理程序的唯一参数。

* 拒绝期约类似于throw()表达式，因为它们都代表一种程序状态，即需要中断或者特殊处理。在期约的执行函数或处理程序中抛出错误会导致拒绝，对应的错误对象会成为拒绝的理由。因此以下这些期约都会以一个错误对象为由被拒绝

* 正常情况下，在通过throw()关键字抛出错误时，JavaScript运行时的错误处理机制会停止执行抛出错误之后的任何指令

* then()和catch()的onRejected处理程序在语义上相当于try/catch。出发点都是捕获错误之后将其隔离，同时不影响正常逻辑执行。为此，onRejected处理程序的任务应该是在捕获异步错误之后返回一个解决的期约。

* 多个期约组合在一起可以构成强大的代码逻辑。这种组合可以通过两种方式实现：期约连锁与期约合成。前者就是一个期约接一个期约地拼接，后者则是将多个期约组合为一个期约。

* 个后续的处理程序都会等待前一个期约解决，然后实例化一个新期约并返回它。这种结构可以简洁地将异步任务串行化，解决之前依赖回调的难题。

* 因为一个期约可以有任意多个处理程序，所以期约连锁可以构建有向非循环图的结构。这样，每个期约都是图中的一个节点，而使用实例方法添加的处理程序则是有向顶点。因为图中的每个节点都会等待前一个节点落定，所以图的方向就是期约的解决或拒绝顺序。

* Promise类提供两个将多个期约实例组合成一个期约的静态方法：Promise.all()和Promise.race()。而合成后期约的行为取决于内部期约的行为。

* 如果至少有一个包含的期约待定，则合成的期约也会待定。如果有一个包含的期约拒绝，则合成的期约也会拒绝

* 如果所有期约都成功解决，则合成期约的解决值就是所有包含期约解决值的数组，按照迭代器顺序

* 如果有期约拒绝，则第一个拒绝的期约会将自己的理由作为合成期约的拒绝理由。之后再拒绝的期约不会影响最终期约的拒绝理由。不过，这并不影响所有包含期约正常的拒绝操作。合成的期约会静默处理所有包含期约的拒绝操作

* Promise.race()静态方法返回一个包装期约，是一组集合中最先解决或拒绝的期约的镜像。这个方法接收一个可迭代对象，返回一个新期约

* Promise.race()不会对解决或拒绝的期约区别对待。无论是解决还是拒绝，只要是第一个落定的期约，Promise.race()就会包装其解决值或拒绝理由并返回新期约

* 到目前为止，我们讨论期约连锁一直围绕期约的串行执行，忽略了期约的另一个主要特性：异步产生值并将其传给处理程序。基于后续期约使用之前期约的返回值来串联期约是期约的基本功能。这很像函数合成，即将多个函数合成为一个函数

* ES6期约实现是很可靠的，但它也有不足之处。比如，很多第三方期约库实现中具备而ECMAScript规范却未涉及的两个特性：期约取消和进度追踪。

* 注意 ES6不支持取消期约和进度通知，一个主要原因就是这样会导致期约连锁和期约合成过度复杂化。比如在一个期约连锁中，如果某个被其他期约依赖的期约被取消了或者发出了通知，那么接下来应该发生什么完全说不清楚。毕竟，如果取消了Promise.all()中的一个期约，或者期约连锁中前面的期约发送了一个通知，那么接下来应该怎么办才比较合理呢？


### 11.3 异步函数

* 异步函数，也称为“async/await”（语法关键字），是ES6期约模式在ECMAScript函数中的应用。async/await是ES8规范新增的。这个特性从行为和语法上都增强了JavaScript，让以同步方式写的代码能够异步执行。

* 这个改进其实也不大。这是因为任何需要访问这个期约所产生值的代码，都需要以处理程序的形式来接收这个值。也就是说，代码照样还是要放到处理程序里。ES8为此提供了async/await关键字。

* async关键字用于声明异步函数。这个关键字可以用在函数声明、函数表达式、箭头函数和方法上

* 使用async关键字可以让函数具有异步特征，但总体上其代码仍然是同步求值的。而在参数或闭包方面，异步函数仍然具有普通JavaScript函数的正常行为。正如下面的例子所示，foo()函数仍然会在后面的指令之前被求值

* 不过，异步函数如果使用return关键字返回了值（如果没有return则会返回undefined），这个值会被Promise.resolve()包装成一个期约对象。异步函数始终返回期约对象。在函数外部调用这个函数可以得到它返回的期约

* 异步函数的返回值期待（但实际上并不要求）一个实现thenable接口的对象，但常规的值也可以。如果返回的是实现thenable接口的对象，则这个对象可以由提供给then()的处理程序“解包”。如果不是，则返回值就被当作已经解决的期约。

* 因为异步函数主要针对不会马上完成的任务，所以自然需要一种暂停和恢复执行的能力。使用await关键字可以暂停异步函数代码的执行，等待期约解决

* 注意，await关键字会暂停执行异步函数后面的代码，让出JavaScript运行时的执行线程。这个行为与生成器函数中的yield关键字是一样的。await关键字同样是尝试“解包”对象的值，然后将这个值传给表达式，再异步恢复异步函数的执行。

* await关键字期待（但实际上并不要求）一个实现thenable接口的对象，但常规的值也可以。如果是实现thenable接口的对象，则这个对象可以由await来“解包”。如果不是，则这个值就被当作已经解决的期约。

* 如前面的例子所示，单独的Promise.reject()不会被异步函数捕获，而会抛出未捕获错误。不过，对拒绝的期约使用await则会释放（unwrap）错误值（将拒绝期约返回）

* await关键字必须在异步函数中使用，不能在顶级上下文如<script>标签或模块中使用。不过，定义并立即调用异步函数是没问题的。

* async/await中真正起作用的是await。async关键字，无论从哪方面来看，都不过是一个标识符。毕竟，异步函数如果不包含await关键字，其执行基本上跟普通函数没有什么区别

* 要完全理解await关键字，必须知道它并非只是等待一个值可用那么简单。JavaScript运行时在碰到await关键字时，会记录在哪里暂停执行。等到await右边的值可用了，JavaScript运行时会向消息队列中推送一个任务，这个任务会恢复异步函数的执行。

* 如果await后面是一个期约，则问题会稍微复杂一些。此时，为了执行异步函数，实际上会有两个任务被添加到消息队列并被异步求值。

* 因为简单实用，所以异步函数很快成为JavaScript项目使用最广泛的特性之一。不过，在使用异步函数时，还是有些问题要注意。

* 很多人在刚开始学习JavaScript时，想找到一个类似Java中Thread.sleep()之类的函数，好在程序中加入非阻塞的暂停。以前，这个需求基本上都通过setTimeout()利用JavaScript运行时的行为来实现的。
有了异步函数之后，就不一样了。一个简单的箭头函数就可以实现sleep()

* 如果使用await时不留心，则很可能错过平行加速的机会。

* 就算这些期约之间没有依赖，异步函数也会依次暂停，等待每个超时完成。这样可以保证执行顺序，但总执行时间会变长。
如果顺序不是必需保证的，那么可以先一次性初始化所有期约，然后再分别等待它们的结果。

* 注意，虽然期约没有按照顺序执行，但await按顺序收到了每个期约的值

* 期约与异步函数的功能有相当程度的重叠，但它们在内存中的表示则差别很大。

* 答案很简单，这是因为JavaScript引擎会在创建期约时尽可能保留完整的调用栈。在抛出错误时，调用栈可以由运行时的错误处理逻辑获取，因而就会出现在栈追踪信息中。当然，这意味着栈追踪信息会占用内存，从而带来一些计算和存储成本。


### 11.4 小结

* 期约的主要功能是为异步代码提供了清晰的抽象。可以用期约表示异步执行的代码块，也可以用期约表示异步计算的值。在需要串行异步代码时，期约的价值最为突出。作为可塑性极强的一种结构，期约可以被序列化、连锁使用、复合、扩展和重组。



### 第12章 BOM

* 虽然ECMAScript把浏览器对象模型（BOM, Browser Object Model）描述为JavaScript的核心，但实际上BOM是使用JavaScript开发Web应用程序的核心。BOM提供了与网页无关的浏览器功能对象。多年来，BOM是在缺乏规范的背景下发展起来的，因此既充满乐趣又问题多多。毕竟，浏览器开发商都按照自己的意愿来为它添砖加瓦。最终，浏览器实现之间共通的部分成为了事实标准，为Web开发提供了浏览器间互操作的基础。HTML5规范中有一部分涵盖了BOM的主要内容，因为W3C希望将JavaScript在浏览器中最基础的部分标准化。


### 12.1 window对象

* 注意 因为window对象的属性在全局作用域中有效，所以很多浏览器API及相关构造函数都以window对象属性的形式暴露出来。这些API将在全书各章中介绍，特别是第20章。另外，由于实现不同，某些window对象的属性在不同浏览器间可能差异很大。本章不会介绍已经废弃的、非标准化或特定于浏览器的window属性。

* 记住，JavaScript中有很多对象都暴露在全局作用域中，比如location和navigator（本章后面都会讨论），因而它们也是window对象的属性。

* CSS像素是Web开发中使用的统一像素单位。这个单位的背后其实是一个角度：0.0213°。如果屏幕距离人眼是一臂长，则以这个角度计算的CSS像素大小约为1/96英寸。这样定义像素大小是为了在不同设备上统一标准。比如，低分辨率平板设备上12像素（CSS像素）的文字应该与高清4K屏幕下12像素（CSS像素）的文字具有相同大小。这就带来了一个问题，不同像素密度的屏幕下就会有不同的缩放系数，以便把物理像素（屏幕实际的分辨率）转换为CSS像素（浏览器报告的虚拟分辨率）。
举个例子，手机屏幕的物理分辨率可能是1920×1080，但因为其像素可能非常小，所以浏览器就需要将其分辨率降为较低的逻辑分辨率，比如640×320。这个物理像素与CSS像素之间的转换比率由window.devicePixelRatio属性提供。对于分辨率从1920×1080转换为640×320的设备，window. devicePixelRatio的值就是3。这样一来，12像素（CSS像素）的文字实际上就会用36像素的物理像素来显示。
window.devicePixelRatio实际上与每英寸像素数（DPI, dots per inch）是对应的。DPI表示单位像素密度，而window.devicePixelRatio表示物理像素与逻辑像素之间的缩放系数。

* 所有现代浏览器都支持4个属性：innerWidth、innerHeight、outerWidth和outerHeight。outerWidth和outerHeight返回浏览器窗口自身的大小（不管是在最外层window上使用，还是在窗格<frame>中使用）。innerWidth和innerHeight返回浏览器窗口中页面视口的大小（不包含浏览器边框和工具栏）。

* 在其他移动浏览器中，document.documentElement.clientWidth和document.documentElement. clientHeight返回的布局视口的大小，即渲染页面的实际大小。布局视口是相对于可见视口的概念，可见视口只能显示整个页面的一小部分。

* 注意 手机视口的概念比较复杂，有各种各样的问题。如果读者在做移动开发，推荐阅读Peter-Paul Koch发表在QuirksMode网站上的文章“A Tale of Two Viewports— Part Two”。

* 可以使用resizeTo()和resizeBy()方法调整窗口大小。这两个方法都接收两个参数，resizeTo()接收新的宽度和高度值，而resizeBy()接收宽度和高度各要缩放多少。

* 可以使用scroll()、scrollTo()和scrollBy()方法滚动页面。这3个方法都接收表示相对视口距离的x和y坐标，这两个参数在前两个方法中表示要滚动到的坐标，在最后一个方法中表示滚动的距离。

* 这几个方法也都接收一个ScrollToOptions字典，除了提供偏移值，还可以通过behavior属性告诉浏览器是否平滑滚动。


* window.open()方法可以用于导航到指定URL，也可以用于打开新浏览器窗口。这个方法接收4个参数：要加载的URL、目标窗口、特性字符串和表示新窗口在浏览器历史记录中是否替代当前加载页面的布尔值。通常，调用这个方法时只传前3个参数，最后一个参数只有在不打开新窗口时才会使用。

* window.open()方法返回一个对新建窗口的引用。这个对象与普通window对象没有区别，只是为控制新窗口提供了方便。例如，某些浏览器默认不允许缩放或移动主窗口，但可能允许缩放或移动通过window.open()创建的窗口。跟使用任何window对象一样，可以使用这个对象操纵新打开的窗口。

* 新创建窗口的window对象有一个属性opener，指向打开它的窗口。这个属性只在弹出窗口的最上层window对象（top）有定义，是指向调用window.open()打开它的窗口或窗格的指针。

* 所有现代浏览器都内置了屏蔽弹窗的程序，因此大多数意料之外的弹窗都会被屏蔽。在浏览器屏蔽弹窗时，可能会发生一些事。如果浏览器内置的弹窗屏蔽程序阻止了弹窗，那么window.open()很可能会返回null。此时，只要检查这个方法的返回值就可以知道弹窗是否被屏蔽了

* JavaScript在浏览器中是单线程执行的，但允许使用定时器指定在某个时间之后或每隔一段时间就执行相应的代码。setTimeout()用于指定在一定时间后执行某些代码，而setInterval()用于指定每隔一段时间执行某些代码。


* 调用setTimeout()时，会返回一个表示该超时排期的数值ID。这个超时ID是被排期执行代码的唯一标识符，可用于取消该任务。要取消等待中的排期任务，可以调用clearTimeout()方法并传入超时ID

* 注意 所有超时执行的代码（函数）都会在全局作用域中的一个匿名函数中运行，因此函数中的this值在非严格模式下始终指向window，而在严格模式下是undefined。如果给setTimeout()提供了一个箭头函数，那么this会保留为定义它时所在的词汇作用域。

* setInterval()与setTimeout()的使用方法类似，只不过指定的任务会每隔指定时间就执行一次，直到取消循环定时或者页面卸载。setInterval()同样可以接收两个参数：要执行的代码（字符串或函数），以及把下一次执行定时代码的任务添加到队列要等待的时间（毫秒）。

* 注意 这里的关键点是，第二个参数，也就是间隔时间，指的是向队列添加新任务之前等待的时间。比如，调用setInterval()的时间为01:00:00，间隔时间为3000毫秒。这意味着01:00:03时，浏览器会把任务添加到执行队列。浏览器不关心这个任务什么时候执行或者执行要花多长时间。因此，到了01:00:06，它会再向队列中添加一个任务。由此可看出，执行时间短、非阻塞的回调函数比较适合setInterval()。

* 注意在使用setTimeout()时，不一定要记录超时ID，因为它会在条件满足时自动停止，否则会自动设置另一个超时任务。这个模式是设置循环任务的推荐做法。setIntervale()在实践中很少会在生产环境下使用，因为一个任务结束和下一个任务开始之间的时间间隔是无法保证的，有些循环定时任务可能会因此而被跳过。而像前面这个例子中一样使用setTimeout()则能确保不会出现这种情况。一般来说，最好不要使用setInterval()。

* 使用alert()、confirm()和prompt()方法，可以让浏览器调用系统对话框向用户显示消息。这些对话框与浏览器中显示的网页无关，而且也不包含HTML。它们的外观由操作系统或者浏览器决定，无法使用CSS设置。此外，这些对话框都是同步的模态对话框，即在它们显示的时候，代码会停止执行，在它们消失以后，代码才会恢复执行。

* 这些系统对话框可以向用户显示消息、确认操作和获取输入。由于不需要HTML和CSS，所以系统对话框是Web应用程序最简单快捷的沟通手段。

* JavaScript还可以显示另外两种对话框：find()和print()。这两种对话框都是异步显示的，即控制权会立即返回给脚本。


### 12.2 location对象

* location是最有用的BOM对象之一，提供了当前窗口中加载文档的信息，以及通常的导航功能。这个对象独特的地方在于，它既是window的属性，也是document的属性。也就是说，window.location和document.location指向同一个对象。location对象不仅保存着当前加载文档的信息，也保存着把URL解析为离散片段后能够通过属性访问的信息。这些解析后的属性在下表中有详细说明（location前缀是必需的）。

* URLSearchParams提供了一组标准API方法，通过它们可以检查和修改查询字符串。给URLSearchParams构造函数传入一个查询字符串，就可以创建一个实例。这个实例上暴露了get()、set()和delete()等方法，可以对查询字符串执行相应操作。

* 最后一个修改地址的方法是reload()，它能重新加载当前显示的页面。调用reload()而不传参数，页面会以最有效的方式重新加载。也就是说，如果页面自上次请求以来没有修改过，浏览器可能会从缓存中加载页面。如果想强制从服务器重新加载，可以像下面这样给reload()传个true


### 12.3 navigator对象

* 检测浏览器是否安装了某个插件是开发中常见的需求。除IE10及更低版本外的浏览器，都可以通过plugins数组来确定。

* 通常，name属性包含识别插件所需的必要信息，尽管不是特别准确。检测插件就是遍历浏览器中可用的插件，并逐个比较插件的名称

* 注意 plugins数组中的每个插件对象还有一个MimeType对象，可以通过中括号访问。每个MimeType对象有4个属性：description描述MIME类型，enabledPlugin是指向插件对象的指针，suffixes是该MIME类型对应扩展名的逗号分隔的字符串，type是完整的MIME类型字符串。

* 注意 plugins有一个refresh()方法，用于刷新plugins属性以反映新安装的插件。这个方法接收一个布尔值参数，表示刷新时是否重新加载页面。如果传入true，则所有包含插件的页面都会重新加载。否则，只有plugins会更新，但页面不会重新加载。


### 12.5 history对象

* go()方法可以在用户历史记录中沿任何方向导航，可以前进也可以后退。这个方法只接收一个参数，这个参数可以是一个整数，表示前进或后退多少步。负值表示在历史记录中后退（类似点击浏览器的“后退”按钮），而正值表示在历史记录中前进（类似点击浏览器的“前进”按钮）。

* 对于窗口或标签页中加载的第一个页面，history.length等于1。通过以下方法测试这个值，可以确定用户浏览器的起点是不是你的页面：

* 注意 如果页面URL发生变化，则会在历史记录中生成一个新条目。对于2009年以来发布的主流浏览器，这包括改变URL的散列值（因此，把location.hash设置为一个新值会在这些浏览器的历史记录中增加一条记录）。这个行为常被单页应用程序框架用来模拟前进和后退，这样做是为了不会因导航而触发页面刷新。

* 注意 使用HTML5状态管理时，要确保通过pushState()创建的每个“假”URL背后都对应着服务器上一个真实的物理URL。否则，单击“刷新”按钮会导致404错误。所有单页应用程序（SPA, Single Page Application）框架都必须通过服务器或客户端的某些配置解决这个问题。


### 13.1 能力检测

* 比如，IE5之前的版本中没有document.getElementById()这个DOM方法，但可以通过document.all属性实现同样的功能。

* 注意 能力检测最适合用于决定下一步该怎么做，而不一定能够作为辨识浏览器的标志。


### 13.2 用户代理检测

* Safari用户代理字符串中最受争议的部分是在1.0预发布版中添加的"(KHTML, like Gecko)"。由于有意想让客户端和服务器把Safari当成基于Gecko的浏览器（好像光添加"Mozilla/5.0"还不够），苹果也招来了很多开发者的反对。苹果的回应与微软当初IE遭受质疑时一样：Safari与Mozilla兼容，不能让网站以为用户使用了不受支持的浏览器而把Safari排斥在外。


* 谷歌的Chrome浏览器使用Blink作为渲染引擎，使用V8作为JavaScript引擎。Chrome的用户代理字符串包含所有WebKit的信息，另外又加上了Chrome及其版本的信息。

* 默认情况下，Opera会返回这个简单的用户代理字符串。这是唯一一个使用产品名称和版本完全标识自身的主流浏览器。不过，与其他浏览器一样，Opera也遇到了使用这种字符串的问题。虽然从技术角度看这是正确的，但网上已经有了很多浏览器检测代码只考虑Mozilla这个产品名称。还有不少代码专门针对IE或Gecko。为了不让这些检测代码判断错误，Opera坚持使用唯一标识自身的字符串。

* 与其劳心费力检测造假，不如更好地专注于浏览器识别。如果相信浏览器返回的用户代理字符串，那就可以用它来判断浏览器。如果怀疑脚本或浏览器可能篡改这个值，那最好还是使用能力检测。

* 注意 Mozilla维基有一个页面“Compatibility/UADetectionLibraries”，其中提供了用户代理解析程序的列表，可以用来识别Mozilla浏览器（甚至所有主流浏览器）。这些解析程序是按照语言分组的。这个页面好像维护不频繁，但其中给出了所有主流的解析库。（注意JavaScript部分包含客户端库和Node.js库。）GitHub上的文章“Are We Detectable Yet? ”中还有一张可视化的表格，能让我们对这些库的检测能力一目了然。


### 13.3 软件与硬件检测

* 注意 浏览器也可能会利用Google Location Service（Chrome和Firefox）等服务确定位置。有时候，你可能会发现自己并没有GPS，但浏览器给出的坐标却非常精确。浏览器会收集所有可用的无线网络，包括Wi-Fi和蜂窝信号。拿到这些信息后，再去查询网络数据库。这样就可以精确地报告出你的设备位置。

* 浏览器会跟踪网络连接状态并以两种方式暴露这些信息：连接事件和navigator.onLine属性。在设备连接到网络时，浏览器会记录这个事实并在window对象上触发online事件。相应地，当设备断开网络连接后，浏览器会在window对象上触发offline事件。任何时候，都可以通过navigator. onLine属性来确定浏览器的联网状态。这个属性返回一个布尔值，表示浏览器是否联网


### 13.4 小结

* 客户端检测是JavaScript中争议最多的话题之一。因为不同浏览器之间存在差异，所以经常需要根据浏览器的能力来编写不同的代码。客户端检测有不少方式，但下面两种用得最多。


### 第14章 DOM

* DOM Level 1在1998年成为W3C推荐标准，提供了基本文档结构和查询的接口。本章之所以介绍DOM，主要因为它与浏览器中的HTML网页相关，并且在JavaScript中提供了DOM API。



### 14.1 节点层级

* 浏览器并不支持所有节点类型。开发者最常用到的是元素节点和文本节点。本章后面会讨论每种节点受支持的程度及其用法。

* 每个节点都有一个childNodes属性，其中包含一个NodeList的实例。NodeList是一个类数组对象，用于存储可以按位置存取的有序节点。注意，NodeList并不是Array的实例，但可以使用中括号访问它的值，而且它也有length属性。NodeList对象独特的地方在于，它其实是一个对DOM结构的查询，因此DOM结构的变化会自动地在NodeList中反映出来。我们通常说NodeList是实时的活动对象，而不是第一次访问时所获得内容的快照。

* 有了这些关系，childNodes属性的作用远远不止是必备属性那么简单了。这是因为利用这些关系指针，几乎可以访问到文档树中的任何节点，而这种便利性是childNodes的最大亮点。还有一个便利的方法是hasChildNodes()，这个方法如果返回true则说明节点有一个或多个子节点。

* 注意 虽然所有节点类型都继承了Node，但并非所有节点都有子节点。本章后面会讨论不同节点类型的差异。

* 因为所有关系指针都是只读的，所以DOM又提供了一些操纵节点的方法。最常用的方法是appendChild()，用于在childNodes列表末尾添加节点。添加新节点会更新相关的关系指针，包括父节点和之前的最后一个子节点。appendChild()方法返回新添加的节点

* 如果把文档中已经存在的节点传给appendChild()，则这个节点会从之前的位置被转移到新位置。即使DOM树通过各种关系指针维系，一个节点也不会在文档中同时出现在两个或更多个地方。因此，如果调用appendChild()传入父元素的第一个子节点，则这个节点会成为父元素的最后一个子节点

* 如果想把节点放到childNodes中的特定位置而不是末尾，则可以使用insertBefore()方法。这个方法接收两个参数：要插入的节点和参照节点。调用这个方法后，要插入的节点会变成参照节点的前一个同胞节点，并被返回。如果参照节点是null，则insertBefore()与appendChild()效果相同

* 要移除节点而不是替换节点，可以使用removeChild()方法。这个方法接收一个参数，即要移除的节点。被移除的节点会被返回，

* 所有节点类型还共享了两个方法。第一个是cloneNode()，会返回与调用它的节点一模一样的节点。cloneNode()方法接收一个布尔值参数，表示是否深复制。在传入true参数时，会进行深复制，即复制节点及其整个子DOM树。如果传入false，则只会复制调用该方法的节点。复制返回的节点属于文档所有，但尚未指定父节点，所以可称为孤儿节点（orphan）。可以通过appendChild()、insertBefore()或replaceChild()方法把孤儿节点添加到文档中。

* 注意 cloneNode()方法不会复制添加到DOM节点的JavaScript属性，比如事件处理程序。这个方法只复制HTML属性，以及可选地复制子节点。除此之外则一概不会复制。IE在很长时间内会复制事件处理程序，这是一个bug，所以推荐在复制前先删除事件处理程序。

* 虽然document.childNodes中始终有<html>元素，但使用documentElement属性可以更快更直接地访问该元素。

* 一般来说，appendChild()、removeChild()和replaceChild()方法不会用在document对象上。这是因为文档类型（如果存在）是只读的，而且只能有一个Element类型的子节点（即<html>，已经存在了）。

* 当页面中包含来自某个不同子域的窗格（<frame>）或内嵌窗格（<iframe>）时，设置document.domain是有用的。因为跨源通信存在安全隐患，所以不同子域的页面间无法通过JavaScript通信。

* 使用DOM最常见的情形可能就是获取某个或某组元素的引用，然后对它们执行某些操作。document对象上暴露了一些方法，可以实现这些操作。

* 如果页面中存在多个具有相同ID的元素，则getElementById()返回在文档中出现的第一个元素。

* HTMLCollection对象还有一个额外的方法namedItem()，可通过标签的name属性取得某一项的引用。

* 对HTMLCollection对象而言，中括号既可以接收数值索引，也可以接收字符串索引。而在后台，数值索引会调用item()，字符串索引会调用namedItem()。

* 要取得文档中的所有元素，可以给getElementsByTagName()传入＊。在JavaScript和CSS中，＊一般被认为是匹配一切的字符。

* HTMLDocument类型上定义的获取元素的第三个方法是getElementsByName()。顾名思义，这个方法会返回具有给定name属性的所有元素。getElementsByName()方法最常用于单选按钮，因为同一字段的单选按钮必须具有相同的name属性才能确保把正确的值发送给服务器

* 与getElementsByTagName()一样，getElementsByName()方法也返回HTMLCollection。不过在这种情况下，namedItem()方法只会取得第一项（因为所有项的name属性都一样）。

* DOM Level 1在document.implementation上只定义了一个方法，即hasFeature()。这个方法接收两个参数：特性名称和DOM版本。如果浏览器支持指定的特性和版本，则hasFeature()方法返回true

* 由于实现不一致，因此hasFeature()的返回值并不可靠。目前这个方法已经被废弃，不再建议使用。为了向后兼容，目前主流浏览器仍然支持这个方法，但无论检测什么都一律返回true

* 前面的例子展示了在页面渲染期间通过document.write()向文档中输出内容。如果是在页面加载完之后再调用document.write()，则输出的内容会重写整个页面

* 除了Document类型，Element类型就是Web开发中最常用的类型了。Element表示XML或HTML元素，对外暴露出访问元素标签名、子节点和属性的能力。

* 所有HTML元素都通过HTMLElement类型表示，包括其直接实例和间接实例。另外，HTMLElement直接继承Element并增加了一些属性。

* 修改title属性则只会在鼠标移到这个元素上时才会反映出来。修改dir会导致页面文本立即向左或向右对齐。修改className会立即反映应用到新类名的CSS样式（如果定义了不同的样式）。

* 注意传给getAttribute()的属性名与它们实际的属性名是一样的，因此这里要传"class"而非"className"（className是作为对象属性时才那么拼写的）。如果给定的属性不存在，则getAttribute()返回null。

* 元素的所有属性也可以通过相应DOM元素对象的属性来取得。当然，这包括HTMLElement上定义的直接映射对应属性的5个属性，还有所有公认（非自定义）的属性也会被添加为DOM对象的属性。

* 第二个属性其实是一类，即事件处理程序（或者事件属性），比如onclick。在元素上使用事件属性时（比如onclick），属性的值是一段JavaScript代码。如果使用getAttribute()访问事件属性，则返回的是字符串形式的源代码。而通过DOM对象的属性访问事件属性时返回的则是一个JavaScript函数（未指定该属性则返回null）。这是因为onclick及其他事件属性是可以接受函数作为值的。

* Element类型是唯一使用attributes属性的DOM节点类型。attributes属性包含一个NamedNodeMap实例，是一个类似NodeList的“实时”集合。元素的每个属性都表示为一个Attr节点，并保存在这个NamedNodeMap对象中。

* attributes属性最有用的场景是需要迭代元素上所有属性的时候。这时候往往是要把DOM结构序列化为XML或HTML字符串。

* 可以使用document.createElement()方法创建新元素。这个方法接收一个参数，即要创建元素的标签名。

* 在新元素上设置这些属性只会附加信息。因为这个元素还没有添加到文档树，所以不会影响浏览器显示。要把元素添加到文档树，可以使用appendChild()、insertBefore()或replaceChild()。比如，以下代码会把刚才创建的元素添加到文档的<body>元素中

* 元素被添加到文档树之后，浏览器会立即将其渲染出来。之后再对这个元素所做的任何修改，都会立即在浏览器中反映出来

* 元素可以拥有任意多个子元素和后代元素，因为元素本身也可以是其他元素的子元素。childNodes属性包含元素所有的子节点，这些子节点可能是其他元素、文本节点、注释或处理指令。不同浏览器在识别这些节点时的表现有明显不同。

* Text节点中包含的文本可以通过nodeValue属性访问，也可以通过data属性访问，这两个属性包含相同的值。修改nodeValue或data的值，也会在另一个属性反映出来。

* document.createTextNode()可以用来创建新文本节点，它接收一个参数，即要插入节点的文本。

* DOM文档中的同胞文本节点可能导致困惑，因为一个文本节点足以表示一个文本字符串。同样，DOM文档中也经常会出现两个相邻文本节点。为此，有一个方法可以合并相邻的文本节点。这个方法叫normalize()，是在Node类型中定义的（因此所有类型的节点上都有这个方法）。

* 注意 将属性作为节点来访问多数情况下并无必要。推荐使用getAttribute()、removeAttribute()和setAttribute()方法操作属性，而不是直接操作属性节点。


### 14.2 DOM编程

* 这里先尝试使用标准的DOM文本节点插入方式，因为除IE之外的浏览器都支持这种方式。IE此时会抛出错误，那么可以在捕获错误之后再使用text属性来插入JavaScript代码。于是，我们就可以抽象出一个跨浏览器的函数

* 以上代码在所有主流浏览器中都能正常运行。注意应该把<link>元素添加到<head>元素而不是<body>元素，这样才能保证所有浏览器都能正常运行。

* 注意 对于IE，要小心使用styleSheet.cssText。如果重用同一个<style>元素并设置该属性超过一次，则可能导致浏览器崩溃。同样，将cssText设置为空字符串也可能导致浏览器崩溃。

* 理解NodeList对象和相关的NamedNodeMap、HTMLCollection，是理解DOM编程的关键。这3个集合类型都是“实时的”，意味着文档结构的变化会实时地在它们身上反映出来，因此它们的值始终代表最新的状态。实际上，NodeList就是基于DOM文档的实时查询。例如，下面的代码会导致无穷循环

* 任何时候要迭代NodeList，最好再初始化一个变量保存当时查询时的长度，然后用循环变量与这个变量进行比较


### 14.3 MutationObserver接口

* 新创建的MutationObserver实例不会关联DOM的任何部分。要把这个observer与DOM关联起来，需要使用observe()方法。这个方法接收两个必需的参数：要观察其变化的DOM节点，以及一个MutationObserverInit对象。

* MutationObserver接口是出于性能考虑而设计的，其核心是异步回调与记录队列模型。为了在大量变化事件发生时不影响性能，每次变化的信息（由观察者实例决定）会保存在MutationRecord实例中，然后添加到记录队列。这个队列对每个MutationObserver实例都是唯一的，是所有DOM变化事件的有序列表


### 14.4 小结

* 要理解DOM，最关键的一点是知道影响其性能的问题所在。DOM操作在JavaScript代码中是代价比较高的，NodeList对象尤其需要注意。NodeList对象是“实时更新”的，这意味着每次访问它都会执行一次新的查询。考虑到这些问题，实践中要尽量减少DOM操作的数量。


### 第15章 DOM扩展

* 本章所有内容已经得到市场占有率名列前茅的所有主流浏览器支持，除非特别说明。


### 15.1 Selectors API

* Selectors API Level 1的核心是两个方法：querySelector()和querySelectorAll()。在兼容浏览器中，Document类型和Element类型的实例上都会暴露这两个方法

* Selectors API Level 2规范在Element类型上新增了更多方法，比如matches()、find()和findAll()。不过，目前还没有浏览器实现或宣称实现find()和findAll()

* 再强调一次，querySelectorAll()返回的NodeList实例一个属性和方法都不缺，但它是一个静态的“快照”，而非“实时”的查询。这样的底层实现避免了使用NodeList对象可能造成的性能问题。


### 15.3 HTML5

* 注意 因为HTML5覆盖的范围极其广泛，所以本节主要讨论其影响所有DOM节点的部分。HTML5的其他部分将在本书后面的相关章节中再讨论。

* getElementsByClassName()是HTML5新增的最受欢迎的一个方法，暴露在document对象和所有HTML元素上。这个方法脱胎于基于原有DOM特性实现该功能的JavaScript库，提供了性能高好的原生实现。

* HTML5通过给所有元素增加classList属性为这些操作提供了更简单也更安全的实现方式。classList是一个新的集合类型DOMTokenList的实例。与其他DOM集合类型一样，DOMTokenList也有length属性表示自己包含多少项，也可以通过item()或中括号取得个别的元素。此外，DOMTokenList还增加了以下方法。


* 第一个方法可以用来查询文档，确定哪个元素拥有焦点，第二个方法可以查询文档是否获得了焦点，而这对于保证Web应用程序的无障碍使用是非常重要的。无障碍Web应用程序的一个重要方面就是焦点管理，而能够确定哪个元素当前拥有焦点（相比于之前的猜测）是一个很大的进步。

* 作为对document.body（指向文档的<body>元素）的补充，HTML5增加了document.head属性，指向文档的<head>元素。

* 在读取innerHTML属性时，会返回元素所有后代的HTML字符串，包括元素、注释和文本节点。而在写入innerHTML时，则会根据提供的字符串值以新的DOM子树替代元素中原来包含的所有节点。

* 注意 设置innerHTML会导致浏览器将HTML字符串解析为相应的DOM树。这意味着设置innerHTML属性后马上再读出来会得到不同的字符串。这是因为返回的字符串是将原始字符串对应的DOM子树序列化之后的结果。

* 注意 Firefox在内容类型为application/xhtml+xml的XHTML文档中对innerHTML更加严格。在XHTML文档中使用innerHTML，必须使用格式良好的XHTML代码。否则，在Firefox中会静默失败。

* 使用本节介绍的方法替换子节点可能在浏览器（特别是IE）中导致内存问题。比如，如果被移除的子树元素中之前有关联的事件处理程序或其他JavaScript对象（作为元素的属性），那它们之间的绑定关系会滞留在内存中。如果这种替换操作频繁发生，页面的内存占用就会持续攀升。在使用innerHTML、outerHTML和insertAdjacentHTML()之前，最好手动删除要被替换的元素上关联的事件处理程序和JavaScript对象。


### 15.4 专有扩展

* 注意 Firefox 45（2016年3月发布）以前的版本中只支持textContent属性，与innerText的区别是返回的文本中也会返回行内样式或脚本代码。innerText目前已经得到所有浏览器支持，应该作为取得和设置文本内容的首选方法使用。


### 15.5 小结

* DOM扩展的数量总体还不大，但随着Web技术的发展一定会越来越多。浏览器仍然没有停止对专有扩展的探索，如果出现成功的扩展，那么就可能成为事实标准，或者最终被整合到未来的标准中。


### 16.1 DOM的演进

* 注意 跨源访问子内嵌窗格的document对象会受到安全限制。如果内嵌窗格中加载了不同域名（或子域名）的页面，或者该页面使用了不同协议，则访问其document对象会抛出错误。


### 16.2 样式

* 大多数属性名会这样直接转换过来。但有一个CSS属性名不能直接转换，它就是float。因为float是JavaScript的保留字，所以不能用作属性名。DOM2 Style规定它在style对象中对应的属性应该是cssFloat。

* 注意 在标准模式下，所有尺寸都必须包含单位。在混杂模式下，可以把style.width设置为"20"，相当于"20px"。如果是在标准模式下，把style.width设置为"20"会被忽略，因为没有单位。实践中，最好一直加上单位。

* 注意 浏览器虽然会返回样式值，但返回值的格式不一定相同。比如，Firefox和Safari会把所有颜色值转换为RGB格式（如红色会变成rgb(255,0,0)），而Opera把所有颜色转换为十六进制表示法（如红色会变成#ff0000）。因此在使用getComputedStyle()时一定要多测试几个浏览器。

* DOM规定，可以使用insertRule()方法向样式表中添加新规则。这个方法接收两个参数：规则的文本和表示插入位置的索引值。

* 注意 所有这些偏移尺寸属性都是只读的，每次访问都会重新计算。因此，应该尽量减少查询它们的次数。比如把查询的值保存在局量中，就可以避免影响性能。


### 16.3 遍历

* DOM2 Traversal and Range模块定义了两个类型用于辅助顺序遍历DOM结构。这两个类型——NodeIterator和TreeWalker——从某个起点开始执行对DOM结构的深度优先遍历。


### 16.4 范围

* 如果范围并没有选择文档的任何部分，则称为折叠（collapsed）。折叠范围有点类似文本框：如果文本框中有文本，那么可以用鼠标选中以高亮显示全部文本。这时候，如果再单击鼠标，则选区会被移除，光标会落在某两个字符中间。而在折叠范围时，位置会被设置为范围与文档交界的地方，可能是范围选区的开始处，也可能是结尾处。图16-10展示了范围折叠时会发生什么


### 第17章 事件

* JavaScript与HTML的交互是通过事件实现的，事件代表文档或浏览器窗口中某个有意义的时刻。可以使用仅在事件发生时执行的监听器（也叫处理程序）订阅事件。在传统软件工程领域，这个模型叫“观察者模式”，其能够做到页面行为（在JavaScript中定义）与页面展示（在HTML和CSS中定义）的分离。

* 浏览器的事件系统非常复杂。即使所有主流浏览器都实现了DOM2 Events，规范也没有涵盖所有的事件类型。BOM也支持事件，这些事件与DOM事件之间的关系由于长期以来缺乏文档，经常容易被混淆（HTML5已经致力于明确这些关系）。而DOM3新增的事件API又让这些问题进一步复杂化了。根据具体的需求不同，使用事件可能会相对简单，也可能会非常复杂。但无论如何，理解其中的核心概念还是最重要的


### 17.1 事件流

* 虽然这是Netscape Communicator唯一的事件流模型，但事件捕获得到了所有现代浏览器的支持。实际上，所有浏览器都是从window对象开始捕获事件，而DOM2 Events规范规定的是从document开始。

* DOM2 Events规范规定事件流分为3个阶段：事件捕获、到达目标和事件冒泡。事件捕获最先发生，为提前拦截事件提供了可能。然后，实际的目标元素接收到事件。最后一个阶段是冒泡，最迟要在这个阶段响应事件。

* 注意 所有现代浏览器都支持DOM事件流，只有IE8及更早版本不支持。


### 17.2 事件处理程序

* 事件意味着用户或浏览器执行的某种动作。比如，单击（click）、加载（load）、鼠标悬停（mouseover）。为响应事件而调用的函数被称为事件处理程序（或事件监听器）。事件处理程序的名字以"on"开头，因此click事件的处理程序叫作onclick，而load事件的处理程序叫作onload。有很多方式可以指定事件处理程序。

* 以这种方式指定的事件处理程序有一些特殊的地方。首先，会创建一个函数来封装属性的值。这个函数有一个特殊的局部变量event，其中保存的就是event对象

* 如果这个元素是一个表单输入框，则作用域链中还会包含表单元素，事件处理程序对应的函数等价于如下这样

* 本质上，经过这样的扩展，事件处理程序的代码就可以不必引用表单元素，而直接访问同一表单中的其他成员了。

* 使用HTML指定事件处理程序的最后一个问题是HTML与JavaScript强耦合。如果需要修改事件处理程序，则必须在两个地方，即HTML和JavaScript中，修改代码。这也是很多开发者不使用HTML事件处理程序，而使用JavaScript指定事件处理程序的主要原因。

* 像这样使用DOM0方式为事件处理程序赋值时，所赋函数被视为元素的方法。因此，事件处理程序会在元素的作用域中运行，即this等于元素。下面的例子演示了使用this引用元素本身

* 注意 如果事件处理程序是在HTML中指定的，则onclick属性的值是一个包装相应HTML事件处理程序属性值的函数。这些事件处理程序也可以通过在JavaScript中将相应属性设置为null来移除。

* DOM2 Events为事件处理程序的赋值和移除定义了两个方法：addEventListener()和remove-EventListener()。这两个方法暴露在所有DOM节点上，它们接收3个参数：事件名、事件处理函数和一个布尔值，true表示在捕获阶段调用事件处理程序，false（默认值）表示在冒泡阶段调用事件处理程序。

* 大多数情况下，事件处理程序会被添加到事件流的冒泡阶段，主要原因是跨浏览器兼容性好。把事件处理程序注册到捕获阶段通常用于在事件到达其指定目标之前拦截事件。如果不需要拦截，则不要使用事件捕获。


### 17.3 事件对象

* 在DOM中发生事件时，所有相关信息都会被收集并存储在一个名为event的对象中。这个对象包含了一些基本信息，比如导致事件的元素、发生的事件类型，以及可能与特定事件相关的任何其他数据。例如，鼠标操作导致的事件会生成鼠标位置信息，而键盘操作导致的事件会生成与被按下的键有关的信息。所有浏览器都支持这个event对象，尽管支持方式不同。

* 在这个例子中，函数handler被用于处理3种不同的事件：click、mouseover和mouseout。当按钮被点击时，应该在控制台打印一条消息，如前面的例子所示。而把鼠标放到按钮上，会导致按钮背景变成红色，接着把鼠标从按钮上移开，背景颜色应该又恢复成默认值。这个函数使用event.type属性确定了事件类型，从而可以做出不同的响应。

* preventDefault()方法用于阻止特定事件的默认动作。比如，链接的默认行为就是在被单击时导航到href属性指定的URL。如果想阻止这个导航行为，可以在onclick事件处理程序中取消

* stopPropagation()方法用于立即阻止事件流在DOM结构中传播，取消后续的事件捕获或冒泡。例如，直接添加到按钮的事件处理程序中调用stopPropagation()，可以阻止document.body上注册的事件处理程序执行。

* 注意 event对象只在事件处理程序执行期间存在，一旦执行完毕，就会被销毁。


### 17.4 事件类型

* Web浏览器中可以发生很多种事件。如前所述，所发生事件的类型决定了事件对象中会保存什么信息。DOM3 Events定义了如下事件类型。

* 注意 根据DOM2 Events, load事件应该在document而非window上触发。可是为了向后兼容，所有浏览器都在window上实现了load事件。

* 注意 根据DOM2 Events, unload事件应该在<body>而非window上触发。可是为了向后兼容，所有浏览器都在window上实现了unload事件。

* 注意 浏览器窗口在最大化和最小化时也会触发resize事件。

* ❑ dblclick：在用户双击鼠标主键（通常是左键）时触发。这个事件不是在DOM2 Events中定义的，但得到了很好的支持，DOM3 Events将其进行了标准化。

* 页面中的所有元素都支持鼠标事件。除了mouseenter和mouseleave，所有鼠标事件都会冒泡，都可以被取消，而这会影响浏览器的默认行为。
由于事件之间存在关系，因此取消鼠标事件的默认行为也会影响其他事件。
比如，click事件触发的前提是mousedown事件触发后，紧接着又在同一个元素上触发了mouseup事件。如果mousedown和mouseup中的任意一个事件被取消，那么click事件就不会触发。类似地，两次连续的click事件会导致dblclick事件触发。只要有任何逻辑阻止了这两个click事件发生（比如取消其中一个click事件或者取消mousedown或mouseup事件中的任一个）, dblclick事件就不会发生。

* 鼠标事件都是在浏览器视口中的某个位置上发生的。这些信息被保存在event对象的clientX和clientY属性中。这两个属性表示事件发生时鼠标光标在视口中的坐标，所有浏览器都支持。

* 虽然鼠标事件主要是通过鼠标触发的，但有时候要确定用户想实现的操作，还要考虑键盘按键的状态。键盘上的修饰键Shift、Ctrl、Alt和Meta经常用于修改鼠标事件的行为。DOM规定了4个属性来表示这几个修饰键的状态：shiftKey、ctrlKey、altKey和metaKey。这几属性会在各自对应的修饰键被按下时包含布尔值true，没有被按下时包含false。在鼠标事件发生的，可以通过这几个属性来检测修饰键是否被按下。

* 注意 HTML5也增加了mousewheel事件，以反映大多数浏览器对它的支持。

* 对于keydown和keyup事件，event对象的keyCode属性中会保存一个键码，对应键盘上特定的一个键。对于字母和数字键，keyCode的值与小写字母和数字的ASCII编码一致。比如数字7键的keyCode为55，而字母A键的keyCode为65，而且跟是否按了Shift键无关。DOM和IE的event对象都支持keyCode属性。

* 注意 这些事件已经被废弃，浏览器已经在有计划地停止对它们的支持。变化事件已经被Mutation Observers所取代，可以参考第14章中的介绍

* 注意 因为orientationchange事件被认为是window事件，所以也可以通过给<body>元素添加onorientationchange属性来指定事件处理程序。


### 17.5 内存与性能

* 因为事件处理程序在现代Web应用中可以实现交互，所以很多开发者会错误地在页面中大量使用它们。在创建GUI的语言如C#中，通常会给GUI上的每个按钮设置一个onclick事件处理程序。这样做不会有什么性能损耗。在JavaScript中，页面中事件处理程序的数量与页面整体性能直接相关。原因有很多。首先，每个函数都是对象，都占用内存空间，对象越多，性能越差。其次，为指定事件处理程序所需访问DOM的次数会先期造成整个页面交互的延迟。只要在使用事件处理程序时多注意一些方法，就可以改善页面性能。

* 把事件处理程序指定给元素后，在浏览器代码和负责页面交互的JavaScript代码之间就建立了联系。这种联系建立得越多，页面性能就越差。除了通过事件委托来限制这种连接之外，还应该及时删除不用的事件处理程序。很多Web应用性能不佳都是由于无用的事件处理程序长驻内存导致的。


### 17.6 模拟事件

* 事件就是为了表示网页中某个有意义的时刻。通常，事件都是由用户交互或浏览器功能触发。事实上，可能很少有人知道可以通过JavaScript在任何时候触发任意事件，而这些事件会被当成浏览器创建的事件。这意味着同样会有事件冒泡，因而也会触发相应的事件处理程序。这种能力在测试Web应用时特别有用。DOM3规范指明了模拟特定类型事件的方式。IE8及更早版本也有自己模拟事件的方式。


### 17.7 小结

* 事件是JavaScript与网页结合的主要方式。最常见的事件是在DOM3 Events规范或HTML5中定义的。虽然基本的事件都有规范定义，但很多浏览器在规范之外实现了自己专有的事件，以方便开发者更好地满足用户交互需求，其中一些专有事件直接与特殊的设备相关。
围绕着使用事件，需要考虑内存与性能问题。例如：
❑ 最好限制一个页面中事件处理程序的数量，因为它们会占用过多内存，导致页面响应缓慢；
❑ 利用事件冒泡，事件委托可以解决限制事件处理程序数量的问题；
❑ 最好在页面卸载之前删除所有事件处理程序。


### 18.1 使用requestAnimationFrame

* 更麻烦的是，浏览器又开始对切换到后台或不活跃标签页中的计时器执行限流。因此即使将时间间隔设定为最优，也免不了只能得到近似的结果。


### 第19章 表单脚本

* JavaScript较早的一个用途是承担一部分服务器端表单处理的责任。虽然Web和JavaScript都已经发展了很多年，但Web表单的变化不是很大。由于不能直接使用表单解决问题，因此开发者不得不使用JavaScript既做表单验证，又用于增强标准表单控件的默认行为。


### 19.1 表单基础

* 表单是通过用户点击提交按钮或图片按钮的方式提交的。提交按钮可以使用type属性为"submit"的<input>或<button>元素来定义，图片按钮可以使用type属性为"image"的<input>元素来定义。

* 如果表单中有上述任何一个按钮，且焦点在表单中某个控件上，则按回车键也可以提交表单。（textarea控件是个例外，当焦点在它上面时，按回车键会换行。）注意，没有提交按钮的表单在按回车键时不会提交。
以这种方式提交表单会在向服务器发送请求之前触发submit事件。这样就提供了一个验证表单数据的机会，可以根据验证结果决定是否真的要提交。阻止这个事件的默认行为可以取消提交表单。

* 表单提交的一个最大的问题是可能会提交两次表单。如果提交表单之后没有什么反应，那么没有耐心的用户可能会多次点击提交按钮。结果是很烦人的（因为服务器要处理重复的请求），甚至可能造成损失（如果用户正在购物，则可能会多次下单）。解决这个问题主要有两种方式：在表单提交后禁用提交按钮，或者通过onsubmit事件处理程序取消之后的表单提交。

* 注意 表单设计中通常不提倡重置表单，因为重置表单经常会导致用户迷失方向，如果意外触发则会令人感到厌烦。实践中几乎没有重置表单的需求。一般来说，提供一个取消按钮，让用户点击返回前一个页面，而不是恢复表单中所有的值来得更直观。

* 因此最好使用表单的submit事件来禁用提交按钮。但这种方式不适用于没有使用提交按钮的表单提交。如前所述，只有提交按钮才能触发submit事件。

* 每个表单字段都有两个公共方法：focus()和blur()。focus()方法把浏览器焦点设置到表单字段，这意味着该字段会变成活动字段并可以响应键盘事件。

* 注意 默认情况下只能给表单元素设置焦点。不过，通过将tabIndex属性设置为-1再调用focus()，也可以给任意元素设置焦点。只有Opera不支持这个技术。

* 注意 blur和change事件的关系并没有明确定义。在某些浏览器中，blur事件会先于change事件触发；在其他浏览器中，触发顺序则相反。因此不能依赖这两个事件触发的顺序，必须区分时要多加注意。


### 19.2 文本框编程

* 如果想只屏蔽特定字符，则需要检查事件的charCode属性，以确定正确的回应方式。

* IE是第一个支持剪贴板相关事件及通过JavaScript访问剪贴板数据的浏览器。IE的实现成为了事实标准，这是因为Safari、Chrome、Opera和Firefox都实现了相同的事件和剪贴板访问机制，后来HTML5也增加了剪贴板事件。

* 注意，不同浏览器处理必填字段的机制不同。Firefox、Chrome、IE和Opera会阻止表单提交并在相应字段下面显示有帮助信息的弹框，而Safari什么也不做，也不会阻止提交表单。



### 19.6 小结

* 尽管HTML和Web应用自诞生以来已经发生了天翻地覆的变化，但Web表单几乎从来没有变过。JavaScript可以增加现有的表单字段以提供新功能或增强易用性。为此，表单字段也暴露了属性、方法和事件供JavaScript使用。以下是本章介绍的一些概念。
❑ 可以使用标准或非标准的方法全部或部分选择文本框中的文本。
❑ 所有浏览器都采用了Firefox操作文本选区的方式，使其成为真正的标准。
❑ 可以通过监听键盘事件并检测要插入的字符来控制文本框接受或不接受某些字符。
所有浏览器都支持剪贴板相关的事件，包括copy、cut和paste。剪贴板事件在不同浏览器中的实现有很大差异


### 第20章 JavaScriptAPI

* 注意 Web API的数量之多令人难以置信（参见MDN文档的Web APIs词条）。本章要介绍的API仅限于与大多数开发者有关、已经得到多个浏览器支持，且本书其他章节没有涵盖的部分。


### 20.1 Atomics与SharedArrayBuffer

* 在多线程程序中，一个线程可能只希望在上次读取某个值之后没有其他线程修改该值的情况下才对共享缓冲区执行写操作。如果这个值没有被修改，这个线程就可以安全地写入更新后的值；如果这个值被修改了，那么执行写操作将会破坏其他线程计算的值。对于这种任务，Atomics API提供了compare-Exchange()方法。这个方法只在目标索引处的值与预期值匹配时才会执行写操作。


### 20.3 Encoding API

* 注意 相比于批量（bulk）的编解码，对流（stream）编解码的支持很有限。


### 20.4 File API与Blob API

* Web应用程序的一个主要的痛点是无法操作用户计算机上的文件。2000年之前，处理文件的唯一方式是把<input type="file">放到一个表单里，仅此而已。File API与Blob API是为了让Web开发者能以安全的方式访问客户端机器上的文件，从而更好地与这些文件交互而设计的。


### 20.5 媒体元素

* 随着嵌入音频和视频元素在Web应用上的流行，大多数内容提供商会强迫使用Flash以便达到最佳的跨浏览器兼容性。HTML5新增了两个与媒体相关的元素，即<audio>和<video>，从而为浏览器提供了嵌入音频和视频的统一解决方案。


### 20.6 原生拖放

* 关于拖放最有意思的可能就是可以跨窗格、跨浏览器容器，有时候甚至可以跨应用程序拖动元素。浏览器对拖放的支持可以让我们实现这些功能。


### 20.7 Notifications API

* Notifications API用于向用户显示通知。无论从哪个角度看，这里的通知都很类似alert()对话框：都使用JavaScript API触发页面外部的浏览器行为，而且都允许页面处理用户与对话框或通知弹层的交互。不过，通知提供更灵活的自定义能力。
Notifications API在Service Worker中非常有用。渐进Web应用（PWA, Progressive Web Application）通过触发通知可以在页面不活跃时向用户显示消息，看起来就像原生应用。


### 20.8 Page Visibility API

* Web开发中一个常见的问题是开发者不知道用户什么时候真正在使用页面。如果页面被最小化或隐藏在其他标签页后面，那么轮询服务器或更新动画等功能可能就没有必要了。Page Visibility API旨在为开发者提供页面对用户是否可见的信息。



### 20.9 Streams API

* Streams API是为了解决一个简单但又基础的问题而生的：Web应用如何消费有序的小信息块而不是大块信息？这种能力主要有两种应用场景。

* 注意 虽然Fetch API已经得到所有主流浏览器支持，但Streams API则没有那么快得到支持。


### 20.10 计时API

* 页面性能始终是Web开发者关心的话题。Performance接口通过JavaScript API暴露了浏览器内部的度量指标，允许开发者直接访问这些信息并基于这些信息实现自己想要的功能。这个接口暴露在window.performance对象上。所有与页面相关的指标，包括已经定义和将来会定义的，都会存在于这个对象上。

* 注意 通过使用performance.now()测量L1缓存与主内存的延迟差，幽灵漏洞（Spectre）可以执行缓存推断攻击。为弥补这个安全漏洞，所有的主流浏览器有的选择降低performance.now()的精度，有的选择在时间戳里混入一些随机性。

* Navigation Timing API提供了高精度时间戳，用于度量当前页面加载速度。浏览器会在导航事件发生时自动记录PerformanceNavigationTiming条目。这个对象会捕获大量时间戳，用于描述页面是何时以及如何加载的。

* Resource Timing API提供了高精度时间戳，用于度量当前页面加载时请求资源的速度。浏览器会在加载资源时自动记录PerformanceResourceTiming。这个对象会捕获大量时间戳，用于描述资源加载的速度。


### 20.11 Web组件

* 相反，更好的方式是提前在页面中写出特殊标记，让浏览器自动将其解析为DOM子树，但跳过渲染。这正是HTML模板的核心思想，而<template>标签正是为这个目的而生的。

* DocumentFragment也是批量向HTML中添加元素的高效工具。比如，我们想以最快的方式给某个HTML元素添加多个子元素。如果连续调用document.appendChild()，则不仅费事，还会导致多次布局重排。而使用DocumentFragment可以一次性添加所有子节点，最多只会有一次布局重排

* 概念上讲，影子DOM（shadow DOM）Web组件相当直观，通过它可以将一个完整的DOM树作为节点添加到父DOM树。这样可以实现DOM封装，意味着CSS样式和CSS选择符可以限制在影子DOM子树而不是整个顶级DOM树中。
影子DOM与HTML模板很相似，因为它们都是类似document的结构，并允许与顶级DOM有一定程度的分离。不过，影子DOM与HTML模板还是有区别的，主要表现在影子DOM的内容会实际渲染到页面上，而HTML模板的内容不会。

* 影子DOM是通过attachShadow()方法创建并添加给有效HTML元素的。容纳影子DOM的元素被称为影子宿主（shadow host）。影子DOM的根节点被称为影子根（shadow root）。


* 注意 如果想保护独立的DOM树不受未信任代码影响，影子DOM并不适合这个需求。对<iframe>施加的跨源限制更可靠。

* 注意，事件重定向只会发生在影子DOM中实际存在的元素上。使用<slot>标签从外部投射进来的元素不会发生事件重定向，因为从技术上讲，这些元素仍然存在于影子DOM外部。


### 20.12 Web Cryptography API

* Web Cryptography API描述了一套密码学工具，规范了JavaScript如何以安全和符合惯例的方式实现加密。这些工具包括生成、使用和应用加密密钥对，加密和解密消息，以及可靠地生成随机数。

* 注意 SubtleCrypto对象只能在安全上下文（https）中使用。在不安全的上下文中，subtle属性是undefined。


### 21.1 浏览器错误报告

* 所有主流桌面浏览器，包括IE/Edge、Firefox、Safari、Chrome和Opera，都提供了向用户报告错误的机制。默认情况下，所有浏览器都会隐藏错误信息。一个原因是除了开发者之外这些信息对别人没什么用，另一个原因是网页在正常操作中报错的固有特性。


### 21.2 错误处理

* 这个例子使用message属性向用户显示错误消息。message属性是唯一一个在IE、Firefox、Safari、Chrome和Opera中都有的属性

* 注意 只要代码中包含了finally子句，try块或catch块中的return语句就会被忽略，理解这一点很重要。在使用finally时一定要仔细确认代码的行为。

* ReferenceError会在找不到对象时发生。（这就是著名的"object expected"浏览器错误的原因。）这种错误经常是由访问不存在的变量而导致的

* try/catch语句最好用在自己无法控制的错误上。例如，假设你的代码中使用了一个大型JavaScript库的某个函数，而该函数可能会有意或由于出错而抛出错误。因为不能修改这个库的代码，所以为防止这个函数报告错误，就有必要通过try/catch语句把该函数调用包装起来，对可能的错误进行处理。
如果你明确知道自己的代码会发生某种错误，那么就不适合使用try/catch语句。例如，如果给函数传入字符串而不是数值时就会失败，就应该检查该函数的参数类型并采取相应的操作。这种情况下，没有必要使用try/catch语句。

* 虽然Firefox、Chrome和Safari至少给出了导致错误的相关代码，但并没有哪个错误消息特别明确地指出发生了什么，或者怎么修复。对于上面的一个函数来说，通过这样的错误消息调试还是很容易的。但是，如果是一个复杂的Web应用程序，有几千行JavaScript代码，想要找到错误的原因就会很难。
这时候，使用适当的信息创建自定义错误可以有效提高代码的可维护性。

* 至于抛出错误与捕获错误的区别，可以这样想：应该只在确切知道接下来该做什么的时候捕获错误。捕获错误的目的是阻止浏览器以其默认方式响应；抛出错误的目的是为错误提供有关其发生原因的说明。

* 注意 浏览器在使用这个事件处理错误时存在明显差异。在IE中发生error事件时，正常代码会继续执行，所有变量和数据会保持，且可以在onerror事件处理程序中访问。然而在Firefox中，正常代码会执行会终止，错误发生之前的所有变量和数据会被销毁，导致很难真正分析处理错误。

* 在Web应用程序的JavaScipt层面落地错误处理策略同样重要。因为任何JavaScript错误都可能导致网页无法使用，所以理解这些错误会在什么情况下发生以及为什么会发生非常重要。绝大多数Web应用程序的用户不懂技术，在碰到页面出问题时通常会迷惑。为解决问题，他们可能会尝试刷新页面，也可能会直接放弃。作为开发者，应该非常清楚自己的代码在什么情况下会失败，以及失败会导致什么结果。另外，还要有一个系统跟踪这些问题。

* 注意 随着代码数量的增长，代码分析器会变得越来越重要，尤其是协作开发者也在增加的情况下。所有主流技术公司都有着庞大的JavaScript库，并会在构建流程中使用稳健的静态分析工具。

* 注意代码风格指南通常会指出什么时候应使用===，什么时候应使用==。有些风格指南认同只要始终使用===，类型转换就不再是个问题。另一些则认为除了可能发生字符串/布尔值转换的情形，在其他时候使用===均是用力过猛的表现。

* 任何错误处理策略中一个非常重要的方面就是确定某个错误是否为重大错误。

* 通过在for循环中加入try/catch语句，模块初始化过程中的任何错误都不会影响其他模块初始化。如果代码中有错误发生，则可以单独处理，并不会影响用户体验。


### 21.3 调试技术

* 在JavaScript调试器出现以前，开发者必须使用创造性的方法调试代码。结果就出现了各种各样专门为输出调试信息而设计的代码。其中最为常用的调试技术是在相关代码中插入alert()，这种方式既费事（调试完之后还得清理）又麻烦（如果有漏洞的警告框出现在产品环境中，会给用户造成不便）。已不再推荐将警告框用于调试，因为有其他更好的解决方案。

* 注意 相比于使用警告框，打印日志消息是更好的调试方法。这是因为警告框会阻塞代码执行，从而影响对异步操作的计时，进而影响代码的结果。打印日志也可以随意输出任意多个参数并检查对象实例（警告框只能将对象序列化为一个字符串再展示出来，因此经常会看到Object[Object]。

* 控制台运行时也会集成开发者工具，提供常规JavaScript开发中所没有的上下文调试工具。其中一个非常有用的工具是最后点击选择器，所有主流浏览器都会提供。在开发者工具的Element（元素）标签页内，单击DOM树中一个节点，就可以在Console（控制台）标签页中使用$0引用该节点的JavaScript实例。它就跟普通的JavaScript实例一样，因此可以读取属性（如$0.scrollWidth），或者调用成员方法（如$0.remove()）。


* 在所有主流浏览器中都可以使用的还有JavaScript调试器。ECMAScript 5.1规范定义了debugger关键字，用于调用可能存在的调试功能。

* 在运行时碰到这个关键字时，所有主流浏览器都会打开开发者工具面板，并在指定位置显示断点。然后，可以通过单独的浏览器控制台在断点所在的特定词法作用域中执行代码。此外，还可以执行标准的代码调试器操作（单步进入、单步跳过、继续，等等）。


### 第23章 JSON

* 理解JSON最关键的一点是要把它当成一种数据格式，而不是编程语言。JSON不属于JavaScript，它们只是拥有相同的语法而已。JSON也不是只能在JavaScript中使用，它是一种通用数据格式。很多语言都有解析和序列化JSON的内置能力。


### 23.2 解析与序列化

* JSON的迅速流行并不仅仅因为其语法与JavaScript类似，很大程度上还因为JSON可以直接被解析成可用的JavaScript对象。与解析为DOM文档的XML相比，这个优势非常明显。为此，JavaScript开发者可以非常方便地使用JSON数据。

* JSON对象有两个方法：stringify()和parse()。在简单的情况下，这两个方法分别可以将JavaScript序列化为JSON字符串，以及将JSON解析为原生JavaScript值。

* 在序列化JavaScript对象时，所有函数和原型成员都会有意地在结果中省略。此外，值为undefined的任何属性也会被跳过。最终得到的就是所有实例属性均为有效JSON数据类型的表示。

* 实际上，JSON.stringify()方法除了要序列化的对象，还可以接收两个参数。这两个参数可以用于指定其他序列化JavaScript对象的方式。第一个参数是过滤器，可以是数组或函数；第二个参数是用于缩进结果JSON字符串的选项。单独或组合使用这些参数可以更好地控制JSON序列化。

* JSON.stringify()方法的第三个参数控制缩进和空格。在这个参数是数值时，表示每一级缩进的空格数。例如，每级缩进4个空格，可以这样

* 有时候，对象需要在JSON.stringify()之上自定义JSON序列化。此时，可以在要序列化的对象中添加toJSON()方法，序列化时会基于这个方法返回适当的JSON表示。

* JSON.parse()方法也可以接收一个额外的参数，这个函数会针对每个键/值对都调用一次。为区别于传给JSON.stringify()的起过滤作用的替代函数（replacer），这个函数被称为还原函数（reviver）。实际上它们的格式完全一样，即还原函数也接收两个参数，属性名（key）和属性值（value），另外也需要返回值。



### 第24章 网络请求与远程资源

* XHR对象的API被普遍认为比较难用，而Fetch API自从诞生以后就迅速成为了XHR更现代的替代标准。Fetch API支持期约（promise）和服务线程（service worker），已经成为极其强大的Web开发工具。


### 24.1 XMLHttpRequest对象

* 注意 只能访问同源URL，也就是域名相同、端口相同、协议相同。如果请求的URL与发送请求的页面在任何方面有所不同，则会抛出安全错误。

* IE8给XHR对象增加了一个timeout属性，用于表示发送请求后等待多少毫秒，如果响应不成功就中断请求。之后所有浏览器都在自己的XHR实现中增加了这个属性。在给timeout属性设置了一个时间且在该时间过后没有收到响应时，XHR对象就会触发timeout事件，调用ontimeout事件处理程序。


### 24.5 Fetch API

* Fetch API能够执行XMLHttpRequest对象的所有任务，但更容易使用，接口也更现代化，能够在Web工作线程等现代Web工具中使用。XMLHttpRequest可以选择异步，而Fetch API则必须是异步。Fetch API是WHATWG的一个“活标准”（living standard），用规范原文说，就是“Fetch标准定义请求、响应，以及绑定二者的流程：获取（fetch）”。


* Fetch API支持通过Response的status（状态码）和statusText（状态文本）属性检查响应状态。成功获取响应的请求通常会产生值为200的状态码

* Headers对象与Map对象极为相似。这是合理的，因为HTTP头部本质上是序列化后的键/值对，它们的JavaScript表示则是中间接口。Headers与Map类型都有get()、set()、has()和delete()等实例方法

* 通常，将Request和Response主体作为流来使用主要有两个原因。一个原因是有效载荷的大小可能会导致网络延迟，另一个原因是流API本身在处理有效载荷方面是有优势的。除此之外，最好是一次性获取资源主体。

* JavaScript编程逻辑很多时候会将访问网络作为原子操作，比如请求是同时创建和发送的，响应数据也是以统一的格式一次性暴露出来的。这种约定隐藏了底层的混乱，让涉及网络的代码变得很清晰。
从TCP/IP角度来看，传输的数据是以分块形式抵达端点的，而且速度受到网速的限制。接收端点会为此分配内存，并将收到的块写入内存。Fetch API通过ReadableStream支持在这些块到达时就实时读取和操作这些数据。


### 24.6 Beacon API

* 为了把尽量多的页面信息传到服务器，很多分析工具需要在页面生命周期中尽量晚的时候向服务器发送遥测或分析数据。因此，理想的情况下是通过浏览器的unload事件发送网络请求。这个事件表示用户要离开当前页面，不会再生成别的有用信息了。


### 24.7 Web Socket

* Web Socket（套接字）的目标是通过一个长时连接实现与服务器全双工、双向的通信。在JavaScript中创建Web Socket时，一个HTTP请求会发送到服务器以初始化连接。服务器响应后，连接使用HTTP的Upgrade头部从HTTP协议切换到Web Socket协议。这意味着Web Socket不能通过标准HTTP服务器实现，而必须使用支持该协议的专有服务器。


### 24.9 小结

* Fetch API是作为对XHR对象的一种端到端的替代方案而提出的。这个API提供了优秀的基于期约的结构、更直观的接口，以及对Stream API的最好支持。



### 25.1 cookie

* 注意 不要在cookie中存储重要或敏感的信息。cookie数据不是保存在安全的环境中，因此任何人都可能获得。应该避免把信用卡号或个人地址等信息保存在cookie中。


### 25.2 Web Storage

* Web Storage的第2版定义了两个对象：localStorage和sessionStorage。localStorage是永久存储机制，sessionStorage是跨会话的存储机制。

* 注意 Storage类型只能存储字符串。非字符串数据在存储之前会自动转换为字符串。注意，这种转换不能在获取数据时撤销。


### 25.3 IndexedDB

* IndexedDB的设计几乎完全是异步的。为此，大多数操作以请求的形式执行，这些请求会异步执行，产生成功的结果或错误。绝大多数IndexedDB操作要求添加onerror和onsuccess事件处理程序来确定输出。

* 有了事务的引用，就可以使用objectStore()方法并传入对象存储的名称以访问特定的对象存储。然后，可以使用add()和put()方法添加和更新对象，使用get()取得对象，使用delete()删除对象，使用clear()删除所有对象。其中，get()和delete()方法都接收对象键作为参数，这5个方法都创建新的请求对象。

* 对某些数据集，可能需要为对象存储指定多个键。例如，如果同时记录了用户ID和用户名，那可能需要通过任何一种方式来获取用户数据。为此，可以考虑将用户ID作为主键，然后在用户名上创建索引。


### 26.1 理解模块模式

* 将代码拆分成独立的块，然后再把这些块连接起来可以通过模块模式来实现。这种模式背后的思想很简单：把逻辑分块，各自封装，相互独立，每个块自行决定对外暴露什么，同时自行决定引入执行哪些外部代码。不同的实现和特性让这些基本的概念变得有点复杂，但这个基本的思想是所有JavaScript模块系统的基础。


### 26.3 使用ES6之前的模块加载器

* 注意 一般认为，Node.js的模块系统使用了CommonJS规范，实际上并不完全正确。Node.js使用了轻微修改版本的CommonJS，因为Node.js主要在服务器环境下使用，所以不需要考虑网络延迟问题。考虑到一致性，本节使用Node.js风格的模块定义语法。


### 26.4 使用ES6模块

* ES6最大的一个改进就是引入了模块规范。这个规范全方位简化了之前出现的模块加载器，原生浏览器支持意味着加载器及其他预处理都不再必要。从很多方面看，ES6模块系统是集AMD和CommonJS之大成者。

* 注意 什么可以或不可以与exprot关键字出现在同一行可能很难记住。一般来说，声明、赋值和导出标识符最好分开。这样就不容易搞错了，同时也可以让export语句集中在一块。


### 26.5 小结

* 模块模式是管理复杂性的永恒工具。开发者可以通过它创建逻辑彼此独立的代码段，在这些代码段之间声明依赖，并将它们连接在一起。此外，这种模式也是经证明能够优雅扩展到任意复杂度且跨平台的方案。
多年以来，CommonJS和AMD这两个分别针对服务器端环境和受延迟限制的客户端环境的模块系统长期分裂。两个系统都获得了爆炸性增强，但为它们编写的代码则在很多方面不一致，经常也会带有冗余的样板代码。而且，这两个系统都没有在浏览器中实现。缺乏兼容导致出现了相关工具，从而让在浏览器中实现模块模式成为可能。
ECMAScript 6规范重新定义了浏览器模块，集之前两个系统之长于一身，并通过更简单的声明性语法暴露出来。浏览器对原生模块的支持越来越好，但也提供了稳健的工具以实现从不支持到支持ES6模块的过渡。


### 第27章 工作者线程

* 单线程就意味着不能像多线程语言那样把工作委托给独立的线程或进程去做。JavaScript的单线程可以保证它与不同浏览器API兼容。假如JavaScript可以多线程执行并发更改，那么像DOM这样的API就会出现问题。因此，POSIX线程或Java的Thread类等传统并发结构都不适合JavaScript。
而这也正是工作者线程的价值所在：允许把主线程的工作转嫁给独立的实体，而不会改变现有的单线程模型。虽然本章要介绍的各种工作者线程有不同的形式和功能，但它们的共同的特点是都独立于JavaScript的主执行环境。


### 27.2 专用工作者线程

* 注意 这里两个独立的JavaScript线程都在向一个console对象发消息，该对象随后将消息序列化并在浏览器控制台打印出来。浏览器从两个不同的JavaScript线程收到消息，并按照自己认为合适的顺序输出这些消息。为此，在多线程应用程序中使用日志确定操作顺序时必须要当心。

* 注意 像这样序列化函数有个前提，就是函数体内不能使用通过闭包获得的引用，也包括全局变量，比如window，因为这些引用在工作者线程中执行时会出错。

* 注意 顶级工作者线程的脚本和子工作者线程的脚本都必须从与主页相同的源加载。

* 使用工作者线程时，经常需要为它们提供某种形式的数据负载。工作者线程是独立的上下文，因此在上下文之间传输数据就会产生消耗。在支持传统多线程模型的语言中，可以使用锁、互斥量，以及volatile变量。在JavaScript中，有三种在上下文间转移信息的方式：结构化克隆算法（structured clone algorithm）、可转移对象（transferable objects）和共享数组缓冲区（shared array buffers）。

* 注意 草率地采用并行计算不一定是最好的办法。线程池的调优策略会因计算任务不同和系统硬件不同而不同。


### 27.4 服务工作者线程

* 注意 服务工作者线程涉及的内容极其广泛，几乎可以单独写一本书。为了更好地理解这一话题，推荐有条件的读者学一下Udacity的课程“Offline Web Applications”。除此之外，也可以参考Mozilla维护的Service Worker Cookbook网站，其中包含了常见的服务工作者线程模式。
注意 服务工作者线程的生命周期取决于打开的同源标签页（称为“客户端”）数量、页面是否发生导航，以及服务脚本是否改变（以及其他一些因素）。如果对服务工作者线程的生命周期认识不够，本节的一些例子可能会让人觉得出乎意料。27.4.5节详细解释了服务工作者线程的生命周期。
另外，在调试服务工作者线程时，要谨慎使用浏览器的强制刷新功能（Ctrl+Shift+R）。强制刷新会强制浏览器忽略所有网络缓存，而服务工作者线程对大多数主流浏览器而言就是网络缓存。

* 注意 有些浏览器也支持async事件，该事件是在Background Sync API中定义的。Background Sync API还没有标准化，目前只有Chrome和Opera支持，因此本书没介绍。

* 理解服务工作者线程的生命周期与它所控制的客户端的生命周期无关非常重要。大多数浏览器将服务工作者线程实现为独立的进程，而该进程由浏览器单独控制。如果浏览器检测到某个服务工作者线程空闲了，就可以终止它并在需要时再重新启动。这意味着可以依赖服务工作者线程在激活后处理事件，但不能依赖它们的持久化全局状态。


### 27.5 小结

* 工作者线程可以运行异步JavaScript而不阻塞用户界面。这非常适合复杂计算和数据处理，特别是需要花较长时间因而会影响用户使用网页的处理任务。工作者线程有自己独立的环境，只能通过异步消息与外界通信。
工作者线程可以是专用线程、共享线程。专用线程只能由一个页面使用，而共享线程则可以由同源的任意页面共享。
服务工作者线程用于让网页模拟原生应用程序。服务工作者线程也是一种工作者线程，但它们更像是网络代理，而非独立的浏览器线程。可以把它们看成是高度定制化的网络缓存，它们也可以在PWA中支持推送通知。


### 28.1 可维护性

* 注意 可维护代码的概念并不只适用于JavaScript，其中很多概念适用于所有编程语言，尽管部分概念特定于JavaScript。

* 能够写出可维护的JavaScript代码是一项重要的专业技能。这就是业余爱好者和专业开发人员之间的区别，前者用一个周末就拼凑出一个网站，而后者真正了解自己的技术。

* ❑ 使用黑科技。由于浏览器之间的差异，JavaScript代码中通常包含一些黑科技。不要假设其他人一看就能明白某个黑科技是为了解决某个浏览器的什么问题。如果某个浏览器不能使用正常方式达到目的，那要在注释里把黑科技的用途写出来。这样可以避免别人误以为黑科技没有用而把它“修复”掉，结果你已解决的问题又会出现。

* 代码中变量和函数的适当命名对于其可读性和可维护性至关重要。因为很多JavaScript开发者是业余爱好者出身，所以很容易用foo、bar命名变量，用doSomething来命名函数。专业JavaScript开发者必须改掉这些习惯，这样才能写出可维护的代码。以下是关于命名的通用规则。

* 匈牙利表示法也可以很好地应用于函数参数。它的缺点是使代码可读性下降、不够直观，并破坏了类似句子的自然阅读流畅性。因此，匈牙利表示法在开发者中失宠了。

* Web开发中最常见的耦合是HTML/JavaScript耦合。在网页中，HTML和JavaScript分别代表不同层面的解决方案。HTML是数据，JavaScript是行为。这是因为它们之间要交互操作，需要通过不同的方式将这两种技术联系起来。可惜的是，其中一些方式会导致HTML与JavaScript紧密耦合。

* 解耦HTML和JavaScript可以节省排错时间，因为更容易定位错误来源。同样解耦也有助于保证可维护性。修改行为只涉及JavaScript，修改标记只涉及要渲染的文件。

* 同样，保证层与层之间的适当分离至关重要。显示出问题就应该只到CSS中解决，行为出问题就应该只找JavaScript的问题。这些层之间的松散耦合可以提升整个应用程序的可维护性。

* 把应用程序逻辑从事件处理程序中分离出来有很多好处。首先，这可以让我们以最少的工作量轻松地修改触发某些流程的事件。如果原来是通过鼠标单击触发流程，而现在又想增加键盘操作来触发，那么修改起来也很简单。其次，可以在不用添加事件的情况下测试代码，这样创建单元测试或自动化应用程序流都会更简单。

* JavaScript的动态特性意味着几乎可以在任何时候修改任何东西。过去有人说，JavaScript中没有什么是神圣不可侵犯的，因为不能把任何东西标记为最终结果或者恒定不变。但ECMAScript 5引入防篡改对象之后，情况不同了。

* 为此，最好的方法是永远不要修改不属于你的对象。只有你自己创建的才是你的对象，包括自定义类型和对象字面量。Array、document等对象都不是你的，因为在你的代码执行之前它们已经存在了。可以按如下这样为对象添加新功能。


### 28.2 性能

* 使用变量和数组相比访问对象属性效率更高，访问对象属性的算法复杂度是O（n）。访问对象的每个属性都比访问变量或数组花费的时间长，因为查找属性名要搜索原型链。简单来说，查找的属性越多，执行时间就越长。

* 注意 在旧版浏览器中，从循环迭代器的最大值开始递减至0的效率更高。之所以这样更快，是因为JavaScript引擎用于检查循环分支条件的指令数更少。在现代浏览器中，正序还是倒序不会有可感知的性能差异。因此可以选择最适合代码逻辑的迭代方式。

* ❑ switch 语句很快。如果代码中有复杂的if-else语句，将其转换成switch语句可以变得更快。然后，通过重新组织分支，把最可能的放前面，不太可能的放后面，可以进一步提升性能。

* 注意 减少代码中的语句量是很不错的目标，但不是绝对的法则。一味追求语句最少化，可能导致一条语句容纳过多逻辑，最终难以理解。

* 第一个办法是从页面中移除列表，执行更新，然后再把列表插回页面中相同的位置。这个办法并不可取，因为每次更新时页面都会闪烁。第二个办法是使用文档片段构建DOM结构，然后一次性将它添加到list元素。这个办法可以减少实时更新，也可以避免页面闪烁。

* 注意 使用innerHTML可以提升性能，但也会暴露巨大的XSS攻击面。无论何时使用它填充不受控的数据，都有可能被攻击者注入可执行代码。此时必须要当心。


### 28.3 部署

* 如果你使用Node.js和npm打印JavaScript资源，Grunt和Gulp是两个主流的任务运行器。它们非常稳健，其任务和指令都是通过配置文件，以纯JavaScript形式指定的。使用Grunt和Gulp的好处是它们分别有各自的插件生态，因此可以直接使用npm包。关于这两个工具插件的详细信息可以参考本书附录。

* 注意 在Web开发的上下文中，“压缩”（compression）经常意味着“最小化”（minification）。虽然这两个术语可以互换使用，但实际上它们的含义并不相同。
最小化是指把文件大小减少到比原始大小还要小，但结果文件包含的仍是语法正确的代码。通常，最小化只适合JavaScript等解释型语言，编译为二进制的语言自然会被编译器最小化。
压缩与最小化的区别在于前者得到的文件不再包含语法正确的代码。压缩后的文件必须通过解压缩才能恢复为代码可读的格式。压缩通常能得到比最小化更小的文件，压缩算法不用考虑保留语法结构，因此自由度更高。

* 注意 “转译”（transpilation）和“编译”（compilation）经常被人当成同一个术语混用。编译是将源代码从一种语言转换为另一种语言。转译在本质上跟编译是一样的，只是目标语言与源语言是一种语言的不同级别的抽象。因此，把ES6/ES7/ES8代码转换为ES3/ES5代码从技术角度看既是编译也是转译，只是转译更为确切一些。

* 注意 大多数Web服务器（包括开源的和商业的）具备HTTP压缩能力。关于如何正确地配置压缩，请参考相关服务器的文档


### A.5 数组打平方法

* 注意 flat()和flatMap()只能用于打平嵌套数组。嵌套的可迭代对象如Map和Set不能打平


### A.7 字符串修理方法

* ECMAScript 2019向String.prototype添加了两个新方法：trimStart()和trimEnd()。它们分别用于删除字符串开头和末尾的空格。这两个方法旨在取代之前的trimLeft()和trimRight()，因为后两个方法在从右往左书写的语言（如阿拉伯语和希伯来语）中有歧义。


### B.5 this强制转型

* JavaScript中最大的一个安全问题，也是最令人困惑的一个问题，就是在某些情况下this的值是如何确定的。使用函数的apply()或call()方法时，在非严格模式下null或undefined值会被强制转型为全局对象。在严格模式下，则始终以指定值作为函数this的值，无论指定的是什么值。


### C.1 框架

* Vue是类似Angular的全功能Web应用程序框架，但更加中立化。自2014年Vue发布以来，它的开发者社区发展迅猛，很多开发者因为其高性能和易组织，同时不过于主观而选择了Vue。



### C.2 通用库

* jQuery是为JavaScript提供函数式编程接口的开源库。该库的核心是通过CSS选择符匹配DOM元素，通过调用链，jQuery代码看起来更像描述故事情节而不是JavaScript代码。这种代码风格在设计师和原型设计者中非常流行。


### 附录D JavaScript工具

* 编写JavaScript代码与编写其他编程语言代码类似，都有专门的工具帮助提高开发效率。JavaScript开发者可以使用的工具一直在增加，这些工具可以帮助开发者更容易定位问题、优化代码和部署上线。其中有些工具是在JavaScript中使用的，而其他工具则是在浏览器之外使用的。本附录会全面介绍这些工具，并提供相关参考资源。

* 注意 有不少工具会在本附录中多次出现。今天的很多JavaScript工具是多合一的，因此适用于多个领域。


### D.1 包管理

* npm，即Node包管理器（Node Package Manager），是Node.js运行时默认的包管理器。在npm仓库中发布的第三方包可以指定为项目依赖，并通过命令行本地安装。npm仓库包含服务端和客户端JavaScript库。
npm是为在服务器上使用而设计的，服务器对依赖大小并不敏感。在安装包时，npm使用嵌套依赖树解析所有项目依赖，每个项目依赖都会安装自己的依赖。这意味着如果项目依赖三个包A、B和C，而这三个包又都依赖不同版本的D，则npm会安装包D的三个版本。

* Yarn是Facebook开发的定制包管理器，从很多方面看是npm的升级版。Yarn可以通过自己的注册表访问相同的npm包，并且安装方式与npm也相同。Yarn和npm的主要区别是提供了加速安装、包缓存、锁文件等功能，且提供了改进了包安全功能。


### D.3 模块打包器

* Webpack拥有强大的功能和可扩展能力，是今天非常流行的打包工具。Webpack可以绑定不同的模块类型，支持多种插件，且完全兼容大多数模板和转译库。


### D.4 编译/转译工具及静态类型系统

* 微软的TypeScript是JavaScript支持类型的超集，增加了稳健的静态类型检查和主要语法增强。因为它是JavaScript严格的超集，所以常规JavaScript代码也是有效的TypeScript代码。TypeScript也可以使用类型定义文件指定已有JavaScript库的类型信息。



### D.5 高性能脚本工具

* WebAssembly项目（简称Wasm）正在实现一门语言，该语言可以在多处执行（可移植）并以二进制语言形式存在，可以作为多种低级语言（如C++和Rust）的编译目标。WebAssembly代码在浏览器的一个与JavaScript完全独立的虚拟机中运行，与各种浏览器API交互的能力极为有限。它可以与JavaScript和DOM以间接、受限的方式交互，但其更大的目标是创造一门可以在Web浏览器中（以及在任何地方）运行的速度极快的语言，并提供接近原生的性能和硬件加速。WebAssembly系列规范在2019年12月5日已成为W3C的正式推荐标准，是浏览器技术中非常值得期待的领域。


### D.6 编辑器

* WebStorm是JetBrains的高性能IDE，号称终极项目开发工具包，集成了前沿的前端框架，也集成了大多数构建工具和版本控制系统。


### D.8 代码检查和格式化

* ESLint是开源的JavaScript代码检查器，由本书前几版的作者Nicholas Zakas独立开发；完全“可插拔”，以常识化规则作为默认规则，支持配置；有大型可修改和可切换的规则库，可以用来调试工具的行为。


### D.10 单元测试

* Mocha是目前非常流行的单元测试框架，为开发单元测试提供了优秀的配置能力和可扩展性。Mocha的测试非常灵活，顺序执行可以保证生成准确的报告且更容易调试。


### D.11 文档生成器

* SDoc能够为JavaScript代码生成非常高级的文档页面，包括从文档页面链接到源代码的功能。ESDoc还有一个插件库可以扩展其功能。不过，ESDoc要求代码必须使用ES6模块。



## 个人笔记部分


### 21.2 错误处理

* 错误处理在应用程序的浏览器端进展较慢，尽管其重要性一点也不低。这里有一个重要的事实：大多数上网的人没有技术背景，甚至连什么是浏览器都不十分清楚，而且有的人不知道自己使用的是什么浏览器。  （个人笔记: Hahahs ）


### 21.3 调试技术

* 在运行时碰到这个关键字时，所有主流浏览器都会打开开发者工具面板，并在指定位置显示断点。然后，可以通过单独的浏览器控制台在断点所在的特定词法作用域中执行代码。此外，还可以执行标准的代码调试器操作（单步进入、单步跳过、继续，等等）。  （个人笔记: vue项目的话，选中根元素在控制台输出$0.__vue__，就可以查看所有属性及数据。
这个方法在调试生产项目时很有效

来自读者笔记）


### 3.4 数据类型

* Number()函数基于如下规则执行转换  （个人笔记: Haha, transform not easy, aha）

