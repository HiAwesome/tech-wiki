## Java 8实战

 **Raoul-Gabriel Urma Mario Fusco Alan Mycroft**


### 第9章 默认方法

* 静态方法及接口
同时定义接口以及工具辅助类（companion class）是Java语言常用的一种模式，工具类定义了与接口实例协作的很多静态方法。比如，Collections就是处理Collection对象的辅助类。由于静态方法可以存在于接口内部，你代码中的这些辅助类就没有了存在的必要，你可以把这些静态方法转移到接口内部。为了保持后向的兼容性，这些类依然会存在于Java应用程序的接口之中。


### 第13章 函数式的思考

* 让我们先看看函数式编程的基石声明式编程吧。

* 采用这种“要做什么”风格的编程通常被称为声明式编程。你制定规则，给出了希望实现的目标，让系统来决定如何实现这个目标。它带来的好处非常明显，用这种方式编写的代码更加接近问题陈述了。

* 使用函数式编程，你可以实现更加健壮的程序，还不会有任何的副作用。

* 当谈论“函数式”时，我们想说的其实是“像数学函数那样——没有副作用”。

* 要被称为函数式，函数或者方法不应该抛出任何异常。

* 你不应该抛出异常，因为一旦抛出异常，就意味着结果被终止了；不再像我们之前讨论的黑盒模式那样，由return返回一个恰当的结果值。

* 那么，如果不使用异常，你该如何对除法这样的函数进行建模呢？答案是请使用Optional<T>类型：你应该避免让sqrt使用double sqrt(double)这样的函数签名，因为这种方式可能抛出异常；与之相反我们推荐你使用Optional<Double> sqrt(double)——这种方式下，函数要么返回一个值表示调用成功，要么返回一个对象，表明其无法进行指定的操作。

* 为了各种各样的实战需求，你最终可能会发现即便对函数式的代码，我们还是需要向某些日志文件打印输出调试信息。是的，这意味着严格意义上说，这些代码并非函数式的，但是你已经在实际中享受了函数式程序带来的大多数好处。

* 如果一个函数只要传递同样的参数值，总是返回同样的结果，那这个函数就是引用透明的。

* Java语言中，关于引用透明性还有一个比较复杂的问题。假设你对一个返回列表的方法调用了两次。这两次调用会返回内存中的两个不同列表，不过它们包含了相同的元素。如果这些列表被当作可变的对象值（因此是不相同的），那么该方法就不是引用透明的。如果你计划将这些列表作为单纯的值（不可修改），那么把这些值看成相同的是合理的，这种情况下该方法是引用透明的。

* 由于硬件（比如多核）和程序员期望（比如使用类数据库查询式的语言去操纵数据）的变化，促使Java的软件工程风格在某种程度上愈来愈向函数式的方向倾斜，本书的目的之一就是要帮助你应对这种潮流的变化。

* 不过，这也取决于你如何审视你的时间，你是愿意为定位诡异的缺陷费劲心机耗费时间呢？还是花费些许的代价创建一个对象的副本呢？

* 我们现在转入介绍更深入的递归，它是函数式编程特别推崇的一种技术，能帮你更深刻地理解“做什么”这一风格。

* 由于这个原因，纯函数式编程语言，比如Haskell直接去除了这样的带有副作用的操作！

* 这意味着坚持纯粹函数式既能享受它的纯净，又不会损失执行的效率。

* 大多数时候编程的效率要比细微的执行时间差异重要得多。


### 第14章 函数式编程的技巧

* 另一个有趣的例子是静态方法Comparator.comparing的使用，它接受一个函数作为参数同时返回另一个函数（一个比较器）

* 将所有你愿意接收的作为参数的函数可能带来的副作用以文档的方式记录下来是一个不错的设计原则，最理想的情况下你接收的函数参数应该没有任何副作用！

* 你可以定义一个“工厂”方法，它生产带一个参数的转换方法，我们希望借此来说明科里化。

* 你并没有一次性地向converter方法传递所有的参数x、f和b，相反，你只是使用了参数f和b并返回了另一个方法，这个方法会接收参数x，最终返回你期望的值x ＊ f+b。通过这种方式，你复用了现有的转换逻辑，同时又为不同的转换因子创建了不同的转换方法。

* 一个函数使用所有参数仅有部分被传递时，通常我们说这个函数是部分应用的（partially applied）。

* 我们应该注意的第一件事是，函数式方法不允许修改任何全局数据结构或者任何作为参数传入的参数。为什么呢？因为一旦对这些数据进行修改，两次相同的调用就很可能产生不同的结构——这违背了引用透明性原则，我们也就无法将方法简单地看作由参数到结果的映射。

* 函数式编程解决这一问题的方法是禁止使用带有副作用的方法。如果你需要使用表示计算结果的数据结果，那么请创建它的一个副本而不要直接修改现存的数据结构。这一最佳实践也适用于标准的面向对象程序设计。

* 因此，无论任何时候，只要你使用非函数式代码向树中添加某种形式的数据结构，请立刻创建它的一份副本，因为谁也不知道将来的某一天，某个人会突然对它进行修改，这一点非常重要（不过也经常被忽视）。

* 你可以凭借编译器，将Tree类的字段key、val、left以及right声明为final执行，“禁止对现存数据结构的修改”这一规则；不过我们也需要注意final只能应用于类的字段，无法应用于它指向的对象，如果你想要对对象进行保护，你需要将其中的字段声明为final，以此类推。

* 只在你需要处理质数的那个时刻（比如，要调用方法limit了）才对Stream进行计算。

* 延迟操作的性能会比提前操作要好——仅在程序需要时才计算值和数据结构当然比传统方式下一次性地创建所有的值（有时甚至比实际需求更多的值）要好。不过，实际情况并非如此简单。完成延迟操作的开销，比如LazyList中每个元素之间执行额外Suppliers调用的开销，有可能超过你猜测会带来的好处，除非你仅仅只访问整个数据结构的10%，甚至更少。

* 可以设定tail中的Supplier方法仅在第一次实时访问时才执行调用，从而修复这一问题——计算的结果会缓存起来——效果上对列表进行了增强。

* 我们推荐的原则是将延迟数据结构作为你编程兵器库中的强力武器。如果它们能让程序设计更简单，就尽量使用它们。如果它们会带来无法接受的性能损失，就尝试以更加传统的方式重新实现它们。

* 这二者之间主要的语法区别在于Scala是面向表达式的，而Java则更多地面向语句

* 解决这一问题的一种比较标准的解决方案是使用记忆表（memoization）

* 一旦并发和可变状态的对象揉到一起，它们引起的复杂度要远超我们的想象，而函数式编程能从根本上解决这一问题。

* 这个想法稍作变更可以对迭代概念的更丰富外延进行建模，甚至包括对在迭代之间传递可变状态的函数式模型。


### 第15章 面向对象和函数式编程的混合：Java 8和Scala的比较

* 此外，你可以将对象声明中的方法看成静态的，这也是main方法的方法签名中并未显式地声明为静态的原因。

* 不像Java那样，Scala没有原始数据类型一说了。

* 由于接受一个参数的方法可以采用中缀式表达，所以你可以用开头的方式实现这一语句。

* 请注意，即便如此，代码依旧是静态检查的！所有的变量在编译时都具有确定的类型

* 这段代码使用了中缀表达式和下划线（_），下划线是一种占位符，它按照位置匹配对应的参数。这个例子中，你可以将_.length()解读为l=>l.length()。在传递给filter和map的函数中，下划线会被绑定到待处理的line参数。

* 和Java 8中的Stream比起来，Scala版本的Stream内存的使用效率变低了，因为Scala中的Stream需要能够回溯之前的元素，这意味着之前访问过的元素都需要在内存“记录下来”（即进行缓存）。

* 在本书中学习的新概念能直接应用于其他语言！然而，不幸的是，为了保持同Java的兼容性，在Scala中依旧保持了null，不过我们极度不推荐你使用它。

* 对科里化的支持，这意味着你可以将一个接受多个参数的函数拆分成一系列接受部分参数的函数。

* 你可能会疑惑参数p到底代表的是什么类型（即(T)=> Boolean），因为在Java语言里你期望看到的是一个函数接口！这其实是一种新的语法，Java中暂时还不支持。它描述的是一个函数类型。

* 对于一门语言的新版本，引入太多的新语法会增加它的学习成本，带来额外学习负担。

* Scala还提供了另一个非常酷炫的特性，你可以使用语法糖调用apply方法，效果就像一次函数调用：

* Lambda避免了对变量值的修改，而不是对变量的访问

* 你应该尽量避免修改，这样你的代码更加易于维护和并发运行，所以请在绝对必要时才使用这一特性。

* 现在的Java语言中，为了构造科里化的形式需要你手工地切分函数（尤其是函数有非常多的参数时），这是极其枯燥的事情。Scala提供了一种特殊的语法可以自动完成这部分工作。

* 如果一个类继承了多个trait，各trait中声明的方法又使用了相同的签名或者相同的字段，这时会发生什么情况？为了解决这些问题，Scala中定义了一系列限制，这些限制和我们之前在第9章介绍默认方法时的限制极其类似。


### 第16章 结论以及Java的未来

* 请记住，这些新特性并非语言设计上的突发奇想，而是一种刻意的设计，它源于两种趋势，即我们在第1章中所说的形势的变化。

* 不过这两种诉求都不能很好地得到传统的、面向对象编程的支持，命令式的方式和通过迭代器访问修改字段都不能满足新的需要。在CPU的一个核上修改数据，在另一个核上读取该数据的值，这种方式的代价是非常高的，更不用说你还需要考虑容易出错的锁；类似地，当你的思考局限于通过迭代访问和修改现存的对象时，类流（stream-like）式编程方法看起来就非常地异类。不过，这两种新的潮流都能通过使用函数式编程非常轻松地得到支持，这也解释了为什么Java 8的重心要从我们最初理解的Java大幅地转型。

* 集合到底有什么问题，以至于我们需要另起炉灶替换掉它们，或通过一个类似却不同的概念Stream对其进行增强。

* 现在，让我们看看这些观念（介绍Stream时使用过这些术语）怎样直接影响了Completable-Future类的设计。

* ❑ 通过Stream你可以对一系列的操作进行流水线，通过map、filter或者其他类似的方法提供行为参数化，它可有效避免使用迭代器时总是出现模板代码。
❑ 类似地，CompletableFuture提供了像thenCompose、thenCombine、allOf这样的操作，对Future涉及的通用设计模式提供了函数式编程的细粒度控制，有助于避免使用命令式编程的模板代码。

* 为什么用一种表示值缺失的形式替换另一种能帮助我们更好地编写程序？

* 关于这一主题的大多数内容都会在JDK改进提议（JDK Enhancement Proposal）中进行讨论

* 但我们在做替代时却忽略了被替代特性的一些优点。一个比较典型的例子是容器的初始化

* 如果一种类型仅包含单一的标识符，类型推断能带来一系列的好处，其中比较主要的一点是，用一种类型替换另一种可以减少编辑工作量。不过，随着类型数量的增加，出现了由更加泛型的类型参数化的泛型，这时类型推断就带来了新的价值，它能帮助我们改善程序的可读性。￼

* 习惯了传统面向对象方式的设计者很可能会说如果采用访问者模式在子类型中实现这种“数据类型”式的分派，表达的效果会更好，不过从函数式编程的角度看，后者会导致相关代码散落于多个类的定义中，也不太理想。这是一种典型的设计二分法（design dichotomy）问题

* 非常不幸，答案是垃圾收集，因为一旦缺失了ArrayList中内容的运行时信息，JVM就无法判断ArrayList中的元素13到底是一个Integer的引用（可以被垃圾收集器标记为“in use”并进行跟踪），还是int类型的简单数据（几乎可以说是无法跟踪的）。

* 这被称为泛型多态的具化模式，或具化泛型。“具化”这个词意味着“将某些默认隐式的东西变为显式的”。

* 从本质上来说，Java 8的Lambda极大地拓展了我们的编程能力，但可惜的是，它的类型系统并未跟上代码灵活度提升的脚步。在很多的函数式编程语言中，你可以用(Integer, Double)=> String这样的类型实现Java 8中BiFunction<Integer, Double, String>调用得到同样的效果；类似地，可以用Integer=> String表示Function<Integer, String>，甚至可以用()=> String表示Supplier<String>。你可以将=>符号看作Function、BiFunction、Supplier，以及其他相似函数的中缀表达式版本。

* 与此相反，和所有泛型一样，Function只能使用对象类型的参数。以Function<Apple, Boolean>为例，它使用的是对象类型Boolean，而不是简单数据类型boolean。所以使用Predicate<Apple>更加高效，因为它无需将boolean装箱为Boolean。因为存在这样的问题，导致类库的设计者在Java时创建了多个类似的接口，比如LongToIntFunction和BooleanSupplier，而这又进一步增加了大家理解的负担。另一个例子和void之间的区别有关，void只能修饰不带任何值的方法，而Void对象实际包含了一个值，它有且仅有一个null值——这是一个经常在论坛上讨论的问题。对于Function的特殊情况，比如Supplier<T>，你可以用前面建议的新操作符将其改写为()=> T，这进一步佐证了由于简单数据类型（primitive type）与对象类型（object type）的差异所导致的分歧。

* 关键字final并未在真正意义上是要达到这一目标，它仅仅避免了对它所修饰字段的更新。

* final对于简单数据类型的值操作效果很好，不过对于对象引用，它通常只是一种错误的安全感。

* 这里的问题是我们想要一种“不装箱的对象”，可是无论Java还是JVM，对此都没有实质的支持。

* 此外，值类型可以减少对存储的要求，因为它们并不包含引用特征。

* 值类型极有可能提供更好的性能，无论是数据访问（用单一的索引地址指令替换多层的指针转换），还是对硬件缓存的利用率（因为数据现在采用的是连续存储）

* 结构看起来和类十分相似，但是二者之间存在重大差异，你应该了解它们之间的不同。首先，类[这里指的是C#中的类]属于引用类型，而结构（struct）属于值类型。使用结构，你可以创建对象[比如sic]，它的行为就像那些内置[简单]类型一样，享受同等的待遇。

* 本书探索了Java 8新增加的一系列新特性；它们所代表的可能是自Java创建以来最大的一次演进——唯一可以与之相提并论的大的演进也是在10年之前，即Java 5中所引入的泛型。


### A.1 注解

* Java 8在两个方面对注解机制进行了改进，分别为：
❑ 你现在可以定义重复注解
❑ 使用新版Java，你可以为任何类型添加注解

* 注解在Java企业版中尤其流行，它们经常用于配置企业应用程序

* 从Java 8开始，注解已经能应用于任何类型。这其中包括new操作符、类型转换、instanceof检查、泛型类型参数，以及implements和throws子句。


### A.2 通用目标类型推断

* emptyList方法使用了类型参数T进行参数化。你可以像下面这样为该类型参数提供一个显式的类型进行函数调用


### B.1 集合

* 一个特别有用的方法是computeIfAbsent，这个方法在第14章解释记忆表时曾经简要地提到过。它能帮助你非常方便地使用缓存模式。


### B.2 并发

* ❑ getAndUpdate——以原子方式用给定的方法更新当前值，并返回变更之前的值。
❑ updateAndGet——以原子方式用给定的方法更新当前值，并返回变更之后的值。
❑ getAndAccumulate——以原子方式用给定的方法对当前及给定的值进行更新，并返回变更之前的值。
❑ accumulateAndGet——以原子方式用给定的方法对当前及给定的值进行更新，并返回变更之后的值。

* 多线程的环境中，如果多个线程需要频繁地进行更新操作，且很少有读取的动作（比如，在统计计算的上下文中）, Java API文档中推荐大家使用新的类LongAdder、LongAccumulator、Double-Adder以及DoubleAccumulator，尽量避免使用它们对应的原子类型。这些新的类在设计之初就考虑了动态增长的需求，可以有效地减少线程间的竞争。

* 但是，如果大量键返回相同的哈希值，由于桶是由List实现的，它的查询复杂度为O(n)，这种情况下性能会恶化。在Java 8中，当桶过于臃肿时，它们会被动态地替换为排序树（sorted tree），新的数据结构具有更好的查询性能（排序树的查询复杂度为O(log(n))）。注意，这种优化只有当键是可以比较的（比如String或者Number类）时才可能发生。

* 如果经过预估当前map的大小小于设定的阈值，操作会顺序执行。使用值1开启基于通用线程池的最大并行。使用值Long.MAX_VALUE设定程序以单线程执行操作。


### B.3 Arrays

* B.3.1 使用parallelSort
parallelSort方法会以并发的方式对指定的数组进行排序，你可以使用自然顺序，也可以为数组对象定义特别的Comparator。


### B.4 Number和Math

* ❑ Boolean类现在提供了静态方法logicalAnd、logicalOr和logicalXor，可以在两个boolean之间执行and、or和xor操作。


### B.7 String

* String类也新增了一个静态方法，名叫join。你大概已经猜出它的功能了，它可以用一个分隔符将多个字符串连接起来。你可以像下面这样使用它


### 附录C 如何以并发方式在同一个流上执行多种操作

* 为了达到这一目标，你需要一个fork类型的方法，对每个复制的流应用不同的函数。更理想的情况是你能以并发的方式执行这些操作，用不同的线程执行各自的运算得到对应的结果。
不幸的是，这些特性目前还没有在Java 8的流实现中提供。不过，本附录会为你展示一种方法，利用一个通用API￼，即Spliterator，尤其是它的延迟绑定能力，结合BlockingQueues和Futures来实现这一大有裨益的特性。


### C.2 性能的考量

* 如果构成流的数据都保存在内存中，阻塞式队列所引发的开销很容易就抵消了由并发执行操作所带来的性能提升。


### D.1 匿名类

* 编译器会为每个匿名类生成一个新的.class文件。


### D.2 生成字节码

* 接着，这个值会被invokespecial指令处理，该指令会初始化对象。
❑ 栈顶现在包含了指向对象的引用


### D.3 用InvokeDynamic力挽狂澜

* 用InvokeDynamic力挽狂澜

* invokedynamic指令
字节码指令invokedynamic最初被JDK7引入，用于支持运行于JVM上的动态类型语言。执行方法调用时，invokedynamic添加了更高层的抽象，使得一部分逻辑可以依据动态语言的特征来决定调用目标。

* 最终这一操作被推迟到了运行时。换句话说，以这种方式使用invokedynamic，可以将实现Lambda表达式的这部分代码的字节码生成推迟到运行时。这种设计选择带来了一系列好结果。


### D.4 代码生成策略

* 为了实现这一目标，最简单的方案是在Lambda表达式中为每一个需要额外保存的变量预留参数

