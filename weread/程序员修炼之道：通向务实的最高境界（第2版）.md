## 程序员修炼之道：通向务实的最高境界（第2版）

 **(美）David Thomas（大卫·托马斯），Andrew Hunt（安德鲁·亨特）**


### 3 软件的熵

* 无视一个明显损坏的东西，会强化这样一种观念：看来没有什么是能修好的，也没人在乎，一切都命中注定了。所有的负面情绪会在团队成员间蔓延，变成恶性循环。


### 4 石头做的汤和煮熟的青蛙

* 这个时候，就该拿出石头了——找出你合理的请求，然后不断完善。一旦有成果产出，展示给人们看，让他们大吃一惊。现在可以用上“当然了，它还可以更好，只要我们再加点……”这句话，而且要假装你并不在意。


### 5 够好即可的软件

* 对于你创建的系统，其应用领域和要达到的质量，必须作为系统需求的一部分加以讨论。


### 6 知识组合

* 管理知识组合和管理金融投资组合非常的类似：
1.正规投资者有定期投资的习惯。
2.多样化是长线成功的关键。
3.聪明的投资者会平衡保守型和高风险高回报型投资的组合。
4.投资者用低买高卖来获得最大的回报。
5.应定期审查和重新平衡投资组合。

* 每年学习一门新语言

* 每月读一本技术书


### 7 交流！

* 不过，有人说必须给每个函数、数据结构、类型声明等都分别加上注释，我们并不赞同这种做法。这种机械的注释方式实际上会导致代码更难维护：一旦你想改点什么，就需要改变两个东西。


### 9 DRY——邪恶的重复

* 一个模块提供的所有服务都应该通过统一的约定来提供，该约定不应表露出其内部实现是基于储存还是基于运算的。


### 10 正交性

* 面向对象语言和函数式语言在正交性方面有什么差异？这些差异是语言本身固有的，还是仅仅由人们使用它们的方法引起的？


### 11 可逆性

* 但是，可以把代码的演化路线想象成装满了薛定谔猫的盒子：每一个决定都会导致不同版本的未来。你的代码可以支持多少种可能的未来？哪一种未来更有可能出现？到时候为其提供支持会有多难？
你敢打开盒子吗？


### 12 曳光弹

* 寻找重要的需求，那些定义了系统的需求。寻找你有疑问的地方，那些你认为有重大风险的地方。然后对开发进行优先级排序，首先从这些地方开始编码。

* 如果能成功地传达你正在做什么（参见第288页的话题52：取悦用户），用户会知道他们看到的是不成熟的东西。这样他们就不会因为缺少功能而失望，而在系统有了明显的进展时则会欢呼鼓舞。用户的持续购买，和项目的推进一样，都会产生贡献。这样的用户，也极有可能会告诉你每次迭代离目标又接近了多少。

* 这一区别非常重要，值得我们反复强调。原型生成的是一次性代码；曳光代码虽然简单但是完整，它是最终系统框架的组成部分。可以将原型制作看作是在发射一颗曳光弹之前进行的侦察和情报收集工作。


### 14 领域语言

* RSpec
RSpec[12]是一个Ruby的测试库。大多数其他现代语言的版本都曾受它启发。用RSpec描述的测试旨在反映出你期望从代码中得到的行为。

* 内部领域语言的缺点是会受到宿主语言的语法和语义的限制。尽管有些语言在这方面非常灵活，你仍然不得不在想要的语言和可以实现的语言之间做出妥协。

* 我们的建议相当简单：花费的努力不要比节省下来的还多。编写领域语言会给项目增加一些成本，所以你需要确信省下的花销（在可预计的长期）足以抵消它。


### 15 估算

* 在某种程度上，这些都是毫无意义的问题——因为缺少必要信息。然而，只要你愿意估算，这些问题都是可以回答的。并且，在估算的过程中，你将会加深对程序所处世界的理解。

* 建模会给估算过程引入不准确性。这不可避免，但也是有益的。你在用模型的简单性来换取精确性。在模型上加倍的努力可能只会换来精度上的微小提升。经验会告诉你何时应停止精炼。

* 在计算阶段，你可能会得到一些奇怪的答案。不要急于否定。如果计算是正确的，那么错的可能是你对问题的理解，或者模型是错的。这是有价值的信息。

* 这也是一个老笑话里所讲的，怎样吃掉大象：一次咬一口。


### 17 Shell游戏

* 图形工具的好处在于WYSIWYG ——所见即所得；弱势之处是WYSIAYG——所见即全部。


### 18 加强编辑能力

* 更进一步，深入研究一下编辑器的扩展语言。搞明白怎样用它来将一些重复工作自动化——通常也就是一两行代码的事情。


### 19 版本控制

* 进步，远非寓于改变之中，而是依赖于保持。那些不能铭记过去的人，注定要重蹈覆辙。
——乔治·桑塔亚那

* 不是说每个都必须去用。但是需要知道它的作用，这样才能做出相应的决定。
· 把版本控制也用到非项目的事务上。


### 20 调试

* 调试时要注意不要短视。不要仅仅去纠正你所看到的症状：更有可能的是，实际的错误可能与你所观察到的尚有几步之遥，并且可能涉及许多其他相关的事情。永远要去发掘问题的根本原因，而不仅仅停留在问题的表面现象。

* 首先，看一眼问题。是程序崩了吗？在我们教授有关编程的课程时，最让人诧异的是，很多开发者一看见红色的异常弹出框，就立马切去看代码。

* 如果修复这个 Bug花了很长时间，问问自己为什么。你能做些什么来让下次修复这个Bug 更容易呢？也许可以构建更好的测试钩子，或是编写一个日志文件分析器。


### 21 文本处理

* 花30分钟尝试一个疯狂的想法，比花5个小时要好得多。花一天时间对项目的重要组件进行自动化是可以接受的；但要花上一周时间就未必了。


### 22 工程日记

* [2]所有的软件从它们完成的那一天开始就变成了遗留软件。


### 第4章 务实的偏执

* 当所有人都真的在给你找麻烦的时候，偏执就是一个好主意。


### 23 契约式设计

* 一定不要把固定的、不可违背的需求，与那些仅仅可能是随着新管理层上任而改变的策略相混淆。这就是我们使用语义不变式这个术语的原因——它必须是事物意义的核心，而不受策略的影响（策略用于更动态的业务规则）。


### 24 死掉的程序不会说谎

* 防御式编程是在浪费时间，让它崩溃！

* 但是，基本原理是一样的——一旦代码发现本来不可能发生的事情已发生，程序就不再可靠。从这一时刻开始，它所做的任何事情都是可疑的，所以要尽快终止它。
一个死掉的程序，通常比一个瘫痪的程序，造成的损害要小得多。


### 25 断言式编程

* 自责中往往有种奢侈。我们自责时，总觉得别人无权再责备我们。
——奥斯卡·王尔德《道林·格雷的画像》

* 这个问题属于一种海森堡 Bug[3]——调试本身改变了被调试的系统的行为。


### 28 解耦

* 会议要求每个人都必须参加，因为没有人能确定谁会受到变化的影响

* 邪恶的全局化
全局可访问的数据是应用程序组件之间耦合的潜在来源。每一块全局数据就好像让应用程序中的每个方法都突然获得了一个额外的参数：毕竟，全局数据在每个方法中都是可用的。



### 29 在现实世界中抛球杂耍

* 观察者根据其兴趣被注册到观察对象上，这通常由传递一个待调用的函数引用来实现。随后，当事件发生时，观察对象遍历它的观察者列表，并调用每个传递给它的函数。事件作为调用参数提供给函数。

* 有许多框架可以帮助实现这种数据级的响应：在浏览器领域，React和 Vue.js是当前的热门技术（不过，由于它们基于JavaScript，这些信息在本书付梓之前就会过时）。


### 30 变换式编程

* 如果你不能将正在做的事情描述为一个流程，那表示你不知道自己正在做什么。

* 有许多方法可以做到这一点，但是所有方法都依赖于一个基础约定：永远不在变换之间传递原始值。取而代之的是，将值封装在一个数据结构（或类型）中，该结构可以告知我们所包含的值是否有效。例如，在 Haskell中，这个包装器被称为 Maybe。在 F#和 Scala中是 Option。


### 31 继承税

* 让我们推荐三种技术，它们意味着你永远不需要再使用继承：
· 接口与协议
· 委托
· mixin 与特征

* 尽量不要扛着大山去兜风。


### 第6章 并发

* 并发和并行代码曾经是很新奇的玩意，但现在已经是标配。


### 33 打破时域耦合

* 记住两者的区别：并发性是一种软件机制，而并行性则和硬件相关。


### 34 共享状态是不正确的状态

* 随机故障通常是并发问题


### 35 角色与进程

* 在角色模型中，不需要为处理并发性编写任何特定代码，因为没有共享状态。对于业务从头到尾的逻辑，也没有必要以“做这个，做那个”的方式，将其显式地写在代码里，因为角色会基于收到的消息自己处理这些事情。

* Erlang系统运行着一些世界上最可靠的代码，号称有9个9的可用性。


### 38 巧合式编程

* 赌徒们想象出彩票号码、骰子游戏或轮盘赌的模式，而实际上这些都是统计上独立的事件。在金融领域，股票和债券交易同样充满了巧合，并没有真实的、可辨别的模式。


### 39 算法速度

* 例如，假设有一个例程需要1s处理 100条记录。那么处理 1，000条需要多久？如果你写的代码是 O（1），那么答案就还是1s。如果是 O（lg n），那么你可能要等大约 3 s。对于O（n），就会线性扩展到 10 s，而 O（n lg n）则会花掉 33 s。如果你很不幸地写出一个O（n2）的例程，那就坐下来耐心等上 100 s吧。而如果使用的是一个指数算法 O（2n），例程大概需要 10263年跑完——而你可能只是想去煮一杯咖啡。到那个时候我们大概能知道宇宙是怎样终结的了。

* 还须注意不要过早地优化。在投入宝贵的时间尝试改进算法之前，确保算法确实是瓶颈，总是最为可取。


### 40 重构

* 重构，和大多数事情一样，在问题很小的时候做起来更容易，要把它当作编码日常活动。


### 41 为编码测试

* 测试是代码的第一个用户

* 我们坚信，构建软件的唯一方法是增量式的。构建端到端功能的小块，一边工作一边了解问题。应用学到的知识持续充实代码，让客户参与每一个步骤并让他们指导这个过程。

* 你编写的所有软件最终都将被测试——如果不是由你和你的团队做测试，那么就将由最终的用户去测试——所以不妨计划好进行彻底的测试。稍微提前考虑一下，就能大大降低维护成本，减少求助电话。


### 42 基于特性测试

* Дoвepяй，нo пpoвepяй.（信任，但要核实。）
——俄罗斯谚语


### 43 出门在外注意安全

* 开发人员实在太粗心了。

* 在版本控制中，我们强烈建议将项目所需的一切事项都置于版本控制之下。没错，几乎一切。


### 44 事物命名

* 另一种方法是使用项目术语表，列出对团队有特殊意义的术语。这是一个非正式的文档，可以在 wiki 上创建并维护，也可以将索引卡片挂在墙上。


### 45 需求之坑

* 但事实并非如此。需求很少停留在表面。通常情况下，它们被埋在层层的假设、误解和政治之下。更糟糕的是，需求通常根本不存在。

* 是的，它做了我想要的东西，但不是用我想要的方式

* 需求不是架构；需求无关设计，也非用户界面；需求就是需要的东西。


### 46 处理无法解决的难题

* 如果你就是不愿意让这个问题搁置一段时间，那么最好的办法就是找个人去解释一下这个问题。通常情况下，围绕它的简单谈论就可以让你分心，从而得到启迪。
让他们问你一些问题，比如：
· 为什么你在解决这个问题？
· 解决这个问题有什么收益？
· 你遇到的问题是否与边界情况有关？你能消除这些边界情况吗？
· 有没有一个更简单的相关问题，是你能解决的？
这是另一个实践橡皮鸭的例子。


### 47 携手共建

* 设计系统的架构受制于产生这些设计的组织的沟通结构。


### 48 敏捷的本质

* 敏捷不是一个名词；敏捷有关你如何做事


### 49 务实的团队

* 程序员有点像猫：聪明、意志坚强、固执己见、独立，并且经常引起网络崇拜。

* “只要有空闲时间”就去做，意味着这件事永远不会发生。

* 当编辑器或IDE 可以为你自动处理格式时，为什么还要与代码格式标准做斗争呢？当持续构建可以自动运行测试时，为什么还要进行手工测试呢？


### 50 椰子派不上用场

* 我们经常听到软件开发的领导者对员工说，“我们应该像 Netflix（或另一家领先的公司）那样运营”。你当然可以这么做。
首先，你自己先要有几十万台服务器和几千万用户……


### 51 务实的入门套件

* 文明的进步是以增加那些不需要思考就能完成的重要操作来实现的。
——阿尔弗雷德·诺思·怀特海

* 版本控制
· 回归测试
· 完全自动化

* 测试状态覆盖率，而非代码覆盖率

* 如果有某个 Bug 成了现有测试的漏网之鱼，那么就需要添加一个新测试，以保证下一次能将其捕获。


### 52 取悦用户

* 这个项目在完成一个月（或是一年，不管多久）之后，你根据什么来判断自己已经取得成功？


### 练习的参考答案

* 我宁愿要无法回答的问题，也不要不能质疑的答案。
——理查德·费曼

