# curl

## [cURL必知必会](https://book.douban.com/subject/34932804/)

丹尼尔·斯坦伯格

111个笔记

### 第1章 cURL项目

* 开源项目比较有趣的一点是，它们通常被称为“项目”，好像它们在某种程度上也会受到时间的限制或者永远无法完成一样。cURL“项目”团队实际上是由一些致力于软件开发的个人志愿者组成的，他们肩负着共同的使命：使用网络协议进行可靠的数据传输，并提供任何人都可以使用的免费代码。

### 第2章 命令行基础

* curl很少会自己决定做什么，它试图在最大程度上让你做自己想做的。你给它什么，它就会处理什么。如果你提供一个拼写错误的选项，那么它可能会做出预想不到的事情。如果你给它一个不合法的URL，那么它仍然会继续处理它。这意味着，你可以通过选项传给它一些疯狂的数据，它会在传输操作中传递这些数据。这是一种设计选择，它允许你调整curl如何进行协议通信，让你能够以最具创造性的方式与服务器交互。

### 2.1 命令行选项

* 长选项使用两个减号（或者称为破折号），后面跟上选项名，而且每两个减号后面只能跟一个选项名。
* 如果想要避免使用单引号，则可以通过文件将数据传给curl，这样就无须使用额外的引用。

### 2.3 URL

* 如果使用的是IPv6地址，则需要将其放在方括号中。
* 如果你传给curl的类型是D，那么就是表明请求的资源是一个目录。
* curl还提供了另一个选项（--next，短格式为-;），用于在一组选项和URL之间插入间隔。当命令行解析器遇到--next选项时，它会将后面的选项应用于下一组URL。因此，--next选项其实是一组选项和URL之间的分隔符。使用多少个--next选项取决于实际的需要。
* curl在内部维护着一个连接池，这可以让之前使用过的连接继续存活一段时间，因此后续发给相同主机的请求可以重用这些已经建立的连接。

### 2.4 URL通配

* 有时你会有一组大致相同的URL，它们只有一小部分不同。不同的部分可能是一组数字或一组名字。curl提供了“通配”（globbing）的方式来指定这类URL。
* 你可以在同一个URL中使用多个通配。例如，如果要下载Ben、Alice和Frank的图像，并且需要100×100和1000×1000的分辨率，那么可以使用以下方式。
* 在前面的所有通配示例中，我们使用了-O或--remote-name选项，因此curl将使用URL中的文件名来保存目标文件。但有时这样还不够。假设你正在下载多个文件，并希望将它们保存到不同的子目录中，或者以不同的名称保存文件。curl为这些情况提供了解决方案：输出文件名变量。URL中的每个通配都对应一个单独的变量，可以通过 ’#\[num\]’ 来引用，即在 ’#’ 后面跟上与通配对应的数字，从1（对应第一个通配）开始，以最后一个通配结束。
* 你可以使用curl --manual输出curl的整个手册页以及常见的用例教程。这是一份非常全面且详尽的文档，说明了每个选项的用法，总量达数千行。但浏览整个手册也是件烦琐的事，因此我们建议使用搜索功能。一些人更喜欢手册页的Web版本（https://curl.haxx.se/docs/manpage.html）。

### 2.6 配置文件

* 你可以使用-K或--config选项告诉curl从特定文件中读取更多的命令行选项。
* 当被调用时，curl会检查是否存在默认配置文件（除非使用了-q），如果存在，则使用这个配置文件。在类Unix系统上，它会查找．curlrc文件，在Windows系统上则查找_curlrc文件。

### 2.7 密码和窥探

* 避免在命令行上指定用户名和密码的一种方法是使用．netrc文件或配置文件。你也可以使用-u选项，但不指定密码，curl会在运行时提示用户输入密码。

### 2.8 进度指示器

* curl有一个内置的进度指示器。当调用curl来传输数据（上传或下载）时，它可以在终端上显示传输的进度，比如当前的传输速率、已经用掉的时间以及还需要多长时间才能完成传输。 如果curl需要在终端上输出内容，那么进度指示器就会被禁用，否则进度指示器会干扰输出内容，把要显示的内容弄得一团糟。用户还可以通过-s或--silent选项强制关闭进度指示器。

### 3.1 详细模式

* 如果curl命令没有执行或返回所期望的东西，你的第一直觉反应应该是使用-v或--verbose选项来运行命令，以便获取更多详细信息。
* HTTP请求标头的最后一行是空的，这表示标头和正文之间的分隔，而且这个请求是没有“正文”的。
* 有时只使用-v是不够的，特别是当你想要保存包括实际传输数据在内的完整消息时。
* 当curl使用HTTPS、FTPS或SFTP协议进行加密文件传输时，其他网络监视工具（如Wireshark或tcpdump）将无法帮你保存完整的消息。为此，curl在-v之外又提供了两个选项。 --trace \[filename\] 选项可以将完整的跟踪信息保存在指定的文件中，也可以使用’-'（单个减号）代替文件名，将内容打印到stdout。发送和接收的每个字节都以十六进制的数字显示出来。如果觉得十六进制的数字没有什么帮助，那么你可以尝试使用--trace-ascii \[filename\]（也可以使用’-’将内容打印到stdout）, 如果使用了这个选项，则所有的输出信息前面都会被加上高精度的时间戳。它可以与常规的-v和--verbose选项以及--trace和--trace-ascii选项一起使用
* 在使用HTTP/2进行文件传输时，curl将发送和接收被压缩的标头信息。因此，为了以可读和可理解的方式显示传出和传入的HTTP/2标头信息，curl将显示未经压缩的版本，就像它们在HTTP/1.1版本中显示的那样。
* 这个选项经常被人们忽略，但它是curl命令行选项当中的一颗小瑰宝。--write-out（或-w）会在传输任务完成后打印一些信息，并且它还提供了大量可添加到输出内容中的变量，这些变量包含了与传输相关的信息。
* 可以在字符串中加入%{variable_name}来访问可用的变量，然后这些变量会被替换成对应的值。
* 可用的--write-out变量
* 与详细模式相反的是静默模式。-s（或--silent）选项可以让curl关闭进度指示器，而且不会在发生错误时输出任何错误信息。它变得无声无息，但仍然会输出你请求下载的数据。启用静默模式后，你可以通过添加-s或--show-error来要求它在发生错误时输出错误信息。

### 3.2 持久连接

* 如果需要针对同一主机或相同的URL执行N次传输或操作，那么你可以考虑使用尽可能少的curl命令行来提速，而不是每次使用一个URL并重复调用curl。

### 3.3 下载

* 如果你在命令行中指定了多个URL，那么curl将逐个下载所有URL。在一个传输完成之前，它不会启动下一个（以及后面的）传输。
* 如果你要求curl将输出内容打印到终端上，那么它会避免将二进制数据输出到终端，因为这会严重扰乱终端（有时甚至会导致终端停止运行）。你可以覆盖curl的这种输出机制，使用-o强制让它输出到stdout。
* 这就是-O（大写字母O）选项，或者--remote-name。-O选项从你提供的URL中提取文件名部分作为本地文件名。这点非常重要。你指定URL, curl从中选择文件名。即使发生重定向（而且你告诉curl要跟踪重定向）, curl选择的文件名也不会发生变化。
* 查看storage.html文件时，用户会发现有些字符看起来很奇怪或者根本就是错误的。这很可能是因为服务器使用字符集X发送内容，而你的编辑器和所在环境使用的是字符集Y。在理想世界中，我们会在所有地方使用UTF-8，但现实并非如此。这个问题的常见解决办法是使用iconv将文本文件转换为不同的字符集。
* HTTP压缩可以通过两种机制来实现，一种被认为是“正确的方式”，另一种在实际中使用得更为广泛！压缩HTTP内容的常用方法是使用Content-Encoding标头。
* “存储指令”的读取和处理顺序与下载的URL的顺序相同，因此它们不一定要位于URL之后。你可以将所有输出选项放在最前面或最后面，或者与URL交错放置，随你喜欢！
* -O只用于单个下载，如果你要下载多个URL，则需要使用多个-O
* 为了避免在下载一百个URL时添加一百个-O选项，我们引入了--remote-name-all选项。这让-O成为所有给定URL的默认操作方式。
* curl的一个常见使用场景是像浏览器那样获取URL，但浏览器做的事情比curl要多得多，curl在终端输出的内容可能与你在浏览器窗口中看到的内容完全不一样。
* 强烈建议你使用HTTPS或其他方法来验证下载内容就是远程服务器发送给你的数据，以及你发送的字节最终会出现在目的地。
* 但有时你会发现，在本地网络中，curl缺少其他网络功能也会带来不便。此时你可能希望curl可以减慢速度，以便其他网络用户也有机会获取数据。你可以使用--limit-rate [speed]让curl的速率不超过指定的字节/秒。速率限定的值可以包含一个后缀字母，K表示千字节，M表示兆字节，G表示千兆字节。
* 指定的限定速率是指整个传输过程的最大平均速率，也就是说，curl有可能会在某些很短的时间段内使用高于指定速率的传输速率，但平均速率不会超过指定速率。 另外请注意，curl永远不会知道可能的最大速度是多少，它会在允许的范围内尽快完成传输。你可能会知道连接的最大速度，但curl不会。
* Metalink是一种文件描述标准，用于告诉客户端有多个位置保存了相同的内容。然后客户端可以选择从一个或多个位置下载内容。
* 将下载的内容保存到文件时，可以通过--xattr选项告诉curl将某些文件元数据也保存在“扩展文件属性”中。这些扩展属性是保存在文件系统中的标准化的名称和值，前提是文件系统和操作系统支持扩展属性。
* 如果使用--raw选项，curl会禁用所有内部的HTTP内容解码或传输编码，取而代之的是传输未经修改的原始数据
* 通常curl只会尝试执行一次传输，不成功则返回错误。你可以使用--retry选项让curl重试失败的传输。
* 你可以向远程服务器请求特定字节范围的内容。例如，你可能只需要从偏移量100开始的1000个字节，以避免下载整个巨大的远程文件
* multipart formpost通常用于涉及文件上传的HTML表单。这种类型的上传也属于HTTP POST，但会根据一些特殊规则发送格式化的数据，因此被称为“multipart”。
* 上传类型HTTP PUT会发送一个完整的资源，并将其保持原样放在远程站点，甚至可以替换那里已有的资源。目前，PUT是Web使用得最少的一种HTTP上传方式，而且大多数Web服务器并没有启用PUT。

### 3.5 连接

* 你会比域名解析器更了解curl应该向哪里发送请求吗？如果是，那么你可以为curl提供一个IP地址！如果你要将访问example.com 80端口的请求重定向到localhost
* --resolve将地址插入curl的DNS缓存中，以便curl相信那就是自己解析得到的地址。如果使用的是HTTPS，那么将发送URL中的SNI，并且curl会验证服务器端的响应，以确保使用的是URL中的名字。
* 它将源主机名和源端口重定向到目标主机名和目标端口。curl将解析和连接load1.example. com，但在其他方面仍然假设连接的是www.example.com
* 正如本书其他地方提到的那样，可以用不同的域名解析器库来构建curl。其中一个库是c-ares，如果用c-ares构建curl，则可以获得一些额外的超级神力，这是使用其他库无法获得的。比如，它能够更具体地指定使用哪些DNS服务器以及DNS流量如何使用网络。
* 在具有多个网络接口并连接到多个网络的计算机上，有时你可以决定使用哪个网络接口来传出网络流量，或者在通信中使用哪个原始IP地址（在你拥有的多个IP地址之外）。 --interface选项可以告诉curl你希望将通信的本地端“绑定”到哪个网络接口、哪个IP地址或主机名。
* 空闲时，TCP连接可以完全没有任何流量。因此，完全空闲的连接与因网络或服务器问题而过时的连接很难明显区分。
* 避免慢连接（或空闲连接）被视为死亡并被错误杀死的其中一种方法是确保使用了TCP的keepalive。keepalive是TCP协议的一项特性，它会来回发送“ping数据帧”，避免连接进入完全空闲的状态。它帮助空闲连接检测中断（即使在没有流量的情况下），并让中间系统不会认为连接已死亡。
* 网络操作本质上是不可靠的，甚至是脆弱的，因为它们依赖了一系列服务和网络。这些服务的可用性时有时无，性能也可能随着时间的推移发生很大变化。 TCP允许网络在很长一段时间内完全断开连接，传输的参与者不一定会注意到。 这导致的结果就是有时网络传输需要很长时间。另外，curl的大多数操作默认没有设置超时。
* curl默认启用TCP keepalive。TCP栈会在没有流量时向另一端发送探测，以确保对方仍然存在，并且还“活着”。通过使用keepalive, curl更有可能发现已死亡的TCP连接。 你可以使用--keepalive-time来指定发送探测的频率，默认为60秒。 有时这种探测机制会干扰你正在做的事情，此时可以用--no-keepalive来禁用它

### 3.8 代理

* 代理是代表客户端执行某项操作的机器或软件。你可以将它视为中间人，位于你和目标服务器之间。你连接的是这个中间人，而不是实际的远程服务器。你可以要求代理代为执行你想要执行的操作，接着它执行这些操作，然后将数据返回给你。代理有几种不同的类型，我们将在本节列出并介绍它们。
* 有些网络要求使用代理，这样你才能访问互联网或者自己感兴趣的特殊网络。出于政策或技术方面的考虑，网络管理员会在网络中引入代理。在网络领域，有一些方法可用于自动检测和连接代理，但这些方法不够通用，因此curl不支持它们。此外，通过代理与外界通信，这通常意味着你必须非常信任自己的代理，因为它将能够看到并修改流经它的所有非安全的网络流量，要建立这种信任并不容易。
* 在网络领域，有一些方法可用于自动检测和连接代理，但这些方法不够通用，因此curl不支持它们。此外，通过代理与外界通信，这通常意味着你必须非常信任自己的代理，因为它将能够看到并修改流经它的所有非安全的网络流量，要建立这种信任并不容易。
* HTTP代理是客户端用来通过HTTP完成传输的代理。默认情况下，curl假设你使用-x或--proxy选项指定的主机就是HTTP代理。另外，除非你还指定了端口号，否则它将默认使用端口3128（使用这个特定端口号纯粹是历史原因）。
* 大多数HTTP代理允许客户端“穿过”它，到达另一端的服务器。通过HTTP代理执行HTTPS传输就是一个很好的示例。你可以通过-p或--proxytunnel选项让curl穿过HTTP代理。
* 可以通过设置 \[scheme\]_proxy 变量来指定代理（与用-x指定主机名的方式相同）。因此，要想让curl访问HTTP服务器时使用代理，则需要设置http_proxy环境变量，还可以通过单个变量ALL_PROXY来设置所有的协议。如果存在某个特定的协议变量，则优先使用这个变量。使用环境变量设置代理时，很容易遇到需要将一个或几个无须使用代理的主机名排除在外的情况。这个时候需要使用NO_PROXY变量。我们使用逗号分隔这些不需要使用代理的主机名。你也可以将NO_PROXY设置为单个星号（'＊'）以匹配所有主机。

### 3.9 退出状态

* 以非零状态码退出时，curl还会输出一个错误消息（除非使用了--silent选项）。这个错误消息可能会包含一些额外的信息，因此，相同的错误码可能会与不同的错误消息一起出现。
* 前面的状态码列表包含了很多标记为“未使用”的数字。这些状态码没有用于现代版本的curl中，但过去曾经被使用过或打算使用。它们很可能会用于未来的curl版本中。另外，这个列表中最大的错误状态码是92，但这并不代表未来的curl版本不会在这个数字之后添加更多的退出码。

### 3.10 FTP

* 访问FTP通常需要用户名和密码，否则就无法访问。有些系统允许“匿名”访问，你可以使用自己喜欢的任意用户名和密码登录。在使用curl进行FTP传输但没有指定用户名或密码的情况下，它将使用用户名anonymous和密码ftp@example.com。
* curl默认请求使用“被动”连接，它向服务器发送PASV或EPSV命令，服务器为第二个连接打开一个新端口，然后curl会连接到这个端口上。连接到新端口通常更加容易，对终端用户和客户端的限制也较少，但服务器端所在的网络必须允许这些连接。默认情况下，curl启用的是被动连接，但如果之前已启用了主动连接，可以使用--ftp-pasv切换回被动连接。
* 安全的网络客户端需要确保远程主机就是它要与之通信的主机。在使用基于TLS的协议时，这是通过客户端验证服务器的证书来实现的。SSH协议不使用服务器证书，但每个服务器都需要提供唯一的密钥。而且与TLS不同的是，SSH没有证书颁发机构，因此客户端需要确保主机的密钥与它已经知道的（通过其他方式获得的）信息相匹配。密钥匹配通常需要用到密钥的散列和客户端用来保存已知服务器散列的文件，这个文件通常叫作known_hosts，存放在专门的SSH目录中。在Linux系统上，通常是～/.ssh目录。
* dig”和“nslookup”是两个比较有用的用于获取MX记录的命令行工具。

### 3.13 TLS

* 3.13.2 启用TLS, curl支持很多协议的TLS版本。HTTP有HTTPS、FTP有FTPS、LDAP有LDAPS、POP3有POP3S、IMAP有IMAPS、SMTP有SMTPS。如果服务器端也支持，则可以在curl中使用这些协议的TLS版本。启用TLS的方法有两种。一种是从第一次进行连接握手时就使用TLS，另一种是用协议特定指令将连接从明文“升级”到TLS。如果在URL中明确指定了协议的TLS版本（以“S”字符结尾）, curl将尝试从一开始就建立TLS连接，而如果指定了非TLS版本，通常可以用--ssl选项将连接升级到基于TLS的连接。可以使用--ssl选项的所有协议都支持这种方法。使用--ssl选项意味着curl会尝试将连接升级到TLS，但如果失败，它仍将继续使用明文协议来执行传输。
* curl支持很多协议的TLS版本。HTTP有HTTPS、FTP有FTPS、LDAP有LDAPS、POP3有POP3S、IMAP有IMAPS、SMTP有SMTPS。如果服务器端也支持，则可以在curl中使用这些协议的TLS版本。 启用TLS的方法有两种。一种是从第一次进行连接握手时就使用TLS，另一种是用协议特定指令将连接从明文“升级”到TLS。如果在URL中明确指定了协议的TLS版本（以“S”字符结尾）, curl将尝试从一开始就建立TLS连接，而如果指定了非TLS版本，通常可以用--ssl选项将连接升级到基于TLS的连接。
* SSL是在20世纪90年代中期发明并发展起来的。SSL 2是第一个在互联网上广泛使用的版本，但很久以前就被认为是不安全的。然后就有了SSL 3，但它也被认为不够安全。
* TLS 1.0是第一个“标准”。RFC 2246于1999年发布。TLS 1.1于2006年问世，此版进一步提高了安全性，然后是2008年的TLS 1.2。十年来，TLS 1.2一直是TLS的黄金标准。2018年8月，IETF最终确定了TLS 1.3（RFC 8446），并将其作为标准发布。这是迄今为止最安全、最快的TLS版本。但因为刚发布不久，很多软件、工具和库尚不支持它。
* 在极少数情况下，即使证书验证失败，你可能仍然希望与TLS服务器展开通信。如果是这样，则必须接受你的通信可能受到中间人攻击的事实。你可以通过-k或--insecure选项来降低安全级别。
* OCSP装订是指通过TLS扩展（证书状态请求，Certificate Status Request）要求服务器在握手过程中提供新的“证据”，即返回的证书仍然有效。这是一种确保服务器证书未被撤销的方法。 如果服务器不支持这个扩展，那么测试将会失败，curl将返回错误。服务器不支持这种扩展的情况太常见了。

### 3.15 复制为curl命令

* 人们经常会问如何用curl执行与浏览器相同的操作。
* 如何获取一个curl命令行，是否可以像浏览器那样获取资源？Firefox、Chrome和Safari都提供了这个功能。
* 这些方法都可以生成用于重现HTTP传输的命令行，但你会发现它们通常不是解决问题的最佳方法。为什么？主要是因为这些工具是为了重新运行完全相同的请求而开发的，你需要获得相同的逻辑，但发送的是不同的cookie和文件内容，等等。

### 第4章 用curl执行HTTP操作

* 每个HTTP请求都包含了一个方法，有时也被称为动词。最常用的方法是GET、POST、HEAD和PUT。 不过，通常不会在命令行中指定方法，具体使用哪个方法取决于使用的选项。默认方法是GET, -d或-F选项对应POST方法，-I对应HEAD方法，-T对应PUT方法
* 如果路径中包含/../或/./这样的字符串，curl会在将路径发送到服务器前自动压缩它们，这些字符串的含义与本地文件系统中的路径含义是一样的。/../前面的部分会被移除，因此/hello/sir/../会变成/hello/, /./会直接被移除，因此/hello/./sir/会变成/hello/sir/。为了防止curl在将这些字符串发送到服务器前压缩它们，可以使用--path-as-is选项。

### 4.2 响应

* HTTP响应消息具有一定的大小，curl需要知道它是多少。HTTP响应消息的结束可以通过几种不同的方式来表示，其中最基本的方法是在消息中使用Content-Length：标头，并在标头中指定响应正文的字节数。
* HTTP响应码的第一个数字表示“某一类错误”。
  * 1xx：临时响应，后面有更多内容。
  * 2xx：成功。
  * 3xx：重定向。
  * 4xx：客户端向服务器请求它无法或不会提供的内容。
  * 5xx：服务器问题。
* HTTP响应消息能够以压缩的格式进行传输。服务器通常会在响应中包含Content-Encoding:gzip标头，以告诉客户端内容经过了压缩。在发送静态资源（提前进行压缩）或CPU资源大于带宽的情况下，使用压缩是很有意义的。我们倾向于发送更少的数据。可以通过--compressed选项让curl请求压缩数据，并在接收gzip（或curl可以理解的任意其他压缩算法）压缩的内容后自动对其进行解压。
* 你可以要求curl直接传递接收到的数据，不对其进行解码，即直接传递分块编码或压缩的数据（如果使用了压缩传输编码）。

### 4.3 HTTP身份验证

* curl将使用默认的“Basic” HTTP身份验证方法。就像它的名字一样，这个方法确实非常基础。要想明确指定使用这个方法，则可以使用--basic选项。因为Basic身份验证方法通过网络（经过base64编码）发送明文的用户名和密码，所以应该避免在HTTP传输中使用这种方法。

### 4.4 HTTP区间

* 如果客户端只想要远程资源的前200个字节或者中间300个字节，该怎么办？HTTP允许客户端请求特定区间的数据。客户端可以向服务器请求起始偏移量和结束偏移量区间内的数据。它甚至可以在同一个请求中请求几个区间内的数据，并进行组合让这些片段并排发回。服务器发回多个独立的片段作为响应，并用mime边界字符串进行分隔，如何处理它们取决于用户的应用。curl不会进一步对这样的响应进行分隔。不过，获取数据区间也只是对服务器的一种请求。服务器不一定会满足所有这样的请求，在很多情况下，例如服务器动态生成内容时，它将拒绝执行这种区间请求，而是返回完整的内容。
* HTTPS实际上是安全的HTTP。“安全”意味着TCP传输层得到了增强，通过使用TLS来提供身份验证、隐私（加密）和数据完整性

### 4.6 HTTP POST

* 用curl的-d选项发送POST请求时，请求中默认会包含一个类似Content-Type: application/x-www-form-urlencoded这样的标头。典型的浏览器在发送POST请求时也会使用这个标头。 很多POST数据接收者不关心也不会去检查Content-Type标头。 如果默认标头对你来说还不够好，则可以用其他标头来代替。例如，如果想将JSON POST到服务器，并且准确地告诉服务器你发送的内容是什么类型，可以参见以下代码
* 用-d选项从文件读取内容时，回车符和换行符将被移除。如果想让curl从文件读取二进制内容，可以使用--data-binary
* 这个时候可以考虑使用一个能够带来些许便利的特性（即使它不适用于POST），也就是-G或--get选项，它将-d选项指定的数据附加到URL右边，并使用“? ”分隔，然后让curl用GET方法发送数据。使用这个选项可以在POST和GET之间轻松切换。
* HTTP无法在保持连接的情况下停止正在进行的传输（不管是哪个方向）。因此，如果在传输开始后发现需要停止传输，只有两种方法：关闭当前连接并为下一个请求重新建立连接，或者继续传输，这样会浪费带宽，但进行下一次传输时可以重用连接
* 当通过HTTP发送大型文件，却发现服务器需要身份验证并发回401响应码时，就会发生这种情况。 要想缓解这个问题，可以让curl传递一个额外的标头，即Expect: 100-continue，这让服务器在客户端发送大量数据前有机会拒绝请求。如果POST请求的大小是已知的或者可能比较大，那么curl就会发送这个Expect：标头。PUT请求也是如此。 当服务器收到包含100-continue的请求并允许这个请求，它将返回100响应码，客户端就可以继续发送数据。如果服务器不允许这个请求，它会返回错误响应码。 遗憾的是，很多服务器对Expect：标头的支持并不好，或者没能正确处理，因此curl只会在收到第一个响应前等待1000毫秒，然后继续发送数据。等待的那1000毫秒可能就被浪费了。你可以从请求中移除Expect:，并通过-H选项来避免等待。
* 第三种方法是使用诸如Wireshark之类的网络捕获工具来检查发送的内容。如果使用的是HTTPS，那么就无法看到明文形式的表单提交，不过你可以让Wireshark从浏览器中提取TLS私钥，这样就可以对加密的内容进行解密。更多详细信息，参见Wireshark文档。

### 4.7 HTTP multipart formpost

* 使用curl时，可以通过-F（或--form）选项添加每个单独的multipart，然后继续为表单的每个字段添加一个-F。 上面示例中的表单有两个part，一个叫作“person”，它是一个纯文本字段，另一个叫作“secret”，它是一个文件。 可以像下面这样发送这个表单数据。
* 用curl的-F选项进行POST时，请求中会包含默认的Content-Type标头，如上面的例子所示。标头的值是multipart/form-data，后面是MIME边界字符串。multipart formpost使用默认的Content-Type，当然你也可以自行修改，如果你做了修改，curl会自动将边界字符串附加到被替换的标头中。你无法修改边界字符串，因为curl需要用它来生成POST数据。

### 4.9 重定向

* 顾名思义，“重定向”是指服务器向客户端发送指令，而不是返回客户端想要的内容。服务器好像在说：“去这里找你想要的东西。” 但并非所有的重定向都是一样的。重定向是永久性的吗？客户端在下一个请求中应该使用哪种请求方法？进行重定向时需要发送一个Location：标头，其中包含新的URI，可以是绝对路径或相对路径。
* 注意，301和302响应码会让浏览器在下一个请求中使用GET，如果最开始使用的是POST，下一个请求会被改为GET。据说收到301和302响应码后将HTTP方法改为GET是因为一些“历史原因”，但浏览器一直是这样做的，因此大多数公共网站的重定向行为也是这样。
* 不过，curl并不会记住或缓存任何重定向信息，因此永久重定向和临时重定向对curl来说并没有什么区别。
* 一般来说，curl只会做一些基本的操作，除非你告诉它，否则默认情况下它不会遵循HTTP重定向。可以通过-L或--location选项让它遵循HTTP重定向。指定遵循重定向的选项后，curl默认最多会执行50次重定向。设置最大次数限制是为了避免陷入无限循环。如果50次对你来说还不够，可以通过--max-redirs选项修改最大重定向次数。
* 事实证明，世界上有一些Web服务希望客户端将POST发送到原始URL，并在返回301、302或303响应码后，仍然希望HTTP客户端在下一个请求中继续使用POST。但在默认情况下，浏览器不会这么做，curl也不会。
* 在使用curl时，你可能会为特定网站提供用户名和密码等凭证，但由于HTTP重定向可能会转移到其他主机，curl会对发送给其他主机的内容加以限制。如果你希望凭证也被发送到后面的主机，即使与原始主机不同（这么做大概是因为你信任它们并且知道没有任何害处），则可以使用--location-trusted选项。
* 现代的Web网站到处是JavaScript, JavaScript是一门语言，也是一个完整的运行时，当用户访问网站时，浏览器通过这个运行时执行JavaScript代码。JavaScript也提供了用于指示浏览器转向另一个网站的方法，如果愿意，你也可以把它叫作重定向。

### 4.10 修改HTTP请求

* 可以在-X或--request选项后面跟上方法名，让curl使用其他方法。例如，你可以按照以下方式发送DELETE，而不是GET
* curl设置的所有标头都是可以被覆盖的，如果愿意，还可以替换它们。可以通过-H或--header选项让curl使用新的标头，如果指定的标头字段与内部字段匹配，它将替换内部标头，否则它会将指定的标头添加到标头列表中。
* 当用户点击网页上的链接时，浏览器会将用户带到下一个URL，它会在新的请求中添加referer标头，表明请求的来源。虽然referer拼写错误，但它就是这个意思！可以在curl中用-e或--referer选项来设置referer标头
* HTTP支持“条件请求”。条件请求是指包含条件的请求，它请求服务器只在相关条件为true时才返回响应正文。
* curl还可以直接从本地文件中获取时间戳。如果服务器的文件没有发生变更，那么就无须再次下载，不是吗？如果字符串与时间或日期格式不匹配，curl会检查是否存在同名文件，如果存在，就使用文件的修改时间。
* PUT和POST之间的区别很微妙。除了方法名不同之外，其他几乎都是一样的。POST是指将数据传给现有的远程资源，而PUT是指创建新的资源。 在这方面，PUT类似于其他协议的文件上传。你可以用PUT上传新的资源，用URL指定远程资源，并指定要发送的本地文
* HTTP cookie是存储在客户端的键值对。在后续请求中，它们被发回服务器，用于保持请求间的状态。HTTP本身是没有状态的，客户端必须在后续请求中重新发送需要服务器知道的所有数据。 服务器用Set-Cookie：标头来设置cookie，并在每个cookie中发送一堆额外的属性，客户端在发回cookie时需要匹配这些属性。这些属性包括域名、路径，以及最重要的cookie应该保留多长时间。cookie的到期时间要么设置为未来的某个固定时刻（或者存活几秒），要么永不过期。没有过期时间的cookie称为“会话cookie”，只在“会话”期间存活。会话通常被认为是浏览器在浏览网站时的生命周期。关闭浏览器后，会话也将结束。如果用支持cookie的命令行客户端执行HTTP操作，会话会在什么时候结束？
* 不建议使用空的cookie存储。为什么不用之前获取的cookie存储或者通过其他方式获取cookie呢？curl使用的cookie文件格式叫作Netscape cookie格式，因为浏览器曾经也使用了这种格式，所以curl可以很轻松地处理浏览器cookie！
* 将cookie写入文件时，curl将保存所有已知的cookie，包括会话cookie（没有过期时间）。curl本身没有会话的概念，它不知道会话什么时候结束，因此不会刷新会话cookie，除非你告诉它要这么做。
* 为了刷新会话cookie，并向服务器发出开始新会话的信号，curl提供了一个选项，以便用户可以决定新会话何时开始。新的cookie会话意味着所有会话cookie都将被丢弃，这相当于重启浏览器。
* curl同时为HTTP:// 和HTTPS:// 类型的URL提供HTTP/2支持（前提是用相关依赖项构建curl）。如果指定了HTTPS URL，那么它会默认使用HTTP/2。如果用curl访问不支持HTTP/2的网站，则发出的请求将进行HTTP/1.1协商。
* 多路复用：HTTP/2协议的主要特性之一是能够在同一物理连接上复用多个逻辑流。在使用curl命令行工具时，你无法利用这个很酷的特性，因为curl严格按照串行的方式执行网络请求，一个接一个，后一个要在前一个结束后才能开始。希望未来的curl版本可以支持这项特性。

### 5.1 安装预构建的二进制包

* 5.2 从源代码构建：可以构建cURL项目的源代码来生成curl和libcurl这两个二进制包。从源代码到二进制包的转换过程通常称为“构建”，也就是说，你可以从源代码构建curl和libcurl。 cURL项目不提供任何已构建的二进制包，它只提供源代码。在curl下载页面上找到的或从网络其他位置安装的二进制包都是由热心的个人和组织构建和提供的。 源代码由大量包含C语言代码的文件组成。一般来说，为curl支持的所有平台和计算机架构构建二进制文件时使用的是同一组文件。curl可以在很多不同的平台上构建和运行。如果你使用的是罕见的操作系统，那么从源代码构建curl可能是最简单，也可能是唯一可行的方法。简化curl的构建是cURL项目的一个优先考虑事项，尽管并不总能如愿！
