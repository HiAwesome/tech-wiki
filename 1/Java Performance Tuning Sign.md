# Java Performance Tuning Sign

[Java性能权威指南（第2版）](https://book.douban.com/subject/35867531/)

> 附录 调优标志总结本附录涵盖了常用的调优标志，并指出了应该在何时使用它们。
>
> 这里的常用标志包括在Java的早期版本中常用、但不再被推荐的标志。
>
> Java早期版本的帮助文档和技巧可能会推荐这些标志，所以这里会提到它们（表A-1～表A-12）。

## 表A-1：优化即时编译器的标志

| 标志                               | 作用                   | 何时使用                                           | 查看更多          |
|----------------------------------|----------------------|------------------------------------------------|---------------|
| -server                          | 这个标志不再有任何作用，它被默默地忽略了 | N/A                                            | 见 4.2 节       |
| -client                          | 这个标志不再有任何作用，它被默默地忽略了 | N/A                                            | 见 4.2 节       |
| -XX:+TieredCompilation           | 使用分层编译               | 应该始终使用，除非你的内存受到严重限制军                           | 见 4.2 节、4.5 节 |
| -XX:ReservedCodeCacheSise=\<MB\> | 为即时编译器编译的代码保留空间      | 当你正在运行一个大型应用程序并看到代码缓存不足的警告时                    | 见 4.3.1 节     |
| -XX:InitialCodeCachesize=\<MB\>  | 为即时编译器编译的代码保留空间      | 当你需要为代码缓存提前分配内存时。这不常见                          | 见 4.3.1 节     |
| -XX:CompileThreshold=\<N\>       | 设置方法或循环在编译前被执行的次数    | 不再推荐使用这个标志                                     | 见 4.4.1 节     |
| -XX:PrintCompilation             | 提供即时编译器的日志           | 当你怀疑一个重要的方法没有被编译，或者好奇编译器正在做什么的时候               | 见 4.3.2 节     |
| -XX:CICompilerCount=\<N\>        | 设置即时时编译器使用的线程数       | 当启动太多编译器线程的时候。这主要会响运行了许多 JVM 的大型机器             | 见 4.4.2 节     |
| -XX:DoEscapeAnalysis             | 启用激进的编译器优化           | 在极少数情况下，这可能会触发崩溃，所以有时候建议禁用它。但不要禁用它，除非你知道它导致了问题 | 见 4.4.4 节     |
| -XX:UseAVX=\<N\>                 | 设置 Intel 处理器使用的指令集   | 在Java11的早期版本中，你应该把它设置为2；在之后的版本中，它默认为2          | 见 4.4.5 节     |
| -XX:AOTLibrary=\<path\>          | 使用指定的用于提前编译的库        | 在有限的情况下，这可能会加快程序的初始执行速度。在 Java11 中，它仅是实验性的     | 见 4.7.1 节     |

## 表A-2：选择GC算法的标志


| 标志                     | 作用                                             | 何时使用                                             | 查看更多      |
|------------------------|------------------------------------------------|--------------------------------------------------|-----------|
| -XX:+UseSerialGC       | 使用一个简单的、单线程的 GC 算法                             | 用于单核的虚拟机和容器，或小于 100MB 的堆                         | 见 5.1.2 节 |
| -XX:+UseParallelGC     | 在应用程序线程停顿时，使用多个线程回收新生代和老年代                     | 用于优化吞吐里而不是响应速度。这在 Java8 中是默认的                    | 见 5.1.2 节 |
| -XX:+UseG1GC           | 在应用程序线程停顿时，使用多个线程回收新生代，并使用后台线程以尽可能短的停顿从老年代回收垃圾 | 当你的后台线程有可用的 CPU，并且你不希望长时间的 GC 停顿时。这在 Java11 中是默认 | 见 5.1.2 节 |
| XX:+UseConcMazkSweepGC | 使用后台线程以尽可能短的停顿清除老年代的垃圾                         | 不再推荐，请使用 G1GC 来替代                                | 见 5.1.2 节 |
| -XX:+UsePazNewGC       | 在应用程序线程停顿时，CMS 使用多个线程回收新生代                     | 不再推荐，请使用 G1GC 来替代                                | 见 5.1.2 节 |
| -XX:+UseZGC            | 使用实验性的 Z 垃圾回收器（仅适用于Java12)                     | 为了让并发回收的新生代GC有更短的停顿时间                            | 见 6.5.1 节 |
| -XX:+UseShenandoahGC   | 使用实验性的Shenandoah垃圾回收器（仅适用于 Java12 的 OpenJDK)   | 为了让并发回收的新生代GC有更短的停顿时间 。                          | 见 6.5.1 节 |
| -XX:+UseEpsilonGC      | 使用实验性的Epsilon垃圾回收器（仅适用于Java12)                 | 如果你的应用程序从不需要执行GC                                 | 见 6.5.2 节 |


