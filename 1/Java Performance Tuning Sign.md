# Java Performance Tuning Sign

[Java性能权威指南（第2版）](https://book.douban.com/subject/35867531/)

> 附录 调优标志总结本附录涵盖了常用的调优标志，并指出了应该在何时使用它们。
>
> 这里的常用标志包括在Java的早期版本中常用、但不再被推荐的标志。
>
> Java早期版本的帮助文档和技巧可能会推荐这些标志，所以这里会提到它们（表A-1～表A-12）。

## 表A-1：优化即时编译器的标志

| 标志                               | 作用                   | 何时使用                                           | 查看更多          |
|----------------------------------|----------------------|------------------------------------------------|---------------|
| -server                          | 这个标志不再有任何作用，它被默默地忽略了 | N/A                                            | 见 4.2 节       |
| -client                          | 这个标志不再有任何作用，它被默默地忽略了 | N/A                                            | 见 4.2 节       |
| -XX:+TieredCompilation           | 使用分层编译               | 应该始终使用，除非你的内存受到严重限制军                           | 见 4.2 节、4.5 节 |
| -XX:ReservedCodeCacheSise=\<MB\> | 为即时编译器编译的代码保留空间      | 当你正在运行一个大型应用程序并看到代码缓存不足的警告时                    | 见 4.3.1 节     |
| -XX:InitialCodeCachesize=\<MB\>  | 为即时编译器编译的代码保留空间      | 当你需要为代码缓存提前分配内存时。这不常见                          | 见 4.3.1 节     |
| -XX:CompileThreshold=\<N\>       | 设置方法或循环在编译前被执行的次数    | 不再推荐使用这个标志                                     | 见 4.4.1 节     |
| -XX:PrintCompilation             | 提供即时编译器的日志           | 当你怀疑一个重要的方法没有被编译，或者好奇编译器正在做什么的时候               | 见 4.3.2 节     |
| -XX:CICompilerCount=\<N\>        | 设置即时时编译器使用的线程数       | 当启动太多编译器线程的时候。这主要会响运行了许多 JVM 的大型机器             | 见 4.4.2 节     |
| -XX:DoEscapeAnalysis             | 启用激进的编译器优化           | 在极少数情况下，这可能会触发崩溃，所以有时候建议禁用它。但不要禁用它，除非你知道它导致了问题 | 见 4.4.4 节     |
| -XX:UseAVX=\<N\>                 | 设置 Intel 处理器使用的指令集   | 在Java11的早期版本中，你应该把它设置为2；在之后的版本中，它默认为2          | 见 4.4.5 节     |
| -XX:AOTLibrary=\<path\>          | 使用指定的用于提前编译的库        | 在有限的情况下，这可能会加快程序的初始执行速度。在 Java11 中，它仅是实验性的     | 见 4.7.1 节     |

## 表A-2：选择GC算法的标志

| 标志                     | 作用                                             | 何时使用                                             | 查看更多      |
|------------------------|------------------------------------------------|--------------------------------------------------|-----------|
| -XX:+UseParallelGC     | 在应用程序线程停顿时，使用多个线程回收新生代和老年代                     | 用于优化吞吐量而不是响应速度。这在 Java8 中是默认的                    | 见 5.1.2 节 |
| -XX:+UseG1GC           | 在应用程序线程停顿时，使用多个线程回收新生代，并使用后台线程以尽可能短的停顿从老年代回收垃圾 | 当你的后台线程有可用的 CPU，并且你不希望长时间的 GC 停顿时。这在 Java11 中是默认 | 见 5.1.2 节 |
| XX:+UseConcMazkSweepGC | 使用后台线程以尽可能短的停顿清除老年代的垃圾                         | 不再推荐，请使用 G1GC 来替代                                | 见 5.1.2 节 |
| -XX:+UsePazNewGC       | 在应用程序线程停顿时，CMS 使用多个线程回收新生代                     | 不再推荐，请使用 G1GC 来替代                                | 见 5.1.2 节 |
| -XX:+UseZGC            | 使用实验性的 Z 垃圾回收器（仅适用于Java12)                     | 为了让并发回收的新生代GC有更短的停顿时间                            | 见 6.5.1 节 |
| -XX:+UseShenandoahGC   | 使用实验性的Shenandoah垃圾回收器（仅适用于 Java12 的 OpenJDK)   | 为了让并发回收的新生代GC有更短的停顿时间 。                          | 见 6.5.1 节 |
| -XX:+UseEpsilonGC      | 使用实验性的Epsilon垃圾回收器（仅适用于Java12)                 | 如果你的应用程序从不需要执行GC                                 | 见 6.5.2 节 |

## 表A-3：所有GC算法的通用标志

| 标志                             | 作用                                                | 何时使用                                                                                                         | 查看更多      |
|--------------------------------|---------------------------------------------------|--------------------------------------------------------------------------------------------------------------|-----------|
| -Xms                           | 设置堆的初始大小                                          | 当堆的默认初始大小对你的应用程序来说太小时                                                                                        | 见 5.2.1 节 |
| -Xmx                           | 设置堆的最大大小                                          | 当堆的默认最大大小对你的应用程序来说太小（或太大）时 。                                                                                 | 见 5.2.2 节 |
| -XX:NewRatio                   | 设置新生代和老年代的比例                                      | 增加它的值可以减少分给新生代的堆的比例；降低它的值可以增加分配给新生代的堆的比例。这只是初始设置，如果不关闭自适应见大小，这个比例会发生变化。随着新生代的减小，你会看到更多的新生代GC和更少的FullGC(反之亦然) | 见 5.2.2 节 |
| -XX:NewSize                    | 设置新生代的初始大小                                        | 当你对应用程序需求进行了微调时                                                                                              | 见 5.2.2 节 |
| -XX:MaxNewSize                 | 设置新生代的最大大小                                        | 当你对应用程序需求进行了微调时                                                                                              | 见 5.2.2 节 |
| -XX:MetaspaceSize=N            | 设置元空间的初始大小                                        | 对于使用大量类的应用程序,在默认值的基础上增加这个值                                                                                   | 见 5.2.3 节 |
| -XX:MaxMetaspaceSize=N         | 设置元空间的最大大小                                        | 减小这个数值以限制类元数据使用的原生内存空间                                                                                       | 见 5.2.3 节 |
| -XX:ParallelGCThreads=M        | 设置垃圾回收器用于前台活动（例如,新生代的回收和Throughput GC中老年代的回收)的线程数 | 在运行很多JVM的系统上,或在Java 8u192之前的版本上运行的 Docker容器中,降低这个值。对于在非常大的系统上有非常大的堆的VM,可以考虑增加它的值                             | 见 5.2.4 节 |
| -XX:+UseAdaptiveSizePolicy     | 设置了这个值之后, JVM 将调整各种堆的大小, 以满足GC目标                  | 如果堆的大小已经细致地优化了,可以关闭这个标志                                                                                      | 见 5.2.2 节 |
| -XX:+PrintAdaptiveSizePolicy   | 在GC日志中添加关于分代大小调整的信息                               | 使用这个标志可以了解JVM的运行情况。当使用G1时，在输出中检查巨型时象的分配是否发了FullGC                                                            | 见 5.2.2 节 |
| -XX:+PrintTenuringDistribution | 在GC日志中添加对象年龄分布的信息                                 | 根据对象年龄分布信息来判断是否应该以及如何调整与晋升相关的选项                                                                              | 见 6.4.1 节 |
| -XX:InitialSurviverRatio=M     | 设置新生代中预留给 Survivor 空间的大小                          | 如果对象频繁地晋升到老年代，就减划小该值（以增加Survivor空间的大小)                                                                       | 见 6.4.1 节 |
| -XX:MingurvivorRatio=M         | 设置新生代中预留给 Survivor 空间的自适应量                        | 增大该值会减小Survivor空间的最大大小（反之亦然）                                                                                 | 见 6.4.1 节 |
| -XX:TargetSurvivorRatio=M      | JVM试图在 Survivor 空间中保留的空闲空间                        | 增大该值会减小Survivor空间的大小（反之亦然）                                                                                   | 见 6.4.1 节 |
| -XX:InitialTenuringThreshold=M | JVM图将对象保留在 Survivor 空间的初始 GC 周期数                  | 增大该值以延长对象保留在Survivor空间的时间。注意，JVM也会调整这个值                                                                      | 见 6.4.1 节 |
| -XX:MaxTenuringThreshold=N     | JVM试图将对象保留在 Survivor 空间的最大 GC 周期数                 | 增加这个值以延长对象保留在Survivor空间的时间，JVM会在这个值和初始阈值之间调整实际的阈值                                                            | 见 6.4.1 节 |
| -XX:+DisableExplicitGC         | 防止对 System.gc() 调用产生任何响                           | 用来防止糟糕的应用程序显式地执行GC                                                                                           | 见 5.1.2 节 |
| -XX:-AggressiveHeap            | 启用一组调优标志，这些标志是为了“优化“运行在具有大量内存的机器上的、具有大堆的单一 JVM    | 最好不要使用这个标志，而是按需使用特定的标志                                                                                       | 见 6.4.3 节 |

## 表A-4：控制GC日志的标志

| 标志                        | 作用                                  | 何时使用                                                                                    | 查看更多      |
|---------------------------|-------------------------------------|-----------------------------------------------------------------------------------------|-----------|
| -Xlog:gc*                 | 控制Java11中的GC日志                      | 即使在生产环境中，也应该始终开启GC日志。和接下来Java8的相关标志不同，这个标志可以控制 Java11GC日志的所有选项。查看正文以了解这些选项和Java8标志的映射关系 | 见 5.3 节   |
| -verbose:gc               | 在Java8中开启基本的GC日志                    | GC日志应该始终开启，但是开启其他更详细的日志通常会更好                                                            | 见 5.3 节   |
| -Xlogge:\<path\>          | 在Java8中，将GC日志定向到一个特定的文件，而不是标谁输出     | 应该始终使用，这能更好地保留日志中的信息                                                                    | 见 5.3 节   |
| -XX:+PrintGC              | 在Java8中开启基本的GC日志                    | GC日志应该始终开启，但是开启其他更详细的日志通常会更好                                                            | 见 5.3 节   |
| -XX:+PrintGCDetails       | 在Java8中开启详细的GC日志                    | 应该始终开启，即使在生产环境中(日志的开销是极小的)                                                              | 见 5.3 节   |
| -XX:+PrintGCTimeStamps    | 在Java8的GC日志中输出每个条目的相对时间戳            | 应该始终开启，除非开启了日期戳                                                                         | 见 5.3 节   |
| -XX:+PrintGCDateStamps    | 在Java8的GC日志中输出每个条目的日期戳              | 它比时间戳的开销稍微大一些，但更容易处理                                                                    | 见 5.3 节   |
| -XX:+PrintReferenceGC     | 在Java8中输出GC过程中软引用和弱引用的处理信息          | 如果程序使用了大量这样的引用，添加这个标志以判断它们对GC开销的影响                                                      | 见 7.3.2 节 |
| -XX:+UseGCLogFileRotation | 在Java8中开启GC日志滚动以节省文件空间              | 在一次运行数周的生产系统中，预计GC日志会消耗大量空时间                                                            | 见 5.3 节   |
| -XX:NumberOfGCLogFiles=N  | 当在Java8中开启日志文件滚动时，该标志表示保留的日志文件数     | 在一次运行数周的生产系统中，预计GC日志会消耗大量空时间                                                            | 见 5.3 节   |
| -XX:GCLogFileSize=N       | 当在Java8中开启日志文件滚动时，该标志表示在滚动之前每个文件的大小 | 在一次运行数周的生产系统中，预计GC日志会消耗大量空间时间                                                           | 见 5.3 节   |

## 表A-5：Throughput回收器的标志

| 标志                   | 作用                                             | 何时使用                                              | 查看更多    |
|----------------------|------------------------------------------------|---------------------------------------------------|---------|
| -XX:MaxGCPauseMillis | 告诉Throughput回收器停顿时间应该是多长；堆的大小会动态调整以满足该目标       | 如果计算出来的默认大小无法满足应用程序的目标，这可以作为优化 Throughput 回收器的第一步 | 见 6.1 节 |
| -XX:GCTimeRatio=N    | 告诉 Throughput 回收器你愿意在GC中花费多少时间；堆的大小会动态调整以满足该目标 | 如果计算出来的默认大小无法满足应用程序的目标，这可以作为优化 Throughput 回收器的第一步 | 见 6.1 节 |

## 表A-6：G1回收器的标志

| 标志                                   | 作用                                       | 何时使用                                               | 查看更多       |
|--------------------------------------|------------------------------------------|----------------------------------------------------|------------|
| -XX:MaxGCPauseMillis=N               | 告诉G1回收器停顿时间应该是多长；G1算法会进行调整以满足该目标         | 可以作为G1回收器优化的第一步；增加这个值以防止FullGC                     | 见 6.2 节    |
| -XX:ConeGCThreads=N                  | 设置用于G1后台扫描的线程数                           | 当有大里CPU可用且G1遇到拼发模式失败时                              | 见 6.2 节    |
| -XX:InitiatingHeapOccupancyPercent=N | 设置G1何时开始后台扫描                             | 如果G1遇到并发模式失败，可以减小这个值                               | 见 6.2 节    |
| -XX:GlMixedGCCountTarget=N           | 设置Mixed GC的次数，超过之后G1会尝试释放之前被标记为大部分是垃圾的区域 | 如果G1遇到并发模式失败，可以减小这个值；如果 Mixed GC 周期花费了太长时间，可以增大这个值 | 见 6.2 节    |
| -XX:GlHeapRegionSize=N               | 设置G1区域的大小                                | 对于非常大的堆，或者当应用程序分非常大的对象时，可以增大这个值                    | 见 6.4.2 节  |
| -XX:+UseStringDeduplication          | 让G1去除重复的字符串                              | 当程序有大里重复字符串且字符串保留不切实际的时候                           | 见 12.1.2 节 |

## 表A-7：CMS回收器的标志

| 标志                                   | 作用                                                     | 何时使用                                 | 查看更多    |
|--------------------------------------|--------------------------------------------------------|--------------------------------------|---------|
| -XX:CMSInitiatingOccupancyFraction=N | 决定CMS何时应该开始老年代的后台扫描                                    | 当CMS遇到并发模式失败时，减小这个值                  | 见 6.3 节 |
| -XX:+UseCMSInitiatingOccupancyOnly   | 让CMS只使用 CMS InitiatingOccupancyFraction 来决定何时开始CMS后台扫描 | 和CMS InitiatingOccupancyFraction一起使用 | 见 6.3 节 |
| -XX:ConeGCThreads=N                  | 设置CMS后台扫描使用的线程数                                        | 当有大里CPU可用且CMS遇到并发模式失败时               | 见 6.3 节 |
| -XX:+CMSInexementalMode              | 以增里模式运行CMS                                             | 不再被支持                                | N/A     |

## 表A-8：内存管理的标志

| 标志                              | 作用                                           | 何时使用                                                          | 查看更多       |
|---------------------------------|----------------------------------------------|---------------------------------------------------------------|------------|
| -XX:+HeapDumpOnOutOfMemozyError | 当 JVM 抛出内存溢出错误的时候生成堆转                        | 如果应用程序抛出的内存溢出错误是由堆空间或永久代造成，请开启这个标志，这样就可以分析堆以定位内存泄漏问题          | 见 7.1.3 节  |
| -XX:HeapDumpPath=\<path\>       | 指定自动堆转储的文件名                                  | 指定 java_pid.hprof 以外的路径，以保存因内存溢出错误或GC事件而生成的堆转储（当这些选项已开启)      | 见 7.1.3 节  |
| -XX:GCTimeLimit=\<N\>           | 指定 JVM 可以在GC执行上耗费的时间，以防抛出内存溢出错误              | 当应用程序执行过多GC周期朋时，降低这个值可以让 JVM 更早地抛出内存溢出错误                      | 见 7.1.3 节  |
| -XX:HeapFreeLimit=\<N\>         | 指定 JVM 必须释放的内存量，以防抛出内存溢出错误                   | 当应用程序执行过多GC周期朋时，降低这个值可以让 JVM 更早地抛出内存溢出错误                      | 见 7.1.3 节  |
| -XX:SoftRefLRUPolicyMSPerMB=N   | 控制软引用使用后可以存留的时间                              | 减小这个值以更快地请理软引用，特别是在内存不足的情况下                                   | 见 7.3.2 节  |
| -XX:MaxDirectMemozySize=N       | 控制 ByteBuffer 类的 allocateDirect() 方法分配的原生内存量 | 如果你想限制一个应用程序可以分配的直接内存里，可以考虑设置这个值。如果要分配的直接内存大于64MB，就没有必要设置这个值了 | 见 8.1.4 节  |
| -XX:+UseLargePages              | 如果适用的话，指示 JVM 从操作系统的大页系统中分配页面                | 如果操作系统支持，这个选项一般会提升性能                                          | 见 8.2 节    |
| -XX:+StringTableSize=N          | 设置 JVM 用来保存保留字符串的哈希表的大小                      | 如果应用程序执行了大里的字符串保留操作，可以增大这个值                                   | 见 12.1.2 节 |
| -XX:+UseCompressedOops          | 为对象引用模拟35位的指针                                | 对于小于 32GB 的堆，这是默认启用的；禁用它并不会带来什么好处                             | 见 7.3.3 节  |
| -XX:+PzintTLAB                  | 在GC日志中输出关于TLAB的概要信息                          | 当使用不支持 JFR 的 JVM 时，可以用这个标志来确保 TLAB 的分配是有效的                    | 见 6.4.2 节  |
| -XX:TLABSize=N                  | 设置TLAB的大小                                    | 当应用程序在 TLAB 之外执行了大里的分配操作时，可以使用这个标志增加 TLAB 的大小                 | 见 6.4.2 节  |
| -XX:-ResizeTLAB                 | 禁止调整TLAB的大小                                  | 当设定了 TLABSize 时，请禁用这个标志                                       | 见 6.4.2 节  |

## 表A-9：原生内存跟踪的标志

| 标志                          | 作用                | 何时使用                  | 查看更多      |
|-----------------------------|-------------------|-----------------------|-----------|
| -XX:+NativeMemoryTracking=X | 开启原生内存跟踪          | 当需要查看 JVM 在堆外使用了哪些内存时 | 见 8.1.3 节 |
| -XX:PrintNMTStatistics      | 在程序终止时输出原生内存跟踪的数据 | 当需要查看 JVM 在堆外使用了哪些内存时 | 见 8.1.3 节 |

## 表A-10：线程处理的标志

| 标志                 | 作用            | 何时使用                        | 查看更多      |
|--------------------|---------------|-----------------------------|-----------|
| -Xss\<N\>          | 设置线程的原生栈大小    | 减小这个值可以为 JVM 的其他部分留出更多的可用内存 | 见 9.5.1 节 |
| -XX:-BiasedLocking | 禁用 JVM 的偏向锁算法 | 它能提高基于线程池的应用程序的性能           | 见 9.5.2 节 |

## 表A-11：JVM的杂项标志

| 标志                         | 作用                               | 何时使用                                      | 查看更多       |
|----------------------------|----------------------------------|-------------------------------------------|------------|
| -XX:+CompactStrings        | 在可能的情况下，使用 8 位的字符串表示（仅适用于Java11） | 该标志是默认启用的；应当始终使用                          | 见 12.1.1 节 |
| -XX:-StackTraceInThrowable | 当抛出异常时，阻止栈轨迹的回收                  | 当系统上的栈很深且频繁抛出异常的时候（在不可能通过修复代码来减少异常抛出的情况下） | 见 12.6 节   |
| -Xshare                    | 控制类数据共享                          | 使用这个标志为程序代码生成新的 CDS 存档                    | 见 12.3 节   |

## 表A-12：Java飞行记录器的标志

| 标志                            | 作用                         | 何时使用                                                               | 查看更多    |
|-------------------------------|----------------------------|--------------------------------------------------------------------|---------|
| -XX:+FlightRecorder           | 开启 Java 飞行记录器              | 始终建议开启飞行记录器，因为它的开销很小，除非有实际的记录正在发生（在这种情况下，开销会根据所使用的特性而发生变化，但仍然相对较小） | 见 3.4 节 |
| -XX:FlightRecorderOptions     | 通过命令行设置默认记录的选项（仅适用于 Java8） | 控制 JVM 的默认记录                                                       | 见 3.4 节 |
| -XX:StartFlightRecording      | 使用给定的飞行记录器选项启动 JVM         | 控制 JVM 的默认记录                                                       | 见 3.4 节 |
| -XX:+UnlockCommercialFeatures | 让 JVM 使用商业（非开源）特性          | 如果有相应的许可证，设置这个标志可以在 Java8 中开启 Java 飞行记录器                           | 见 3.4 节 |

