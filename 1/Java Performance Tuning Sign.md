# Java Performance Tuning Sign

[Java性能权威指南（第2版）](https://book.douban.com/subject/35867531/)

> 附录 调优标志总结本附录涵盖了常用的调优标志，并指出了应该在何时使用它们。
>
> 这里的常用标志包括在Java的早期版本中常用、但不再被推荐的标志。
>
> Java早期版本的帮助文档和技巧可能会推荐这些标志，所以这里会提到它们（表A-1～表A-12）。

## 表A-1：优化即时编译器的标志

| 标志                               | 作用                   | 何时使用                                           | 查看更多          |
|----------------------------------|----------------------|------------------------------------------------|---------------|
| -server                          | 这个标志不再有任何作用，它被默默地忽略了 | N/A                                            | 见 4.2 节       |
| -client                          | 这个标志不再有任何作用，它被默默地忽略了 | N/A                                            | 见 4.2 节       |
| -XX:+TieredCompilation           | 使用分层编译               | 应该始终使用，除非你的内存受到严重限制军                           | 见 4.2 节、4.5 节 |
| -XX:ReservedCodeCacheSise=\<MB\> | 为即时编译器编译的代码保留空间      | 当你正在运行一个大型应用程序并看到代码缓存不足的警告时                    | 见 4.3.1 节     |
| -XX:InitialCodeCachesize=\<MB\>  | 为即时编译器编译的代码保留空间      | 当你需要为代码缓存提前分配内存时。这不常见                          | 见 4.3.1 节     |
| -XX:CompileThreshold=\<N\>       | 设置方法或循环在编译前被执行的次数    | 不再推荐使用这个标志                                     | 见 4.4.1 节     |
| -XX:PrintCompilation             | 提供即时编译器的日志           | 当你怀疑一个重要的方法没有被编译，或者好奇编译器正在做什么的时候               | 见 4.3.2 节     |
| -XX:CICompilerCount=\<N\>        | 设置即时时编译器使用的线程数       | 当启动太多编译器线程的时候。这主要会响运行了许多 JVM 的大型机器             | 见 4.4.2 节     |
| -XX:DoEscapeAnalysis             | 启用激进的编译器优化           | 在极少数情况下，这可能会触发崩溃，所以有时候建议禁用它。但不要禁用它，除非你知道它导致了问题 | 见 4.4.4 节     |
| -XX:UseAVX=\<N\>                 | 设置 Intel 处理器使用的指令集   | 在Java11的早期版本中，你应该把它设置为2；在之后的版本中，它默认为2          | 见 4.4.5 节     |
| -XX:AOTLibrary=\<path\>          | 使用指定的用于提前编译的库        | 在有限的情况下，这可能会加快程序的初始执行速度。在 Java11 中，它仅是实验性的     | 见 4.7.1 节     |

## 表A-2：选择GC算法的标志

| 标志                     | 作用                                             | 何时使用                                             | 查看更多      |
|------------------------|------------------------------------------------|--------------------------------------------------|-----------|
| -XX:+UseParallelGC     | 在应用程序线程停顿时，使用多个线程回收新生代和老年代                     | 用于优化吞吐里而不是响应速度。这在 Java8 中是默认的                    | 见 5.1.2 节 |
| -XX:+UseG1GC           | 在应用程序线程停顿时，使用多个线程回收新生代，并使用后台线程以尽可能短的停顿从老年代回收垃圾 | 当你的后台线程有可用的 CPU，并且你不希望长时间的 GC 停顿时。这在 Java11 中是默认 | 见 5.1.2 节 |
| XX:+UseConcMazkSweepGC | 使用后台线程以尽可能短的停顿清除老年代的垃圾                         | 不再推荐，请使用 G1GC 来替代                                | 见 5.1.2 节 |
| -XX:+UsePazNewGC       | 在应用程序线程停顿时，CMS 使用多个线程回收新生代                     | 不再推荐，请使用 G1GC 来替代                                | 见 5.1.2 节 |
| -XX:+UseZGC            | 使用实验性的 Z 垃圾回收器（仅适用于Java12)                     | 为了让并发回收的新生代GC有更短的停顿时间                            | 见 6.5.1 节 |
| -XX:+UseShenandoahGC   | 使用实验性的Shenandoah垃圾回收器（仅适用于 Java12 的 OpenJDK)   | 为了让并发回收的新生代GC有更短的停顿时间 。                          | 见 6.5.1 节 |
| -XX:+UseEpsilonGC      | 使用实验性的Epsilon垃圾回收器（仅适用于Java12)                 | 如果你的应用程序从不需要执行GC                                 | 见 6.5.2 节 |

## 表A-3：所有GC算法的通用标志

| 标志                             | 作用                                                | 何时使用                                                                                                         | 查看更多      |
|--------------------------------|---------------------------------------------------|--------------------------------------------------------------------------------------------------------------|-----------|
| -Xms                           | 设置堆的初始大小                                          | 当堆的默认初始大小对你的应用程序来说太小时                                                                                        | 见 5.2.1 节 |
| -Xmx                           | 设置堆的最大大小                                          | 当堆的默认最大大小对你的应用程序来说太小（或太大）时 。                                                                                 | 见 5.2.2 节 |
| -XX:NewRatio                   | 设置新生代和老年代的比例                                      | 增加它的值可以减少分给新生代的堆的比例；降低它的值可以增加分配给新生代的堆的比例。这只是初始设置，如果不关闭自适应见大小，这个比例会发生变化。随着新生代的减小，你会看到更多的新生代GC和更少的FullGC(反之亦然) | 见 5.2.2 节 |
| -XX:NewSize                    | 设置新生代的初始大小                                        | 当你对应用程序需求进行了微调时                                                                                              | 见 5.2.2 节 |
| -XX:MaxNewSize                 | 设置新生代的最大大小                                        | 当你对应用程序需求进行了微调时                                                                                              | 见 5.2.2 节 |
| -XX:MetaspaceSize=N            | 设置元空间的初始大小                                        | 对于使用大里类的应用程序,在默认值的基础上增加这个值                                                                                   | 见 5.2.3 节 |
| -XX:MaxMetaspaceSize=N         | 设置元空间的最大大小                                        | 减小这个数值以限制类元数据使用的原生内存空间                                                                                       | 见 5.2.3 节 |
| -XX:ParallelGCThreads=M        | 设置垃圾回收器用于前台活动（例如,新生代的回收和Throughput GC中老年代的回收)的线程数 | 在运行很多JVM的系统上,或在Java 8u192之前的版本上运行的 Docker容器中,降低这个值。对于在非常大的系统上有非常大的堆的VM,可以考虑增加它的值                             | 见 5.2.4 节 |
| -XX:+UseAdaptiveSizePolicy     | 设置了这个值之后, JVM 将调整各种堆的大小, 以满足GC目标                  | 如果堆的大小已经细致地优化了,可以关闭这个标志                                                                                      | 见 5.2.2 节 |
| -XX:+PrintAdaptiveSizePolicy   | 在GC日志中添加关于分代大小调整的信息                               | 使用这个标志可以了解JVM的运行情况。当使用G1时，在输出中检查巨型时象的分配是否发了FullGC                                                            | 见 5.2.2 节 |
| -XX:+PrintTenuringDistribution | 在GC日志中添加对象年龄分布的信息                                 | 根据对象年龄分布信息来判断是否应该以及如何调整与晋升相关的选项                                                                              | 见 6.4.1 节 |
| -XX:InitialSurviverRatio=M     | 设置新生代中预留给 Survivor 空间的大小                          | 如果对象频繁地晋升到老年代，就减划小该值（以增加Survivor空间的大小)                                                                       | 见 6.4.1 节 |
| -XX:MingurvivorRatio=M         | 设置新生代中预留给 Survivor 空间的自适应里                        | 增大该值会减小Survivor空间的最大大小（反之亦然）                                                                                 | 见 6.4.1 节 |
| -XX:TargetSurvivorRatio=M      | JVM试图在 Survivor 空间中保留的空闲空间                        | 增大该值会减小Survivor空间的大小（反之亦然）                                                                                   | 见 6.4.1 节 |
| -XX:InitialTenuringThreshold=M | JVM图将对象保留在 Survivor 空间的初始 GC 周期数                  | 增大该值以延长对象保留在Survivor空间的时间。注意，JVM也会调整这个值                                                                      | 见 6.4.1 节 |
| -XX:MaxTenuringThreshold=N     | JVM试图将对象保留在 Survivor 空间的最大 GC 周期数                 | 增加这个值以延长对象保留在Survivor空间的时间，JVM会在这个值和初始阈值之间调整实际的阈值                                                            | 见 6.4.1 节 |
| -XX:+DisableExplicitGC         | 防止对 System.gc() 调用产生任何响                           | 用来防止糟糕的应用程序显式地执行GC                                                                                           | 见 5.1.2 节 |
| -XX:-AggressiveHeap            | 启用一组调优标志，这些标志是为了“优化“运行在具有大里内存的机器上的、具有大堆的单一 JVM    | 最好不要使用这个标志，而是按需使用特定的标志                                                                                       | 见 6.4.3 节 |

