# [现代 JavaScript 教程](https://zh.javascript.info/)

## 散装笔记

* 兼容性表: JavaScript 是一门还在发展中的语言，定期会添加一些新的功能。要查看它们在基于浏览器的引擎及其他引擎中的支持情况，请看：
  * <http://caniuse.com> —— 每个功能的支持表，例如，查看哪个引擎支持现代加密（cryptography）函数：<http://caniuse.com/#feat=cryptography>。
  * <https://kangax.github.io/compat-table> —— 一份列有语言功能以及引擎是否支持这些功能的表格。
* 多行输入：通常，当我们向控制台输入一行代码后，按 Enter，这行代码就会立即执行。如果想要插入多行代码，请按 Shift+Enter 来进行换行。这样就可以输入长片段的 JavaScript 代码了。
* 即使语句被换行符分隔了，我们依然建议在它们之间加分号。这个规则被社区广泛采用。我们再次强调一下 —— 大部分时候可以省略分号，但是最好不要省略分号，尤其对新手来说。
* "use strict": 这个指令看上去像一个字符串 "use strict" 或者 'use strict'。当它处于脚本文件的顶部时，则整个脚本文件都将以“现代”模式进行工作。
* 当你使用 开发者控制台 运行代码时，请注意它默认是不启动 use strict 的。 有时，当 use strict 会对代码产生一些影响时，你会得到错误的结果。 那么，怎么在控制台中启用 use strict 呢？ 首先，你可以尝试搭配使用 Shift+Enter 按键去输入多行代码，然后将 use strict 放在代码最顶部，就像这样:
  ```text
  'use strict'; <Shift+Enter 换行>
  //  ...你的代码
  <按下 Enter 以运行>
  ```
* 我们应该使用 “use strict” 吗？因此，目前我们欢迎将 "use strict"; 写在脚本的顶部。稍后，当你的代码全都写在了 class 和 module 中时，你则可以将 "use strict"; 这行代码省略掉。
* 函数式语言: 有趣的是，也存在禁止更改变量值的 函数式 编程语言。比如 Scala 或 Erlang。 在这种类型的语言中，一旦值保存在盒子中，就永远存在。如果你试图保存其他值，它会强制创建一个新盒子（声明一个新变量），无法重用之前的变量。虽然第一次看上去有点奇怪，但是这些语言有很大的发展潜力。不仅如此，在某些领域，比如并行计算，这个限制有一定的好处。研究这样的一门语言（即使不打算很快就用上它）有助于开阔视野。
* **重用还是新建？最后一点，有一些懒惰的程序员，倾向于重用现有的变量，而不是声明一个新的变量。 结果是，这个变量就像是被扔进不同东西盒子，但没有改变它的贴纸。现在里面是什么？谁知道呢。我们需要靠近一点，仔细检查才能知道。 这样的程序员节省了一点变量声明的时间，但却在调试代码的时候损失数十倍时间。 额外声明一个变量绝对是利大于弊的。 现代的 JavaScript 压缩器和浏览器都能够很好地对代码进行优化，所以不会产生性能问题。为不同的值使用不同的变量可以帮助引擎对代码进行优化。**
* 数学运算是安全的: 在 JavaScript 中做数学运算是安全的。我们可以做任何事：除以 0，将非数字字符串视为数字，等等。脚本永远不会因为一个致命的错误（“死亡”）而停止。最坏的情况下，我们会得到 NaN 的结果。
* BigInt 兼容性问题：目前 Firefox/Chrome/Edge/Safari 已经支持 BigInt 了，但 IE 还没有。你可以查看 [MDN BigInt 兼容性表](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt#Browser_compatibility) 以了解哪些版本的浏览器已经支持 BigInt 了。
* 反引号是 功能扩展 引号。它们允许我们通过将变量和表达式包装在 ${…} 中，来将它们嵌入到字符串中。${…} 内的表达式会被计算，计算结果会成为字符串的一部分。可以在 ${…} 内放置任何东西：诸如名为 name 的变量，或者诸如 1 + 2 的算数表达式，或者其他一些更复杂的。
* JavaScript 中的 null 仅仅是一个代表“无”、“空”或“值未知”的特殊值。
* 如果一个变量已被声明，但未被赋值，那么它的值就是 undefined.
* object 类型是一个特殊的类型。其他所有的数据类型都被称为“原始类型”，因为它们的值只包含一个单独的内容（字符串、数字或者其他）。相反，object 则用于储存数据集合和更复杂的实体。
* typeof null 的结果为 "object"。这是官方承认的 typeof 的错误，这个问题来自于 JavaScript 语言的早期阶段，并为了兼容性而保留了下来。null 绝对不是一个 object。null 有自己的类型，它是一个特殊值。typeof 的行为在这里是错误的。
* typeof alert 的结果是 "function"，因为 alert 在 JavaScript 语言中是一个函数。我们会在下一章学习函数，那时我们会了解到，在 JavaScript 语言中没有一个特别的 “function” 类型。函数隶属于 object 类型。但是 typeof 会对函数区分对待，并返回 "function"。这也是来自于 JavaScript 语言早期的问题。从技术上讲，这种行为是不正确的，但在实际编程中却非常方便。
* prompt: 显示信息要求用户输入文本。点击确定返回文本，点击取消或按下 Esc 键返回 null。
* confirm: 显示信息等待用户点击确定或取消。点击确定返回 true，点击取消或按下 Esc 键返回 false。
* 我们也可以显式地调用 String(value) 来将 value 转换为字符串类型; 我们也可以使用 Number(value) 显式地将这个 value 转换为 number 类型; 我们也可以通过调用 Boolean(value) 显式地进行转换布尔值。
* 请注意：包含 0 的字符串 "0" 是 true; 一些编程语言（比如 PHP）视 "0" 为 false。但在 JavaScript 中，非空的字符串总是 true。
* 逗号运算符 , 是最少见最不常使用的运算符之一。有时候它会被用来写更简短的代码，因此为了能够理解代码，我们需要了解它。逗号运算符能让我们处理多个语句，使用 , 将它们分开。每个语句都运行了，但是只有最后的语句的结果会被返回。为什么我们需要这样一个运算符，它只返回最后一个值呢？有时候，人们会使用它把几个行为放在一行上来进行复杂的运算。这样的技巧在许多 JavaScript 框架中都有使用，这也是为什么我们提到它。但是通常它并不能提升代码的可读性，使用它之前，我们要想清楚。
* 严格相等运算符 === 在进行比较时不会做任何的类型转换。
* 对 null 和 undefined 进行比较:当使用 null 或 undefined 与其他值进行比较时，其返回结果常常出乎你的意料。 当使用严格相等 === 比较二者时它们不相等，因为它们属于不同的类型。当使用非严格相等 == 比较二者时 JavaScript 存在一个特殊的规则，会判定它们相等。它们俩就像“一对恋人”，仅仅等于对方而不等于其他任何的值（只在非严格相等下成立）。
* 或运算寻找第一个真值: `result = value1 || value2 || value3;` 从左到右依次计算操作数。 处理每一个操作数时，都将其转化为布尔值。如果结果是 true，就停止计算，返回这个操作数的初始值。 如果所有的操作数都被计算过（也就是，转换结果都是 false），则返回最后一个操作数。
* 与运算寻找第一个假值: `result = value1 && value2 && value3;` 从左到右依次计算操作数。 在处理每一个操作数时，都将其转化为布尔值。如果结果是 false，就停止计算，并返回这个操作数的初始值。 如果所有的操作数都被计算过（例如都是真值），则返回最后一个操作数。
* 两个非运算 !! 有时候用来将某个值转化为布尔类型: `alert( !!"non-empty string" ); // true`, `alert( !!null ); // false`, 也就是，第一个非运算将该值转化为布尔类型并取反，第二个非运算再次取反。最后我们就得到了一个任意值到布尔值的转化。
* 空值合并运算符 '??': a ?? b 的结果是：如果 a 是已定义的，则结果为 a，如果 a 不是已定义的，则结果为 b。 换句话说，如果第一个参数不是 null/undefined，则 ?? 返回第一个参数。否则，返回第二个参数。空值合并运算符并不是什么全新的东西。它只是一种获得两者中的第一个“已定义的”值的不错的语法。另一方面，空值合并运算符 ?? 是最近才被添加到 JavaScript 中的，它的出现是因为人们对 || 不太满意。 它们之间重要的区别是： || 返回第一个 真 值。 ?? 返回第一个 已定义的 值。出于安全原因，JavaScript 禁止将 ?? 运算符与 && 和 || 运算符一起使用，除非使用括号明确指定了优先级。这个限制无疑是值得商榷的，它被添加到语言规范中是为了避免人们从 || 切换到 ?? 时的编程错误。 可以明确地使用括号来解决这个问题。
* break/continue 支持循环前的标签。标签是 break/continue 跳出嵌套循环以转到外部的唯一方法。
* 全局变量：任何函数之外声明的变量，例如上述代码中的外部变量 userName，都被称为 全局 变量。 全局变量在任意函数中都是可见的（除非被局部变量遮蔽）。 减少全局变量的使用是一种很好的做法。现代的代码有很少甚至没有全局变量。大多数变量存在于它们的函数中。但是有时候，全局变量能够用于存储项目级别的数据。
* 空值的 return 或没有 return 的函数返回值为 undefined：如果函数无返回值，它就会像返回 undefined 一样。
* 不要在 return 与返回值之间添加新行：对于 return 的长表达式，可能你会很想将其放在单独一行，但这不行，因为 JavaScript 默认会在 return 之后加上分号。因此，实际上它的返回值变成了空值。 如果我们想要将返回的表达式写成跨多行的形式，那么应该在 return 的同一行开始写此表达式。
* 一个函数 —— 一个行为：一个函数应该只包含函数名所指定的功能，而不是做更多与函数名无关的功能。 两个独立的行为通常需要两个函数，即使它们通常被一起调用（在这种情况下，我们可以创建第三个函数来调用这两个函数）。 有几个违反这一规则的例子： getAge —— 如果它通过 alert 将 age 显示出来，那就有问题了（只应该是获取）。 createForm —— 如果它包含修改文档的操作，例如向文档添加一个表单，那就有问题了（只应该创建表单并返回）。 checkPermission —— 如果它显示 access granted/denied 消息，那就有问题了（只应执行检查并返回结果）。 这些例子假设函数名前缀具有通用的含义。你和你的团队可以自定义这些函数名前缀的含义，但是通常都没有太大的不同。无论怎样，你都应该对函数名前缀的含义、带特定前缀的函数可以做什么以及不可以做什么有深刻的了解。所有相同前缀的函数都应该遵守相同的规则。并且，团队成员应该形成共识。
* 非常短的函数命名：常用的函数有时会有非常短的名字。 例如，[jQuery](http://jquery.com/) 框架用 $ 定义一个函数。[LoDash](http://lodash.com/) 库的核心函数用 _ 命名。 这些都是例外，一般而言，函数名应简明扼要且具有描述性。
* 函数是一个值：重申一次：无论函数是如何创建的，函数都是一个值。在某些编程语言中，只要提到函数的名称都会导致函数的调用执行，但 JavaScript 可不是这样。 在 JavaScript 中，函数是一个值，所以我们可以把它当成值对待。
* 回调函数：让我们多举几个例子，看看如何将函数作为值来传递以及如何使用函数表达式。 我们写一个包含三个参数的函数 ask(question, yes, no).
  ```text
  function ask(question, yes, no) {
    if (confirm(question)) yes()
    else no();
  }
  
  ask(
    "Do you agree?",
    function() { alert("You agreed."); },
    function() { alert("You canceled the execution."); }
  );
  ```
* 一个函数是表示一个“行为”的值：字符串或数字等常规值代表 数据。 函数可以被视为一个 行为（action）。 我们可以在变量之间传递它们，并在需要时运行。
* 什么时候选择函数声明与函数表达式？根据经验，当我们需要声明一个函数时，首先考虑函数声明语法。它能够为组织代码提供更多的灵活性。因为我们可以在声明这些函数之前调用这些函数。 这对代码可读性也更好，因为在代码中查找 function f(…) {…} 比 let f = function(…) {…} 更容易。函数声明更“醒目”。 ……但是，如果由于某种原因而导致函数声明不适合我们（我们刚刚看过上面的例子），那么应该使用函数表达式。
* 一开始，箭头函数可能看起来并不熟悉，也不容易读懂，但一旦我们看习惯了之后，这种情况很快就会改变。 箭头函数对于简单的单行行为（action）来说非常方便，尤其是当我们懒得打太多字的时候。对于一行代码的函数来说，箭头函数是相当方便的。它具体有两种：不带花括号：(...args) => expression — 右侧是一个表达式：函数计算表达式并返回其结果。 带花括号：(...args) => { body } — 花括号允许我们在函数中编写多个语句，但是我们需要显式地 return 来返回一些内容。
* 条件断点：在行号上 右键单击 允许你创建一个 条件 断点。只有当给定的表达式为真（即满足条件）时才会被触发。当我们需要在特定的变量值或参数的情况下暂停程序执行时，这种调试方法就很有用了。
* Continue to here: 在代码中的某一行上右键，在显示的关联菜单（context menu）中点击一个非常有用的名为 “Continue to here” 的选项。 当你想要向前移动很多步到某一行为止，但是又懒得设置一个断点时非常的方便。
* 没有什么规则是“必须”的：没有什么规则是“刻在石头上”的。这些是风格偏好，而不是宗教教条。
* 分号：每一个语句后面都应该有一个分号。即使它可以被跳过。 有一些编程语言的分号确实是可选的，那些语言中也很少使用分号。但是在 JavaScript 中，极少数情况下，换行符有时不会被解释为分号，这时代码就容易出错。更多内容请参阅 [代码结构](https://zh.javascript.info/structure#semicolon) 一章的内容。 如果你是一个有经验的 JavaScript 程序员，你可以选择像 [StandardJS](https://standardjs.com/readme-zhcn.html) 这样的无分号的代码风格。否则，最好使用分号以避免可能出现的陷阱。大多数开发人员都应该使用分号。
* 本章描述的（和提到的代码风格指南中的）所有语法规则，都旨在帮助你提高代码可读性。它们都是值得商榷的。 当我们思考如何写“更好”的代码的时候，我们应该问自己的问题是：“什么可以让代码可读性更高，更容易被理解？”和“什么可以帮助我们避免错误？”这些是我们讨论和选择代码风格时要牢记的主要原则。 阅读流行的代码风格指南，可以帮助你了解有关代码风格的变化趋势和最佳实践的最新想法。
* 好的注释：所以，解释性注释通常来说都是不好的。那么哪一种注释才是好的呢？ 
  * 描述架构：对组件进行高层次的整体概括，它们如何相互作用、各种情况下的控制流程是什么样的……简而言之 —— 代码的鸟瞰图。有一个专门用于构建代码的高层次架构图，以对代码进行解释的特殊编程语言 [UML](http://wikipedia.org/wiki/Unified_Modeling_Language), 绝对值得学习。 
  * 记录函数的参数和用法：有一个专门用于记录函数的语法 [JSDoc](http://en.wikipedia.org/wiki/JSDoc): 用法、参数和返回值。这种注释可以帮助我们理解函数的目的，并且不需要研究其内部的实现代码，就可以直接正确地使用它。
  * 为什么任务以这种方式解决？写了什么代码很重要。但是为什么 不 那样写可能对于理解正在发生什么更重要。为什么任务是通过这种方式解决的？代码并没有给出答案。 如果有很多种方法都可以解决这个问题，为什么偏偏是这一种？尤其当它不是最显而易见的那一种的时候。解决方案的注释非常的重要。它们可以帮助你以正确的方式继续开发。
  * 代码有哪些巧妙的特性？它们被用在了什么地方？ 如果代码存在任何巧妙和不显而易见的方法，那绝对需要注释。
* 自动化测试意味着测试是独立于代码的。它们以各种方式运行我们的函数，并将结果与预期结果进行比较。
* 在 BDD 中，规范先行，实现在后。最后我们同时拥有了规范和代码。有了规范，我们可以安全地改进、修改甚至重写函数，并确保它仍然正确地工作。 这在一个函数会被用在多个地方的大型项目中尤其重要。当我们改变这样一个函数时，没有办法手动检查每个使用它们的地方是否仍旧正确。自动化测试则有助于避免这样的问题！ 如果这个项目被测试代码覆盖了，就不会出现这种问题。在任何修改之后，我们都可以运行测试，并在几秒钟内看到大量的检查。 另外，一个经过良好测试的代码通常都有更好的架构。 当然，这是因为覆盖了自动化测试的代码更容易修改和改进。但还有另一个原因。 要编写测试，代码的组织方式应确保每个函数都有一个清晰描述的任务、定义良好的输入和输出。这意味着从一开始就有一个好的架构。 在实际开发中有时候可能并不容易，有时很难在写实际代码之前编写规范，因为还不清楚它应该如何表现。但一般来说，编写测试使得开发更快更稳定。
* 作为程序员，我们希望使用最新的特性。好东西越多越好！ 另一方面，如何让我们现代的代码在还不支持最新特性的旧引擎上工作？ 有两个工作可以做到这一点： 转译器（Transpilers）。 垫片（Polyfills）。
* 通常，开发者会在自己的计算机上运行转译器，然后将转译后的代码部署到服务器。 说到名字，[Babel](https://babeljs.io/) 是最著名的转译器之一。 现代项目构建系统，例如 [webpack](http://webpack.github.io/), 提供了在每次代码更改时自动运行转译器的方法，因此很容易将代码转译集成到开发过程中。
* JavaScript 是一种高度动态的语言，脚本可以添加/修改任何函数，甚至包括内建函数。 两个有趣的 polyfill 库： [core js](https://github.com/zloirock/core-js) 支持了很多特性，允许只包含需要的特性。 [polyfill.io](http://polyfill.io/) 提供带有 polyfill 的脚本的服务，具体取决于特性和用户的浏览器。
* 谷歌的 Chrome 浏览器通常是对最新的语言特性的支持情况最好的浏览器，如果教程的示例运行失败，请尝试使用 Chrome 浏览器。不过，教程中的大多数示例都适用于任意的现代浏览器。
* 方括号: 对于多词属性，点操作就不能用了。JavaScript 理解不了。它认为我们在处理 user.likes，然后在遇到意外的 birds 时给出了语法错误。 点符号要求 key 是有效的变量标识符。这意味着：不包含空格，不以数字开头，也不包含特殊字符（允许使用 $ 和 _）。 有另一种方法，就是使用方括号，可用于任何字符串
* 现在一切都可行了。请注意方括号中的字符串要放在引号中，单引号或双引号都可以。 方括号同样提供了一种可以通过任意表达式来获取属性名的方法 —— 跟语义上的字符串不同。 在这里，变量 key 可以是程序运行时计算得到的，也可以是根据用户的输入得到的。然后我们可以用它来访问属性。这给了我们很大的灵活性。
* 计算属性：当创建一个对象时，我们可以在对象字面量中使用方括号。这叫做 计算属性。计算属性的含义很简单：\[fruit\] 含义是属性名应该从 fruit 变量中获取。 所以，如果一个用户输入 "apple"，bag 将变为 {apple: 5}。
* 方括号比点符号更强大。它允许任何属性名和变量，但写起来也更加麻烦。所以，大部分时间里，当属性名是已知且简单的时候，就使用点符号。如果我们需要一些更复杂的内容，那么就用方括号。
* 属性值简写：在实际开发中，我们通常用已存在的变量当做属性名。属性名跟变量名一样。这种通过变量生成属性的应用场景很常见，在这有一种特殊的 属性值缩写 方法，使属性名变得更短。 可以用 name 来代替 name:name
* 属性名称限制：我们已经知道，变量名不能是编程语言的某个保留字，如 “for”、“let”、“return” 等…… 但对象的属性名并不受此限制。简而言之，属性命名没有限制。属性名可以是任何字符串或者 symbol（一种特殊的标志符类型，将在后面介绍）。 其他类型会被自动地转换为字符串。 例如，当数字 0 被用作对象的属性的键时，会被转换为字符串 "0"
* 属性存在性测试，“in” 操作符：相比于其他语言，JavaScript 的对象有一个需要注意的特性：能够被访问任何属性。即使属性不存在也不会报错！ 读取不存在的属性只会得到 undefined。所以我们可以很容易地判断一个属性是否存在。这里还有一个特别的，检查属性是否存在的操作符 "in"。请注意，in 的左边必须是 属性名。通常是一个带引号的字符串。 如果我们省略引号，就意味着左边是一个变量，它应该包含要判断的实际属性名。为何会有 in 运算符呢？与 undefined 进行比较来判断还不够吗？ 确实，大部分情况下与 undefined 进行比较来判断就可以了。但有一个例外情况，这种比对方式会有问题，但 in 运算符的判断结果仍是对的。 那就是属性存在，但存储的值是 undefined 的时候。
* 像对象一样排序：对象有顺序吗？换句话说，如果我们遍历一个对象，我们获取属性的顺序是和属性添加时的顺序相同吗？这靠谱吗？ 简短的回答是：“有特别的顺序”：整数属性会被进行排序，其他属性则按照创建的顺序显示。
* 整数属性？那是什么？这里的“整数属性”指的是一个可以在不做任何更改的情况下与一个整数进行相互转换的字符串。 所以，“49” 是一个整数属性名，因为我们把它转换成整数，再转换回来，它还是一样的。但是 “+49” 和 “1.2” 就不行了。……此外，如果属性名不是整数，那它们就按照创建时的顺序来排序。
* 深层克隆: 为了解决这个问题，我们应该使用一个拷贝循环来检查 user\[key] 的每个值，如果它是一个对象，那么也复制它的结构。这就是所谓的“深拷贝”。 我们可以使用递归来实现它。或者为了不重复造轮子，采用现有的实现，例如 [lodash](https://lodash.com/) 库的 [_.cloneDeep(obj)](https://lodash.com/docs#cloneDeep).
* [垃圾回收](https://zh.javascript.info/garbage-collection): JavaScript 中主要的内存管理概念是 可达性。 **这里有大量图说明可达性概念。**  一些优化建议： 
  * 分代收集（Generational collection）—— 对象被分成两组：“新的”和“旧的”。许多对象出现，完成它们的工作并很快死去，它们可以很快被清理。那些长期存活的对象会变得“老旧”，而且被检查的频次也会减少。 
  * 增量收集（Incremental collection）—— 如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟。所以引擎试图将垃圾收集工作分成几部分来做。然后将这几部分会逐一进行处理。这需要它们之间有额外的标记来追踪变化，但是这样会有许多微小的延迟而不是一个大的延迟。 
  * 闲时收集（Idle-time collection）—— 垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。
* 面向对象编程: 当我们在代码中用对象表示实体时，就是所谓的 面向对象编程，简称为 “OOP”。 OOP 是一门大学问，本身就是一门有趣的科学。怎样选择合适的实体？如何组织它们之间的交互？这就是架构，有很多关于这方面的书，例如 E. Gamma、R. Helm、R. Johnson 和 J. Vissides 所著的《设计模式：可复用面向对象软件的基础》，G. Booch 所著的《面向对象分析与设计》等。
* “this” 不受限制: 在 JavaScript 中，this 关键字与其他大多数编程语言中的不同。JavaScript 中的 this 可以用于任何函数，即使它不是对象的方法。this 的值是在代码运行时计算出来的，它取决于代码上下文。
* 在没有对象的情况下调用：this == undefined 在这种情况下，严格模式下的 this 值为 undefined。如果我们尝试访问 this.name，将会报错。 在非严格模式的情况下，this 将会是 全局对象（浏览器中的 window，我们稍后会在 [全局对象](https://zh.javascript.info/global-object) 一章中学习它）。这是一个历史行为，"use strict" 已经将其修复了。 通常这种调用是程序出错了。如果在一个函数内部有 this，那么通常意味着它是在对象上下文环境中被调用的。
* 解除 this 绑定的后果: 如果你经常使用其他的编程语言，那么你可能已经习惯了“绑定 this”的概念，即在对象中定义的方法总是有指向该对象的 this。 在 JavaScript 中，this 是“自由”的，它的值是在调用时计算出来的，它的值并不取决于方法声明的位置，而是取决于在“点符号前”的是什么对象。 在运行时对 this 求值的这个概念既有优点也有缺点。一方面，函数可以被重用于不同的对象。另一方面，更大的灵活性造成了更大的出错的可能。 这里我们的立场并不是要评判编程语言的这个设计是好是坏。而是要了解怎样使用它，如何趋利避害。
* 箭头函数没有自己的 “this”: 箭头函数有些特别：它们没有自己的 this。如果我们在这样的函数中引用 this，this 值取决于外部“正常的”函数。
* 当一个函数被使用 new 操作符执行时，它按照以下步骤：
  1. 一个新的空对象被创建并分配给 this。
  2. 函数体执行。通常它会修改 this，为其添加新的属性。 
  3. 返回 this 的值。
* 让我们再强调一遍 —— 从技术上讲，任何函数（除了箭头函数，它没有自己的 this）都可以用作构造器。即可以通过 new 来运行，它会执行上面的算法。“首字母大写”是一个共同的约定，以明确表示一个函数将被使用 new 来运行。
* 在一个函数内部，我们可以使用 new.target 属性来检查它是否被使用 new 进行调用了。这种方法有时被用在库中以使语法更加灵活。这样人们在调用函数时，无论是否使用了 new，程序都能工作。 不过，到处都使用它并不是一件好事，因为省略了 new 使得很难观察到代码中正在发生什么。而通过 new 我们都可以知道这创建了一个新对象。
* 构造函数，或简称构造器，就是常规函数，但大家对于构造器有个共同的约定，就是其命名首字母要大写。 构造函数只能使用 new 来调用。这样的调用意味着在开始时创建了空的 this，并在最后返回填充了值的 this。
* 可选链 ?. 是一种访问嵌套对象属性的安全的方式。即使中间的属性不存在，也不会出现错误。
* 如果可选链 ?. 前面的值为 undefined 或者 null，它会停止运算并返回 undefined。
* 不要过度使用可选链: 我们应该只将 ?. 使用在一些东西可以不存在的地方。 例如，如果根据我们的代码逻辑，user 对象必须存在，但 address 是可选的，那么我们应该这样写 user.address?.street，而不是这样 user?.address?.street。 所以，如果 user 恰巧因为失误变为 undefined，我们会看到一个编程错误并修复它。否则，代码中的错误在不恰当的地方被消除了，这会导致调试更加困难。
* ?. 前的变量必须已声明（例如 let/const/var user 或作为一个函数参数）。可选链仅适用于已声明的变量。 其它变体：?.()，?.[] 可选链 ?. 不是一个运算符，而是一个特殊的语法结构。它还可以与函数和方括号一起使用。 例如，将 ?.() 用于调用一个可能不存在的函数。 如果我们想使用方括号 [] 而不是点符号 . 来访问属性，语法 ?.[] 也可以使用。跟前面的例子类似，它允许从一个可能不存在的对象上安全地读取属性。
* 我们可以使用 ?. 来安全地读取或删除，但不能写入: 可选链 ?. 不能用在赋值语句的左侧。
* 可选链 ?. 语法有三种形式：
  * obj?.prop —— 如果 obj 存在则返回 obj.prop，否则返回 undefined。
  * obj?.\[prop\] —— 如果 obj 存在则返回 obj\[prop\]，否则返回 undefined。
  * obj.method?.() —— 如果 obj.method 存在则调用 obj.method()，否则返回 undefined。
* Symbol 不会被自动转换为字符串: JavaScript 中的大多数值都支持字符串的隐式转换。例如，我们可以 alert 任何值，都可以生效。Symbol 比较特殊，它不会被自动转换。
* “隐藏”属性: Symbol 允许我们创建对象的“隐藏”属性，代码的任何其他部分都不能意外访问或重写这些属性。
* 对象字面量中的 Symbol: 如果我们要在对象字面量 {...} 中使用 Symbol，则需要使用方括号把它括起来。
* 全局 symbol: 正如我们所看到的，通常所有的 Symbol 都是不同的，即使它们有相同的名字。但有时我们想要名字相同的 Symbol 具有相同的实体。例如，应用程序的不同部分想要访问的 Symbol "id" 指的是完全相同的属性。 为了实现这一点，这里有一个 全局 Symbol 注册表。我们可以在其中创建 Symbol 并在稍后访问它们，它可以确保每次访问相同名字的 Symbol 时，返回的都是相同的 Symbol。 要从注册表中读取（不存在则创建）Symbol，请使用 Symbol.for(key)。 该调用会检查全局注册表，如果有一个描述为 key 的 Symbol，则返回该 Symbol，否则将创建一个新 Symbol（Symbol(key)），并通过给定的 key 将其存储在注册表中。
* 这听起来像 Ruby: 在一些编程语言中，例如 Ruby，每个名字都有一个 Symbol。 正如我们所看到的，在 JavaScript 中，全局 Symbol 也是这样的。
* 系统 Symbol: JavaScript 内部有很多“系统” Symbol，我们可以使用它们来微调对象的各个方面。例如，Symbol.toPrimitive 允许我们将对象描述为原始值转换。我们很快就会看到它的使用。 当我们研究相应的语言特征时，我们对其他的 Symbol 也会慢慢熟悉起来。
* Symbol 有两个主要的使用场景： “隐藏” 对象属性。 如果我们想要向“属于”另一个脚本或者库的对象添加一个属性，我们可以创建一个 Symbol 并使用它作为属性的键。Symbol 属性不会出现在 for..in 中，因此它不会意外地被与其他属性一起处理。并且，它不会被直接访问，因为另一个脚本没有我们的 symbol。因此，该属性将受到保护，防止被意外使用或重写。 因此我们可以使用 Symbol 属性“秘密地”将一些东西隐藏到我们需要的对象中，但其他地方看不到它。 JavaScript 使用了许多系统 Symbol，这些 Symbol 可以作为 Symbol.* 访问。我们可以使用它们来改变一些内建行为。例如，在本教程的后面部分，我们将使用 Symbol.iterator 来进行 [迭代](https://zh.javascript.info/iterable) 操作，使用 Symbol.toPrimitive 来设置 [对象原始值的转换](https://zh.javascript.info/object-toprimitive) 等等。 从技术上说，Symbol 不是 100% 隐藏的。有一个内建方法 [Object.getOwnPropertySymbols](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols)(obj) 允许我们获取所有的 Symbol。还有一个名为 [Reflect.ownKeys(obj)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys) 的方法可以返回一个对象的 所有 键，包括 Symbol。所以它们并不是真正的隐藏。但是大多数库、内建方法和语法结构都没有使用这些方法。
* 对象 — 原始值转换，为了进行转换，JavaScript 尝试查找并调用三个对象方法：
  1. 调用 obj\[Symbol.toPrimitive\](hint) —— 带有 symbol 键 Symbol.toPrimitive（系统 symbol）的方法，如果这个方法存在的话， 
  2. 否则，如果 hint 是 "string" —— 尝试 obj.toString() 和 obj.valueOf()，无论哪个存在。 
  3. 否则，如果 hint 是 "number" 或 "default" —— 尝试 obj.valueOf() 和 obj.toString()，无论哪个存在。
* 历史原因：由于历史原因，如果 toString 或 valueOf 返回一个对象，则不会出现 error，但是这种值会被忽略（就像这种方法根本不存在）。这是因为在 JavaScript 语言发展初期，没有很好的 “error” 的概念。 相反，Symbol.toPrimitive 必须 返回一个原始值，否则就会出现 error。
* 关于对象的最好的事儿之一是，我们可以把一个函数作为对象的属性存储到对象中。
* 以下是 str.toUpperCase() 中实际发生的情况： 
  1. 字符串 str 是一个原始值。因此，在访问其属性时，会创建一个包含字符串字面值的特殊对象，并且具有有用的方法，例如 toUpperCase()。 
  2. 该方法运行并返回一个新的字符串（由 alert 显示）。 
  3. 特殊对象被销毁，只留下原始值 str。
* 构造器 String/Number/Boolean 仅供内部使用: 像 Java 这样的一些语言允许我们使用 new Number(1) 或 new Boolean(false) 等语法，明确地为原始类型创建“对象包装器”。 在 JavaScript 中，由于历史原因，这也是可以的，但极其 不推荐。因为这样会出问题。
* null/undefined 没有任何方法: 特殊的原始类型 null 和 undefined 是例外。它们没有对应的“对象包装器”，也没有提供任何方法。从某种意义上说，它们是“最原始的”。
* 在 JavaScript 中，我们可以通过在数字后面附加字母 "e" 并指定零的个数来缩短数字。
* [十六进制](https://en.wikipedia.org/wiki/Hexadecimal) 数字在 JavaScript 中被广泛用于表示颜色，编码字符以及其他许多东西。所以自然地，有一种较短的写方法：0x，然后是数字。
* 使用两个点来调用一个方法：请注意 123456..toString(36) 中的两个点不是打错了。如果我们想直接在一个数字上调用一个方法，比如上面例子中的 toString，那么我们需要在它后面放置两个点 ..。 如果我们放置一个点：123456.toString(36)，那么就会出现一个 error，因为 JavaScript 语法隐含了第一个点之后的部分为小数部分。如果我们再放一个点，那么 JavaScript 就知道小数部分为空，现在使用该方法。 也可以写成 (123456).toString(36)。
* 一个数字以其二进制的形式存储在内存中，一个 1 和 0 的序列。但是在十进制数字系统中看起来很简单的 0.1，0.2 这样的小数，实际上在二进制形式中是无限循环小数。 换句话说，什么是 0.1？0.1 就是 1 除以 10，1/10，即十分之一。在十进制数字系统中，这样的数字表示起来很容易。将其与三分之一进行比较：1/3。三分之一变成了无限循环小数 0.33333(3)。 在十进制数字系统中，可以保证以 10 的整数次幂作为除数能够正常工作，但是以 3 作为除数则不能。也是同样的原因，在二进制数字系统中，可以保证以 2 的整数次幂作为除数时能够正常工作，但 1/10 就变成了一个无限循环的二进制小数。 使用二进制数字系统无法 精确 存储 0.1 或 0.2，就像没有办法将三分之一存储为十进制小数一样。 IEEE-754 数字格式通过将数字舍入到最接近的可能数字来解决此问题。这些舍入规则通常不允许我们看到“极小的精度损失”，但是它确实存在。不仅仅是 JavaScript, 许多其他编程语言也存在同样的问题。 PHP，Java，C，Perl，Ruby 给出的也是完全相同的结果，因为它们基于的是相同的数字格式。
* 与 Object.is 进行比较: 有一个特殊的内建方法 Object.is，它类似于 === 一样对值进行比较，但它对于两种边缘情况更可靠： 它适用于 NaN：Object.is(NaN，NaN) === true，这是件好事。 值 0 和 -0 是不同的：Object.is(0，-0) === false，从技术上讲这是对的，因为在内部，数字的符号位可能会不同，即使其他所有位均为零。 在所有其他情况下，Object.is(a，b) 与 a === b 相同。 这种比较方式经常被用在 JavaScript 规范中。当内部算法需要比较两个值是否完全相同时，它使用 Object.is（内部称为 [SameValue](https://tc39.es/ecma262/#sec-samevalue) ）。
* 在 JavaScript 中，文本数据被以字符串形式存储，单个字符没有单独的类型。 字符串的内部格式始终是 [UTF-16](https://en.wikipedia.org/wiki/UTF-16), 它不依赖于页面编码。
* length 是一个属性: 掌握其他编程语言的人，有时会错误地调用 str.length() 而不是 str.length。这是行不通的。 请注意 str.length 是一个数字属性，而不是函数。后面不需要添加括号。
* 实际上，这意味着一件很简单的事儿：对于 32-bit 整数，~n 等于 -(n+1)。正如我们看到这样，只有当 n == -1 时，~n 才为零（适用于任何 32-bit 带符号的整数 n）。 因此，仅当 indexOf 的结果不是 -1 时，检查 if ( ~str.indexOf("...") ) 才为真。换句话说，当有匹配时。 人们用它来简写 indexOf 检查。通常不建议以非显而易见的方式使用语言特性，但这种特殊技巧在旧代码中仍被广泛使用，所以我们应该理解它。 只要记住：if (~str.indexOf(...)) 读作 “if found”。 确切地说，由于 ~ 运算符将大数字截断为 32 位，因此存在给出 0 的其他数字，最小的数字是 ~4294967295=0。这使得这种检查只有在字符串没有那么长的情况下才是正确的。 现在我们只会在旧的代码中看到这个技巧，因为现代 JavaScript 提供了 .includes 方法（见下文）。
* slice, substr, substring 使用哪一个？它们可以完成这项工作。形式上，substr 有一个小缺点：它不是在 JavaScript 核心规范中描述的，而是在附录 B 中，它涵盖了主要由于历史原因而存在的仅浏览器特性。因此，非浏览器环境可能无法支持它。但实际上它在任何地方都有效。 相较于其他两个变体，slice 稍微灵活一些，它允许以负值作为参数并且写法更简短。因此仅仅记住这三种方法中的 slice 就足够了。
* 请注意，代理对的各部分没有任何意义。因此，上述示例中的 alert 显示的实际上是垃圾信息。 技术角度来说，代理对也是可以通过它们的代码检测到的：如果一个字符的代码在 0xd800..0xdbff 范围内，那么它是代理对的第一部分。下一个字符（第二部分）必须在 0xdc00..0xdfff 范围中。这些范围是按照标准专门为代理对保留的。
* JavaScript 中的数组既可以用作队列，也可以用作栈。它们允许你从首端/末端来添加/删除元素。 这在计算机科学中，允许这样的操作的数据结构被称为 [双端队列（deque）](https://en.wikipedia.org/wiki/Double-ended_queue).
* 数组是一种特殊的对象。使用方括号来访问属性 arr\[0] 实际上是来自于对象的语法。它其实与 obj\[key] 相同，其中 arr 是对象，而数字用作键（key）。 它们扩展了对象，提供了特殊的方法来处理有序的数据集合以及 length 属性。但从本质上讲，它仍然是一个对象。 记住，在 JavaScript 中只有 8 种基本的数据类型（详见 数据类型 一章）。数组是一个对象，因此其行为也像一个对象。
* 但是数组真正特殊的是它们的内部实现。JavaScript 引擎尝试把这些元素一个接一个地存储在连续的内存区域，就像本章的插图显示的一样，而且还有一些其它的优化，以使数组运行得非常快。 但是，如果我们不像“有序集合”那样使用数组，而是像常规对象那样使用数组，这些就都不生效了。因为数组是基于对象的。我们可以给它们添加任何属性。 但是 Javascript 引擎会发现，我们在像使用常规对象一样使用数组，那么针对数组的优化就不再适用了，然后对应的优化就会被关闭，这些优化所带来的优势也就荡然无存了。
* 数组误用的几种方式: 添加一个非数字的属性，比如 arr.test = 5。 制造空洞，比如：添加 arr\[0]，然后添加 arr\[1000] (它们中间什么都没有)。 以倒序填充数组，比如 arr\[1000]，arr\[999] 等等。 请将数组视为作用于 有序数据 的特殊结构。它们为此提供了特殊的方法。数组在 JavaScript 引擎内部是经过特殊调整的，使得更好地作用于连续的有序数据，所以请以正确的方式使用数组。如果你需要任意键值，那很有可能实际上你需要的是常规对象 {}。
* 性能: push/pop 方法运行的比较快，而 shift/unshift 比较慢。
* 通常来说，我们不应该用 for..in 来处理数组。会有一些潜在问题存在： 
  * for..in 循环会遍历 所有属性，不仅仅是这些数字属性。 在浏览器和其它环境中有一种称为“类数组”的对象，它们 看似是数组。也就是说，它们有 length 和索引属性，但是也可能有其它的非数字的属性和方法，这通常是我们不需要的。for..in 循环会把它们都列出来。所以如果我们需要处理类数组对象，这些“额外”的属性就会存在问题。 
  * for..in 循环适用于普通对象，并且做了对应的优化。但是不适用于数组，因此速度要慢 10-100 倍。当然即使是这样也依然非常快。只有在遇到瓶颈时可能会有问题。但是我们仍然应该了解这其中的不同。
* 关于 “length”: 当我们修改数组的时候，length 属性会自动更新。准确来说，它实际上不是数组里元素的个数，而是最大的数字索引值加一。
* length 属性的另一个有意思的点是它是可写的。 如果我们手动增加它，则不会发生任何有趣的事儿。但是如果我们减少它，数组就会被截断。该过程是不可逆的。所以，清空数组最简单的方法就是：arr.length = 0;。
* 不要使用 == 比较数组：JavaScript 中的数组与其它一些编程语言的不同，不应该使用 == 运算符比较 JavaScript 中的数组。 该运算符不会对数组进行特殊处理，它会像处理任意对象那样处理数组。
* [arr.splice](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/splice) 方法可以说是处理数组的瑞士军刀。它可以做所有事情：添加，删除和插入元素。
* [arr.slice](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/slice) 方法比 arr.splice 简单得多。它会返回一个新数组，将所有从索引 start 到 end（不包括 end）的数组项复制到一个新的数组。start 和 end 都可以是负数，在这种情况下，从末尾计算索引。 它和字符串的 str.slice 方法有点像，就是把子字符串替换成子数组。
* [arr.concat](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/concat) 创建一个新数组，其中包含来自于其他数组和其他项的值。它接受任意数量的参数 —— 数组或值都可以。 结果是一个包含来自于 arr，然后是 arg1，arg2 的元素的新数组。 如果参数 argN 是一个数组，那么其中的所有元素都会被复制。否则，将复制参数本身。通常，它只复制数组中的元素。其他对象，即使它们看起来像数组一样，但仍然会被作为一个整体添加。……但是，如果类似数组的对象具有 Symbol.isConcatSpreadable 属性，那么它就会被 concat 当作一个数组来处理：此对象中的元素将被添加。
* [arr.forEach](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach) 方法允许为数组的每个元素都运行一个函数。该函数的结果（如果它有返回）会被抛弃和忽略。
* [arr.map](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/map) 方法是最有用和经常使用的方法之一。 它对数组的每个元素都调用函数，并返回结果数组。
* [arr.sort](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/sort) 方法对数组进行 原位（in-place） 排序，更改元素的顺序。(译注：原位是指在此数组内，而非生成一个新数组。) 它还返回排序后的数组，但是返回值通常会被忽略，因为修改了 arr 本身。 arr 可以是由任何内容组成的数组，对吗？它可能包含数字、字符串、对象或其他任何内容。我们有一组 一些元素。要对其进行排序，我们需要一个 排序函数 来确认如何比较这些元素。默认是按字符串进行排序的。 arr.sort(fn) 方法实现了通用的排序算法。我们不需要关心它的内部工作原理（大多数情况下都是经过 [快速排序](https://en.wikipedia.org/wiki/Quicksort) 或 [Timsort](https://en.wikipedia.org/wiki/Timsort) 算法优化的）。它将遍历数组，使用提供的函数比较其元素并对其重新排序，我们所需要的就是提供执行比较的函数 fn。
* 比较函数可以返回任何数字：实际上，比较函数只需要返回一个正数表示“大于”，一个负数表示“小于”。 通过这个原理我们可以编写更短的函数：`arr.sort(function(a, b) { return a - b; });`  这里使用箭头函数会更加简洁：`arr.sort( (a, b) => a - b );`.  
* 当我们需要遍历一个数组时 —— 我们可以使用 forEach，for 或 for..of。 当我们需要遍历并返回每个元素的数据时 —— 我们可以使用 map。 [arr.reduce](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce) 方法和 [arr.reduceRight](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight) 方法和上面的种类差不多，但稍微复杂一点。它们用于根据数组计算单个值。掌握这个知识点的最简单的方法就是通过示例。
* 大多数方法都支持 “thisArg”: 几乎所有调用函数的数组方法 —— 比如 find，filter，map，除了 sort 是一个特例，都接受一个可选的附加参数 thisArg。 上面的部分中没有解释该参数，因为该参数很少使用。但是为了完整性，我们需要讲讲它。
* [arr.some(fn)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/some)/[arr.every(fn)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/every) 检查数组。 与 map 类似，对数组的每个元素调用函数 fn。如果任何/所有结果为 true，则返回 true，否则返回 false。 这两个方法的行为类似于 || 和 && 运算符：如果 fn 返回一个真值，arr.some() 立即返回 true 并停止迭代其余数组项；如果 fn 返回一个假值，arr.every() 立即返回 false 并停止对其余数组项的迭代。
* Iterable object（可迭代对象）: 可迭代（Iterable） 对象是数组的泛化。这个概念是说任何对象都可以被定制为可在 for..of 循环中使用的对象。 数组是可迭代的。但不仅仅是数组。很多其他内建对象也都是可迭代的。例如字符串也是可迭代的。 如果从技术上讲，对象不是数组，而是表示某物的集合（列表，集合），for..of 是一个能够遍历它的很好的语法，因此，让我们来看看如何使其发挥作用。为了让对象可迭代（也就让 for..of 可以运行）我们需要为对象添加一个名为 Symbol.iterator 的方法（一个专门用于使对象可迭代的内建 symbol）。
* 无穷迭代器（iterator）: 无穷迭代器也是可能的。例如，将 range 设置为 range.to = Infinity，这时 range 则成为了无穷迭代器。或者我们可以创建一个可迭代对象，它生成一个无穷伪随机数序列。也是可能的。 next 没有什么限制，它可以返回越来越多的值，这是正常的。 当然，迭代这种对象的 for..of 循环将不会停止。但是我们可以通过使用 break 来停止它。
* 可迭代（iterable）和类数组（array-like）: 这两个官方术语看起来差不多，但其实大不相同。请确保你能够充分理解它们的含义，以免造成混淆。 Iterable 如上所述，是实现了 Symbol.iterator 方法的对象。 Array-like 是有索引和 length 属性的对象，所以它们看起来很像数组。 当我们将 JavaScript 用于编写在浏览器或任何其他环境中的实际任务时，我们可能会遇到可迭代对象或类数组对象，或两者兼有。有一个全局方法 [Array.from](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/from) 可以接受一个可迭代或类数组的值，并从中获取一个“真正的”数组。然后我们就可以对其调用数组方法了。
* map\[key] 不是使用 Map 的正确方式: 虽然 map\[key] 也有效，例如我们可以设置 map\[key] = 2，这样会将 map 视为 JavaScript 的 plain object，因此它暗含了所有相应的限制（仅支持 string/symbol 键等）。 所以我们应该使用 map 方法：set 和 get 等。
* Map 是怎么比较键的？ Map 使用 [SameValueZero](https://tc39.github.io/ecma262/#sec-samevaluezero) 算法来比较键是否相等。它和严格等于 === 差不多，但区别是 NaN 被看成是等于 NaN。所以 NaN 也可以被用作键。 这个算法不能被改变或者自定义。
* 链式调用: 每一次 map.set 调用都会返回 map 本身，所以我们可以进行“链式”调用：`map.set('1', 'str1').set(1, 'num1').set(true, 'bool1');`.
* 使用插入顺序: 迭代的顺序与插入值的顺序相同。与普通的 Object 不同，Map 保留了此顺序。
* 当创建一个 Map 后，我们可以传入一个带有键值对的数组（或其它可迭代对象）来进行初始化。如果我们想从一个已有的普通对象（plain object）来创建一个 Map，那么我们可以使用内建方法 [Object.entries(obj)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/entries), 该方法返回对象的键/值对数组，该数组格式完全按照 Map 所需的格式。[Object.fromEntries](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) 方法的作用是相反的：给定一个具有 \[key, value] 键值对的数组，它会根据给定数组创建一个对象。
* Set 迭代（iteration）: 注意一件有趣的事儿。forEach 的回调函数有三个参数：一个 value，然后是 同一个值 valueAgain，最后是目标对象。没错，同一个值在参数里出现了两次。 forEach 的回调函数有三个参数，是为了与 Map 兼容。当然，这看起来确实有些奇怪。但是这对在特定情况下轻松地用 Set 代替 Map 很有帮助，反之亦然。
* WeakMap 在这方面有着根本上的不同。它不会阻止垃圾回收机制对作为键的对象（key object）的回收。WeakMap 和 Map 的第一个不同点就是，WeakMap 的键必须是对象，不能是原始值。WeakMap 不支持迭代以及 keys()，values() 和 entries() 方法。所以没有办法获取 WeakMap 的所有键或值。为什么会有这种限制呢？这是技术的原因。如果一个对象丢失了其它所有引用（就像上面示例中的 john），那么它就会被垃圾回收机制自动回收。但是在从技术的角度并不能准确知道 何时会被回收。 这些都是由 JavaScript 引擎决定的。JavaScript 引擎可能会选择立即执行内存清理，如果现在正在发生很多删除操作，那么 JavaScript 引擎可能就会选择等一等，稍后再进行内存清理。因此，从技术上讲，WeakMap 的当前元素的数量是未知的。JavaScript 引擎可能清理了其中的垃圾，可能没清理，也可能清理了一部分。因此，暂不支持访问 WeakMap 的所有键/值的方法。WeakMap 和 WeakSet 最明显的局限性就是不能迭代，并且无法获取所有当前内容。那样可能会造成不便，但是并不会阻止 WeakMap/WeakSet 完成其主要工作 — 成为在其它地方管理/存储“额外”的对象数据。
* Object.keys(obj) 相对于 map.keys() 第一个区别是，对于对象我们使用的调用语法是 Object.keys(obj)，而不是 obj.keys()。 为什么会这样？主要原因是灵活性。请记住，在 JavaScript 中，对象是所有复杂结构的基础。因此，我们可能有一个自己创建的对象，比如 data，并实现了它自己的 data.values() 方法。同时，我们依然可以对它调用 Object.values(data) 方法。 第二个区别是 Object.* 方法返回的是“真正的”数组对象，而不只是一个可迭代项。这主要是历史原因。
* Object.keys/values/entries 会忽略 symbol 属性: 就像 for..in 循环一样，这些方法会忽略使用 Symbol(...) 作为键的属性。 通常这很方便。但是，如果我们也想要 Symbol 类型的键，那么这儿有一个单独的方法 [Object.getOwnPropertySymbols](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols), 它会返回一个只包含 Symbol 类型的键的数组。另外，还有一种方法 [Reflect.ownKeys(obj)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys), 它会返回 所有 键。
* 转换对象: 对象缺少数组存在的许多方法，例如 map 和 filter 等。 如果我们想应用它们，那么我们可以使用 Object.entries，然后使用 Object.fromEntries： 使用 Object.entries(obj) 从 obj 获取由键/值对组成的数组。 对该数组使用数组方法，例如 map，对这些键/值对进行转换。 对结果数组使用 Object.fromEntries(array) 方法，将结果转回成对象。乍一看，可能感觉有点困难，但是使用一两次之后就很容易理解了。我们可以通过这种方式建立强大的转换链。
  ```text
  let prices = {
    banana: 1,
    orange: 2,
    meat: 4,
  };
  
  let doublePrices = Object.fromEntries(
    // 将价格转换为数组，将每个键/值对映射为另一对
    // 然后通过 fromEntries 再将结果转换为对象
    Object.entries(prices).map(entry => [entry[0], entry[1] * 2])
  );
  
  alert(doublePrices.meat); // 8
  ```
* 解构赋值 是一种特殊的语法，它使我们可以将数组或对象“拆包”至一系列变量中，因为有时这样更方便。 解构操作对那些具有很多参数和默认值等的函数也很奏效。“解构”并不意味着“破坏”: 
这种语法叫做“解构赋值”，因为它通过将结构中的各元素复制到变量中来达到“解构”的目的。但数组本身是没有被修改的。忽略使用逗号的元素: 数组中不想要的元素也可以通过添加额外的逗号来把它丢弃。等号右侧可以是任何可迭代对象：……实际上，我们可以将其与任何可迭代对象一起使用，而不仅限于数组。赋值给等号左侧的任何内容：我们可以在等号左侧使用任何“可以被赋值的”东西。与 .entries() 方法进行循环操作：在前面的章节中我们已经见过了 [Object.entries(obj)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) 方法。 我们可以将 .entries() 方法与解构语法一同使用，来遍历一个对象的“键—值”对。
* 通常，如果数组比左边的列表长，那么“其余”的数组项会被省略。如果我们还想收集其余的数组项 —— 我们可以使用三个点 "..." 来再加一个参数以获取“其余”数组项。
* 如果数组比左边的变量列表短，这里也不会出现报错。缺少的值被认为是 undefined。如果我们想要一个“默认”值给未赋值的变量，我们可以使用 = 来提供。默认值可以是更加复杂的表达式甚至可以是函数调用，这些表达式或函数只会在这个变量未被赋值的时候才会被计算。
* 解构赋值同样适用于对象。在等号右侧应该有一个已经存在的对象，我们想把它拆分到变量中。等号左侧包含了对象相应属性的一个类对象“模式（pattern）”。在最简单的情况下，等号左侧的就是 {...} 中的变量名列表。如果我们想把一个属性赋值给另一个名字的变量，比如把 options.width 属性赋值给名为 w 的变量，那么我们可以使用冒号来设置变量名称。
* 如果对象拥有的属性数量比我们提供的变量数量还多，该怎么办？我们可以只取其中的某一些属性，然后把“剩余的”赋值到其他地方吗？ 我们可以使用剩余模式（pattern），就像我们对数组那样。一些较旧的浏览器不支持此功能（例如，使用 Babel 对其进行填充），但可以在现代浏览器中使用。
* 不使用 let 时的陷阱：在上面的示例中，变量都是在赋值中通过正确方式声明的：let {…} = {…}。当然，我们也可以使用已有的变量，而不用 let，但这里有一个陷阱。问题在于 JavaScript 把主代码流（即不在其他表达式中）的 {...} 当做一个代码块。因此，这里 JavaScript 假定我们有一个代码块，这就是报错的原因。我们需要解构它。 为了告诉 JavaScript 这不是一个代码块，我们可以把整个赋值表达式用括号 (...) 包起来。
* 智能函数参数：有时，一个函数有很多参数，其中大部分的参数都是可选的。在实际开发中存在一个问题就是你怎么记得住这么多参数的顺序。通常集成开发环境工具（IDE）会尽力帮助我们，特别是当代码有良好的文档注释的时候，但是…… 另一个问题就是，当大部分的参数采用默认值就好的情况下，怎么调用这个函数。这太难看了。而且，当我们处理更多参数的时候可读性会变得很差。 解构赋值语法前来救援！ 我们可以把所有参数当作一个对象来传递，然后函数马上把这个对象解构成多个变量。请注意，这种解构假定了 showMenu() 函数确实存在参数。如果我们想让所有的参数都使用默认值，那我们应该传递一个空对象。我们可以通过指定空对象 {} 为整个参数对象的默认值来解决这个问题。
* 不是 getYear()，而是 getFullYear(): 很多 JavaScript 引擎都实现了一个非标准化的方法 getYear()。不推荐使用这个方法。它有时候可能会返回 2 位的年份信息。永远都不要使用它。要获取年份就使用 getFullYear()。
* Date.now(): 如果我们仅仅想要测量时间间隔，我们不需要 Date 对象。 有一个特殊的方法 Date.now()，它会返回当前的时间戳。 它相当于 new Date().getTime()，但它不会创建中间的 Date 对象。因此它更快，而且不会对垃圾处理造成额外的压力。 这种方法很多时候因为方便，又或是因性能方面的考虑而被采用，例如使用 JavaScript 编写游戏或其他的特殊应用场景。
* 想象一下当运行 bench(diffSubtract) 的同时，CPU 还在并行处理其他事务，并且这也会占用资源。然而，运行 bench(diffGetTime) 的时候，并行处理的事务完成了。 这是对于现代多进程操作系统来说的一个非常真实的场景。 结果就是，第一个函数相比于第二个函数，缺少 CPU 资源。这可能导致错误的结论。 为了得到更加可靠的度量，整个度量测试包应该重新运行多次。
* 进行微度量测试时要小心: 现代的 JavaScript 引擎执行了很多优化。与“正常使用”相比，它们可能会改变“人为测试”的结果，特别是在我们对很细微的东西进行度量测试时，例如 operator 的工作方式或内建函数。因此，如果你想好好了解一下性能，请学习 JavaScript 引擎的工作原理。在那之后，你可能再也不需要微度量了。 关于 V8 引擎的大量文章，可以在 [http://mrale.ph](http://mrale.ph/) 找到。
* 和其他系统不同，JavaScript 中时间戳以毫秒为单位，而不是秒。 有时我们需要更加精准的时间度量。JavaScript 自身并没有测量微秒的方法（百万分之一秒），但大多数运行环境会提供。例如：浏览器有 [performance.now()](https://developer.mozilla.org/zh/docs/Web/API/Performance/now) 方法来给出从页面加载开始的以毫秒为单位的微秒数（精确到毫秒的小数点后三位），Node.js 有 microtime 模块以及其他方法。从技术上讲，几乎所有的设备和环境都允许获取更高精度的数值，只是不是通过 Date 对象。
* JSON 是语言无关的纯数据规范，因此一些特定于 JavaScript 的对象属性会被 JSON.stringify 跳过。即： 函数属性（方法）。 Symbol 类型的键和值。 存储 undefined 的属性。通常这很好。如果这不是我们想要的方式，那么我们很快就会看到如何自定义转换方式。 最棒的是支持嵌套对象转换，并且可以自动对其进行转换。
* JSON 可能会非常复杂，对象和数组可以包含其他对象和数组。但是它们必须遵循相同的 JSON 格式。此外，JSON 不支持注释。向 JSON 添加注释无效。 还有另一种名为 [JSON5](https://json5.org/) 的格式，它允许未加引号的键，也允许注释等。但这是一个独立的库，不在语言的规范中。 常规的 JSON 格式严格，并不是因为它的开发者很懒，而是为了实现简单，可靠且快速地实现解析算法。
* 递归通常更短: 递归解通常比迭代解更短。 在这儿，我们可以使用条件运算符 ? 而不是 if 语句，从而使 pow(x, n) 更简洁并且可读性依然很高。
* 任何递归都可以用循环来重写。通常循环变体更有效。 ……但有时重写很难，尤其是函数根据条件使用不同的子调用，然后合并它们的结果，或者分支比较复杂时。而且有些优化可能没有必要，完全不值得。 递归可以使代码更短，更易于理解和维护。并不是每个地方都需要优化，大多数时候我们需要一个好代码，这就是为什么要使用它。
* 
































































































































































































































































































































































































































