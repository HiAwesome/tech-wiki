# [现代 JavaScript 教程](https://zh.javascript.info/)

## 散装笔记

* 兼容性表: JavaScript 是一门还在发展中的语言，定期会添加一些新的功能。要查看它们在基于浏览器的引擎及其他引擎中的支持情况，请看：
  * <http://caniuse.com> —— 每个功能的支持表，例如，查看哪个引擎支持现代加密（cryptography）函数：<http://caniuse.com/#feat=cryptography>。
  * <https://kangax.github.io/compat-table> —— 一份列有语言功能以及引擎是否支持这些功能的表格。
* 多行输入：通常，当我们向控制台输入一行代码后，按 Enter，这行代码就会立即执行。如果想要插入多行代码，请按 Shift+Enter 来进行换行。这样就可以输入长片段的 JavaScript 代码了。
* 即使语句被换行符分隔了，我们依然建议在它们之间加分号。这个规则被社区广泛采用。我们再次强调一下 —— 大部分时候可以省略分号，但是最好不要省略分号，尤其对新手来说。
* "use strict": 这个指令看上去像一个字符串 "use strict" 或者 'use strict'。当它处于脚本文件的顶部时，则整个脚本文件都将以“现代”模式进行工作。
* 当你使用 开发者控制台 运行代码时，请注意它默认是不启动 use strict 的。 有时，当 use strict 会对代码产生一些影响时，你会得到错误的结果。 那么，怎么在控制台中启用 use strict 呢？ 首先，你可以尝试搭配使用 Shift+Enter 按键去输入多行代码，然后将 use strict 放在代码最顶部，就像这样:
  ```text
  'use strict'; <Shift+Enter 换行>
  //  ...你的代码
  <按下 Enter 以运行>
  ```
* 我们应该使用 “use strict” 吗？因此，目前我们欢迎将 "use strict"; 写在脚本的顶部。稍后，当你的代码全都写在了 class 和 module 中时，你则可以将 "use strict"; 这行代码省略掉。
* 函数式语言: 有趣的是，也存在禁止更改变量值的 函数式 编程语言。比如 Scala 或 Erlang。 在这种类型的语言中，一旦值保存在盒子中，就永远存在。如果你试图保存其他值，它会强制创建一个新盒子（声明一个新变量），无法重用之前的变量。虽然第一次看上去有点奇怪，但是这些语言有很大的发展潜力。不仅如此，在某些领域，比如并行计算，这个限制有一定的好处。研究这样的一门语言（即使不打算很快就用上它）有助于开阔视野。
* **重用还是新建？最后一点，有一些懒惰的程序员，倾向于重用现有的变量，而不是声明一个新的变量。 结果是，这个变量就像是被扔进不同东西盒子，但没有改变它的贴纸。现在里面是什么？谁知道呢。我们需要靠近一点，仔细检查才能知道。 这样的程序员节省了一点变量声明的时间，但却在调试代码的时候损失数十倍时间。 额外声明一个变量绝对是利大于弊的。 现代的 JavaScript 压缩器和浏览器都能够很好地对代码进行优化，所以不会产生性能问题。为不同的值使用不同的变量可以帮助引擎对代码进行优化。**
* 数学运算是安全的: 在 JavaScript 中做数学运算是安全的。我们可以做任何事：除以 0，将非数字字符串视为数字，等等。脚本永远不会因为一个致命的错误（“死亡”）而停止。最坏的情况下，我们会得到 NaN 的结果。
* BigInt 兼容性问题：目前 Firefox/Chrome/Edge/Safari 已经支持 BigInt 了，但 IE 还没有。你可以查看 [MDN BigInt 兼容性表](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt#Browser_compatibility) 以了解哪些版本的浏览器已经支持 BigInt 了。
* 反引号是 功能扩展 引号。它们允许我们通过将变量和表达式包装在 ${…} 中，来将它们嵌入到字符串中。${…} 内的表达式会被计算，计算结果会成为字符串的一部分。可以在 ${…} 内放置任何东西：诸如名为 name 的变量，或者诸如 1 + 2 的算数表达式，或者其他一些更复杂的。
* JavaScript 中的 null 仅仅是一个代表“无”、“空”或“值未知”的特殊值。
* 如果一个变量已被声明，但未被赋值，那么它的值就是 undefined.
* object 类型是一个特殊的类型。其他所有的数据类型都被称为“原始类型”，因为它们的值只包含一个单独的内容（字符串、数字或者其他）。相反，object 则用于储存数据集合和更复杂的实体。
* typeof null 的结果为 "object"。这是官方承认的 typeof 的错误，这个问题来自于 JavaScript 语言的早期阶段，并为了兼容性而保留了下来。null 绝对不是一个 object。null 有自己的类型，它是一个特殊值。typeof 的行为在这里是错误的。
* typeof alert 的结果是 "function"，因为 alert 在 JavaScript 语言中是一个函数。我们会在下一章学习函数，那时我们会了解到，在 JavaScript 语言中没有一个特别的 “function” 类型。函数隶属于 object 类型。但是 typeof 会对函数区分对待，并返回 "function"。这也是来自于 JavaScript 语言早期的问题。从技术上讲，这种行为是不正确的，但在实际编程中却非常方便。
* prompt: 显示信息要求用户输入文本。点击确定返回文本，点击取消或按下 Esc 键返回 null。
* confirm: 显示信息等待用户点击确定或取消。点击确定返回 true，点击取消或按下 Esc 键返回 false。
* 我们也可以显式地调用 String(value) 来将 value 转换为字符串类型; 我们也可以使用 Number(value) 显式地将这个 value 转换为 number 类型; 我们也可以通过调用 Boolean(value) 显式地进行转换布尔值。
* 请注意：包含 0 的字符串 "0" 是 true; 一些编程语言（比如 PHP）视 "0" 为 false。但在 JavaScript 中，非空的字符串总是 true。
* 逗号运算符 , 是最少见最不常使用的运算符之一。有时候它会被用来写更简短的代码，因此为了能够理解代码，我们需要了解它。逗号运算符能让我们处理多个语句，使用 , 将它们分开。每个语句都运行了，但是只有最后的语句的结果会被返回。为什么我们需要这样一个运算符，它只返回最后一个值呢？有时候，人们会使用它把几个行为放在一行上来进行复杂的运算。这样的技巧在许多 JavaScript 框架中都有使用，这也是为什么我们提到它。但是通常它并不能提升代码的可读性，使用它之前，我们要想清楚。
* 严格相等运算符 === 在进行比较时不会做任何的类型转换。
* 对 null 和 undefined 进行比较:当使用 null 或 undefined 与其他值进行比较时，其返回结果常常出乎你的意料。 当使用严格相等 === 比较二者时它们不相等，因为它们属于不同的类型。当使用非严格相等 == 比较二者时 JavaScript 存在一个特殊的规则，会判定它们相等。它们俩就像“一对恋人”，仅仅等于对方而不等于其他任何的值（只在非严格相等下成立）。
* 或运算寻找第一个真值: `result = value1 || value2 || value3;` 从左到右依次计算操作数。 处理每一个操作数时，都将其转化为布尔值。如果结果是 true，就停止计算，返回这个操作数的初始值。 如果所有的操作数都被计算过（也就是，转换结果都是 false），则返回最后一个操作数。
* 与运算寻找第一个假值: `result = value1 && value2 && value3;` 从左到右依次计算操作数。 在处理每一个操作数时，都将其转化为布尔值。如果结果是 false，就停止计算，并返回这个操作数的初始值。 如果所有的操作数都被计算过（例如都是真值），则返回最后一个操作数。
* 两个非运算 !! 有时候用来将某个值转化为布尔类型: `alert( !!"non-empty string" ); // true`, `alert( !!null ); // false`, 也就是，第一个非运算将该值转化为布尔类型并取反，第二个非运算再次取反。最后我们就得到了一个任意值到布尔值的转化。
* 空值合并运算符 '??': a ?? b 的结果是：如果 a 是已定义的，则结果为 a，如果 a 不是已定义的，则结果为 b。 换句话说，如果第一个参数不是 null/undefined，则 ?? 返回第一个参数。否则，返回第二个参数。空值合并运算符并不是什么全新的东西。它只是一种获得两者中的第一个“已定义的”值的不错的语法。另一方面，空值合并运算符 ?? 是最近才被添加到 JavaScript 中的，它的出现是因为人们对 || 不太满意。 它们之间重要的区别是： || 返回第一个 真 值。 ?? 返回第一个 已定义的 值。出于安全原因，JavaScript 禁止将 ?? 运算符与 && 和 || 运算符一起使用，除非使用括号明确指定了优先级。这个限制无疑是值得商榷的，它被添加到语言规范中是为了避免人们从 || 切换到 ?? 时的编程错误。 可以明确地使用括号来解决这个问题。
* break/continue 支持循环前的标签。标签是 break/continue 跳出嵌套循环以转到外部的唯一方法。
* 全局变量：任何函数之外声明的变量，例如上述代码中的外部变量 userName，都被称为 全局 变量。 全局变量在任意函数中都是可见的（除非被局部变量遮蔽）。 减少全局变量的使用是一种很好的做法。现代的代码有很少甚至没有全局变量。大多数变量存在于它们的函数中。但是有时候，全局变量能够用于存储项目级别的数据。
* 空值的 return 或没有 return 的函数返回值为 undefined：如果函数无返回值，它就会像返回 undefined 一样。
* 不要在 return 与返回值之间添加新行：对于 return 的长表达式，可能你会很想将其放在单独一行，但这不行，因为 JavaScript 默认会在 return 之后加上分号。因此，实际上它的返回值变成了空值。 如果我们想要将返回的表达式写成跨多行的形式，那么应该在 return 的同一行开始写此表达式。
* 一个函数 —— 一个行为：一个函数应该只包含函数名所指定的功能，而不是做更多与函数名无关的功能。 两个独立的行为通常需要两个函数，即使它们通常被一起调用（在这种情况下，我们可以创建第三个函数来调用这两个函数）。 有几个违反这一规则的例子： getAge —— 如果它通过 alert 将 age 显示出来，那就有问题了（只应该是获取）。 createForm —— 如果它包含修改文档的操作，例如向文档添加一个表单，那就有问题了（只应该创建表单并返回）。 checkPermission —— 如果它显示 access granted/denied 消息，那就有问题了（只应执行检查并返回结果）。 这些例子假设函数名前缀具有通用的含义。你和你的团队可以自定义这些函数名前缀的含义，但是通常都没有太大的不同。无论怎样，你都应该对函数名前缀的含义、带特定前缀的函数可以做什么以及不可以做什么有深刻的了解。所有相同前缀的函数都应该遵守相同的规则。并且，团队成员应该形成共识。
* 非常短的函数命名：常用的函数有时会有非常短的名字。 例如，[jQuery](http://jquery.com/) 框架用 $ 定义一个函数。[LoDash](http://lodash.com/) 库的核心函数用 _ 命名。 这些都是例外，一般而言，函数名应简明扼要且具有描述性。
* 函数是一个值：重申一次：无论函数是如何创建的，函数都是一个值。在某些编程语言中，只要提到函数的名称都会导致函数的调用执行，但 JavaScript 可不是这样。 在 JavaScript 中，函数是一个值，所以我们可以把它当成值对待。
* 回调函数：让我们多举几个例子，看看如何将函数作为值来传递以及如何使用函数表达式。 我们写一个包含三个参数的函数 ask(question, yes, no).
  ```text
  function ask(question, yes, no) {
    if (confirm(question)) yes()
    else no();
  }
  
  ask(
    "Do you agree?",
    function() { alert("You agreed."); },
    function() { alert("You canceled the execution."); }
  );
  ```
* 一个函数是表示一个“行为”的值：字符串或数字等常规值代表 数据。 函数可以被视为一个 行为（action）。 我们可以在变量之间传递它们，并在需要时运行。
* 什么时候选择函数声明与函数表达式？根据经验，当我们需要声明一个函数时，首先考虑函数声明语法。它能够为组织代码提供更多的灵活性。因为我们可以在声明这些函数之前调用这些函数。 这对代码可读性也更好，因为在代码中查找 function f(…) {…} 比 let f = function(…) {…} 更容易。函数声明更“醒目”。 ……但是，如果由于某种原因而导致函数声明不适合我们（我们刚刚看过上面的例子），那么应该使用函数表达式。
* 一开始，箭头函数可能看起来并不熟悉，也不容易读懂，但一旦我们看习惯了之后，这种情况很快就会改变。 箭头函数对于简单的单行行为（action）来说非常方便，尤其是当我们懒得打太多字的时候。对于一行代码的函数来说，箭头函数是相当方便的。它具体有两种：不带花括号：(...args) => expression — 右侧是一个表达式：函数计算表达式并返回其结果。 带花括号：(...args) => { body } — 花括号允许我们在函数中编写多个语句，但是我们需要显式地 return 来返回一些内容。
* 条件断点：在行号上 右键单击 允许你创建一个 条件 断点。只有当给定的表达式为真（即满足条件）时才会被触发。当我们需要在特定的变量值或参数的情况下暂停程序执行时，这种调试方法就很有用了。
* Continue to here: 在代码中的某一行上右键，在显示的关联菜单（context menu）中点击一个非常有用的名为 “Continue to here” 的选项。 当你想要向前移动很多步到某一行为止，但是又懒得设置一个断点时非常的方便。
* 没有什么规则是“必须”的：没有什么规则是“刻在石头上”的。这些是风格偏好，而不是宗教教条。
* 分号：每一个语句后面都应该有一个分号。即使它可以被跳过。 有一些编程语言的分号确实是可选的，那些语言中也很少使用分号。但是在 JavaScript 中，极少数情况下，换行符有时不会被解释为分号，这时代码就容易出错。更多内容请参阅 [代码结构](https://zh.javascript.info/structure#semicolon) 一章的内容。 如果你是一个有经验的 JavaScript 程序员，你可以选择像 [StandardJS](https://standardjs.com/readme-zhcn.html) 这样的无分号的代码风格。否则，最好使用分号以避免可能出现的陷阱。大多数开发人员都应该使用分号。
* 本章描述的（和提到的代码风格指南中的）所有语法规则，都旨在帮助你提高代码可读性。它们都是值得商榷的。 当我们思考如何写“更好”的代码的时候，我们应该问自己的问题是：“什么可以让代码可读性更高，更容易被理解？”和“什么可以帮助我们避免错误？”这些是我们讨论和选择代码风格时要牢记的主要原则。 阅读流行的代码风格指南，可以帮助你了解有关代码风格的变化趋势和最佳实践的最新想法。
* 好的注释：所以，解释性注释通常来说都是不好的。那么哪一种注释才是好的呢？ 
  * 描述架构：对组件进行高层次的整体概括，它们如何相互作用、各种情况下的控制流程是什么样的……简而言之 —— 代码的鸟瞰图。有一个专门用于构建代码的高层次架构图，以对代码进行解释的特殊编程语言 [UML](http://wikipedia.org/wiki/Unified_Modeling_Language), 绝对值得学习。 
  * 记录函数的参数和用法：有一个专门用于记录函数的语法 [JSDoc](http://en.wikipedia.org/wiki/JSDoc): 用法、参数和返回值。这种注释可以帮助我们理解函数的目的，并且不需要研究其内部的实现代码，就可以直接正确地使用它。
  * 为什么任务以这种方式解决？写了什么代码很重要。但是为什么 不 那样写可能对于理解正在发生什么更重要。为什么任务是通过这种方式解决的？代码并没有给出答案。 如果有很多种方法都可以解决这个问题，为什么偏偏是这一种？尤其当它不是最显而易见的那一种的时候。解决方案的注释非常的重要。它们可以帮助你以正确的方式继续开发。
  * 代码有哪些巧妙的特性？它们被用在了什么地方？ 如果代码存在任何巧妙和不显而易见的方法，那绝对需要注释。
* 自动化测试意味着测试是独立于代码的。它们以各种方式运行我们的函数，并将结果与预期结果进行比较。
* 在 BDD 中，规范先行，实现在后。最后我们同时拥有了规范和代码。有了规范，我们可以安全地改进、修改甚至重写函数，并确保它仍然正确地工作。 这在一个函数会被用在多个地方的大型项目中尤其重要。当我们改变这样一个函数时，没有办法手动检查每个使用它们的地方是否仍旧正确。自动化测试则有助于避免这样的问题！ 如果这个项目被测试代码覆盖了，就不会出现这种问题。在任何修改之后，我们都可以运行测试，并在几秒钟内看到大量的检查。 另外，一个经过良好测试的代码通常都有更好的架构。 当然，这是因为覆盖了自动化测试的代码更容易修改和改进。但还有另一个原因。 要编写测试，代码的组织方式应确保每个函数都有一个清晰描述的任务、定义良好的输入和输出。这意味着从一开始就有一个好的架构。 在实际开发中有时候可能并不容易，有时很难在写实际代码之前编写规范，因为还不清楚它应该如何表现。但一般来说，编写测试使得开发更快更稳定。
* 作为程序员，我们希望使用最新的特性。好东西越多越好！ 另一方面，如何让我们现代的代码在还不支持最新特性的旧引擎上工作？ 有两个工作可以做到这一点： 转译器（Transpilers）。 垫片（Polyfills）。
* 通常，开发者会在自己的计算机上运行转译器，然后将转译后的代码部署到服务器。 说到名字，[Babel](https://babeljs.io/) 是最著名的转译器之一。 现代项目构建系统，例如 [webpack](http://webpack.github.io/), 提供了在每次代码更改时自动运行转译器的方法，因此很容易将代码转译集成到开发过程中。
* JavaScript 是一种高度动态的语言，脚本可以添加/修改任何函数，甚至包括内建函数。 两个有趣的 polyfill 库： [core js](https://github.com/zloirock/core-js) 支持了很多特性，允许只包含需要的特性。 [polyfill.io](http://polyfill.io/) 提供带有 polyfill 的脚本的服务，具体取决于特性和用户的浏览器。
* 谷歌的 Chrome 浏览器通常是对最新的语言特性的支持情况最好的浏览器，如果教程的示例运行失败，请尝试使用 Chrome 浏览器。不过，教程中的大多数示例都适用于任意的现代浏览器。
* 方括号: 对于多词属性，点操作就不能用了。JavaScript 理解不了。它认为我们在处理 user.likes，然后在遇到意外的 birds 时给出了语法错误。 点符号要求 key 是有效的变量标识符。这意味着：不包含空格，不以数字开头，也不包含特殊字符（允许使用 $ 和 _）。 有另一种方法，就是使用方括号，可用于任何字符串
* 现在一切都可行了。请注意方括号中的字符串要放在引号中，单引号或双引号都可以。 方括号同样提供了一种可以通过任意表达式来获取属性名的方法 —— 跟语义上的字符串不同。 在这里，变量 key 可以是程序运行时计算得到的，也可以是根据用户的输入得到的。然后我们可以用它来访问属性。这给了我们很大的灵活性。
* 计算属性：当创建一个对象时，我们可以在对象字面量中使用方括号。这叫做 计算属性。计算属性的含义很简单：\[fruit\] 含义是属性名应该从 fruit 变量中获取。 所以，如果一个用户输入 "apple"，bag 将变为 {apple: 5}。
* 方括号比点符号更强大。它允许任何属性名和变量，但写起来也更加麻烦。所以，大部分时间里，当属性名是已知且简单的时候，就使用点符号。如果我们需要一些更复杂的内容，那么就用方括号。
* 属性值简写：在实际开发中，我们通常用已存在的变量当做属性名。属性名跟变量名一样。这种通过变量生成属性的应用场景很常见，在这有一种特殊的 属性值缩写 方法，使属性名变得更短。 可以用 name 来代替 name:name
* 属性名称限制：我们已经知道，变量名不能是编程语言的某个保留字，如 “for”、“let”、“return” 等…… 但对象的属性名并不受此限制。简而言之，属性命名没有限制。属性名可以是任何字符串或者 symbol（一种特殊的标志符类型，将在后面介绍）。 其他类型会被自动地转换为字符串。 例如，当数字 0 被用作对象的属性的键时，会被转换为字符串 "0"
* 属性存在性测试，“in” 操作符：相比于其他语言，JavaScript 的对象有一个需要注意的特性：能够被访问任何属性。即使属性不存在也不会报错！ 读取不存在的属性只会得到 undefined。所以我们可以很容易地判断一个属性是否存在。这里还有一个特别的，检查属性是否存在的操作符 "in"。请注意，in 的左边必须是 属性名。通常是一个带引号的字符串。 如果我们省略引号，就意味着左边是一个变量，它应该包含要判断的实际属性名。为何会有 in 运算符呢？与 undefined 进行比较来判断还不够吗？ 确实，大部分情况下与 undefined 进行比较来判断就可以了。但有一个例外情况，这种比对方式会有问题，但 in 运算符的判断结果仍是对的。 那就是属性存在，但存储的值是 undefined 的时候。
* 像对象一样排序：对象有顺序吗？换句话说，如果我们遍历一个对象，我们获取属性的顺序是和属性添加时的顺序相同吗？这靠谱吗？ 简短的回答是：“有特别的顺序”：整数属性会被进行排序，其他属性则按照创建的顺序显示。
* 整数属性？那是什么？这里的“整数属性”指的是一个可以在不做任何更改的情况下与一个整数进行相互转换的字符串。 所以，“49” 是一个整数属性名，因为我们把它转换成整数，再转换回来，它还是一样的。但是 “+49” 和 “1.2” 就不行了。……此外，如果属性名不是整数，那它们就按照创建时的顺序来排序。
* 深层克隆: 为了解决这个问题，我们应该使用一个拷贝循环来检查 user\[key] 的每个值，如果它是一个对象，那么也复制它的结构。这就是所谓的“深拷贝”。 我们可以使用递归来实现它。或者为了不重复造轮子，采用现有的实现，例如 [lodash](https://lodash.com/) 库的 [_.cloneDeep(obj)](https://lodash.com/docs#cloneDeep).
* [垃圾回收](https://zh.javascript.info/garbage-collection): JavaScript 中主要的内存管理概念是 可达性。 **这里有大量图说明可达性概念。**  一些优化建议： 
  * 分代收集（Generational collection）—— 对象被分成两组：“新的”和“旧的”。许多对象出现，完成它们的工作并很快死去，它们可以很快被清理。那些长期存活的对象会变得“老旧”，而且被检查的频次也会减少。 
  * 增量收集（Incremental collection）—— 如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟。所以引擎试图将垃圾收集工作分成几部分来做。然后将这几部分会逐一进行处理。这需要它们之间有额外的标记来追踪变化，但是这样会有许多微小的延迟而不是一个大的延迟。 
  * 闲时收集（Idle-time collection）—— 垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。
* 面向对象编程: 当我们在代码中用对象表示实体时，就是所谓的 面向对象编程，简称为 “OOP”。 OOP 是一门大学问，本身就是一门有趣的科学。怎样选择合适的实体？如何组织它们之间的交互？这就是架构，有很多关于这方面的书，例如 E. Gamma、R. Helm、R. Johnson 和 J. Vissides 所著的《设计模式：可复用面向对象软件的基础》，G. Booch 所著的《面向对象分析与设计》等。
* “this” 不受限制: 在 JavaScript 中，this 关键字与其他大多数编程语言中的不同。JavaScript 中的 this 可以用于任何函数，即使它不是对象的方法。this 的值是在代码运行时计算出来的，它取决于代码上下文。
* 在没有对象的情况下调用：this == undefined 在这种情况下，严格模式下的 this 值为 undefined。如果我们尝试访问 this.name，将会报错。 在非严格模式的情况下，this 将会是 全局对象（浏览器中的 window，我们稍后会在 [全局对象](https://zh.javascript.info/global-object) 一章中学习它）。这是一个历史行为，"use strict" 已经将其修复了。 通常这种调用是程序出错了。如果在一个函数内部有 this，那么通常意味着它是在对象上下文环境中被调用的。
* 解除 this 绑定的后果: 如果你经常使用其他的编程语言，那么你可能已经习惯了“绑定 this”的概念，即在对象中定义的方法总是有指向该对象的 this。 在 JavaScript 中，this 是“自由”的，它的值是在调用时计算出来的，它的值并不取决于方法声明的位置，而是取决于在“点符号前”的是什么对象。 在运行时对 this 求值的这个概念既有优点也有缺点。一方面，函数可以被重用于不同的对象。另一方面，更大的灵活性造成了更大的出错的可能。 这里我们的立场并不是要评判编程语言的这个设计是好是坏。而是要了解怎样使用它，如何趋利避害。
* 箭头函数没有自己的 “this”: 箭头函数有些特别：它们没有自己的 this。如果我们在这样的函数中引用 this，this 值取决于外部“正常的”函数。
* 当一个函数被使用 new 操作符执行时，它按照以下步骤：
  1. 一个新的空对象被创建并分配给 this。
  2. 函数体执行。通常它会修改 this，为其添加新的属性。 
  3. 返回 this 的值。
* 让我们再强调一遍 —— 从技术上讲，任何函数（除了箭头函数，它没有自己的 this）都可以用作构造器。即可以通过 new 来运行，它会执行上面的算法。“首字母大写”是一个共同的约定，以明确表示一个函数将被使用 new 来运行。
* 在一个函数内部，我们可以使用 new.target 属性来检查它是否被使用 new 进行调用了。这种方法有时被用在库中以使语法更加灵活。这样人们在调用函数时，无论是否使用了 new，程序都能工作。 不过，到处都使用它并不是一件好事，因为省略了 new 使得很难观察到代码中正在发生什么。而通过 new 我们都可以知道这创建了一个新对象。
* 构造函数，或简称构造器，就是常规函数，但大家对于构造器有个共同的约定，就是其命名首字母要大写。 构造函数只能使用 new 来调用。这样的调用意味着在开始时创建了空的 this，并在最后返回填充了值的 this。
* 可选链 ?. 是一种访问嵌套对象属性的安全的方式。即使中间的属性不存在，也不会出现错误。
* 如果可选链 ?. 前面的值为 undefined 或者 null，它会停止运算并返回 undefined。
* 不要过度使用可选链: 我们应该只将 ?. 使用在一些东西可以不存在的地方。 例如，如果根据我们的代码逻辑，user 对象必须存在，但 address 是可选的，那么我们应该这样写 user.address?.street，而不是这样 user?.address?.street。 所以，如果 user 恰巧因为失误变为 undefined，我们会看到一个编程错误并修复它。否则，代码中的错误在不恰当的地方被消除了，这会导致调试更加困难。
* ?. 前的变量必须已声明（例如 let/const/var user 或作为一个函数参数）。可选链仅适用于已声明的变量。 其它变体：?.()，?.[] 可选链 ?. 不是一个运算符，而是一个特殊的语法结构。它还可以与函数和方括号一起使用。 例如，将 ?.() 用于调用一个可能不存在的函数。 如果我们想使用方括号 [] 而不是点符号 . 来访问属性，语法 ?.[] 也可以使用。跟前面的例子类似，它允许从一个可能不存在的对象上安全地读取属性。
* 我们可以使用 ?. 来安全地读取或删除，但不能写入: 可选链 ?. 不能用在赋值语句的左侧。
* 可选链 ?. 语法有三种形式：
  * obj?.prop —— 如果 obj 存在则返回 obj.prop，否则返回 undefined。
  * obj?.\[prop\] —— 如果 obj 存在则返回 obj\[prop\]，否则返回 undefined。
  * obj.method?.() —— 如果 obj.method 存在则调用 obj.method()，否则返回 undefined。
* Symbol 不会被自动转换为字符串: JavaScript 中的大多数值都支持字符串的隐式转换。例如，我们可以 alert 任何值，都可以生效。Symbol 比较特殊，它不会被自动转换。
* “隐藏”属性: Symbol 允许我们创建对象的“隐藏”属性，代码的任何其他部分都不能意外访问或重写这些属性。
* 对象字面量中的 Symbol: 如果我们要在对象字面量 {...} 中使用 Symbol，则需要使用方括号把它括起来。
* 全局 symbol: 正如我们所看到的，通常所有的 Symbol 都是不同的，即使它们有相同的名字。但有时我们想要名字相同的 Symbol 具有相同的实体。例如，应用程序的不同部分想要访问的 Symbol "id" 指的是完全相同的属性。 为了实现这一点，这里有一个 全局 Symbol 注册表。我们可以在其中创建 Symbol 并在稍后访问它们，它可以确保每次访问相同名字的 Symbol 时，返回的都是相同的 Symbol。 要从注册表中读取（不存在则创建）Symbol，请使用 Symbol.for(key)。 该调用会检查全局注册表，如果有一个描述为 key 的 Symbol，则返回该 Symbol，否则将创建一个新 Symbol（Symbol(key)），并通过给定的 key 将其存储在注册表中。
* 这听起来像 Ruby: 在一些编程语言中，例如 Ruby，每个名字都有一个 Symbol。 正如我们所看到的，在 JavaScript 中，全局 Symbol 也是这样的。
* 系统 Symbol: JavaScript 内部有很多“系统” Symbol，我们可以使用它们来微调对象的各个方面。例如，Symbol.toPrimitive 允许我们将对象描述为原始值转换。我们很快就会看到它的使用。 当我们研究相应的语言特征时，我们对其他的 Symbol 也会慢慢熟悉起来。
* Symbol 有两个主要的使用场景： “隐藏” 对象属性。 如果我们想要向“属于”另一个脚本或者库的对象添加一个属性，我们可以创建一个 Symbol 并使用它作为属性的键。Symbol 属性不会出现在 for..in 中，因此它不会意外地被与其他属性一起处理。并且，它不会被直接访问，因为另一个脚本没有我们的 symbol。因此，该属性将受到保护，防止被意外使用或重写。 因此我们可以使用 Symbol 属性“秘密地”将一些东西隐藏到我们需要的对象中，但其他地方看不到它。 JavaScript 使用了许多系统 Symbol，这些 Symbol 可以作为 Symbol.* 访问。我们可以使用它们来改变一些内建行为。例如，在本教程的后面部分，我们将使用 Symbol.iterator 来进行 [迭代](https://zh.javascript.info/iterable) 操作，使用 Symbol.toPrimitive 来设置 [对象原始值的转换](https://zh.javascript.info/object-toprimitive) 等等。 从技术上说，Symbol 不是 100% 隐藏的。有一个内建方法 [Object.getOwnPropertySymbols](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols)(obj) 允许我们获取所有的 Symbol。还有一个名为 [Reflect.ownKeys(obj)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys) 的方法可以返回一个对象的 所有 键，包括 Symbol。所以它们并不是真正的隐藏。但是大多数库、内建方法和语法结构都没有使用这些方法。
* 对象 — 原始值转换，为了进行转换，JavaScript 尝试查找并调用三个对象方法：
  1. 调用 obj\[Symbol.toPrimitive\](hint) —— 带有 symbol 键 Symbol.toPrimitive（系统 symbol）的方法，如果这个方法存在的话， 
  2. 否则，如果 hint 是 "string" —— 尝试 obj.toString() 和 obj.valueOf()，无论哪个存在。 
  3. 否则，如果 hint 是 "number" 或 "default" —— 尝试 obj.valueOf() 和 obj.toString()，无论哪个存在。
* 历史原因：由于历史原因，如果 toString 或 valueOf 返回一个对象，则不会出现 error，但是这种值会被忽略（就像这种方法根本不存在）。这是因为在 JavaScript 语言发展初期，没有很好的 “error” 的概念。 相反，Symbol.toPrimitive 必须 返回一个原始值，否则就会出现 error。
* 关于对象的最好的事儿之一是，我们可以把一个函数作为对象的属性存储到对象中。
* 以下是 str.toUpperCase() 中实际发生的情况： 
  1. 字符串 str 是一个原始值。因此，在访问其属性时，会创建一个包含字符串字面值的特殊对象，并且具有有用的方法，例如 toUpperCase()。 
  2. 该方法运行并返回一个新的字符串（由 alert 显示）。 
  3. 特殊对象被销毁，只留下原始值 str。
* 构造器 String/Number/Boolean 仅供内部使用: 像 Java 这样的一些语言允许我们使用 new Number(1) 或 new Boolean(false) 等语法，明确地为原始类型创建“对象包装器”。 在 JavaScript 中，由于历史原因，这也是可以的，但极其 不推荐。因为这样会出问题。
* null/undefined 没有任何方法: 特殊的原始类型 null 和 undefined 是例外。它们没有对应的“对象包装器”，也没有提供任何方法。从某种意义上说，它们是“最原始的”。
* 在 JavaScript 中，我们可以通过在数字后面附加字母 "e" 并指定零的个数来缩短数字。
* [十六进制](https://en.wikipedia.org/wiki/Hexadecimal) 数字在 JavaScript 中被广泛用于表示颜色，编码字符以及其他许多东西。所以自然地，有一种较短的写方法：0x，然后是数字。
* 使用两个点来调用一个方法：请注意 123456..toString(36) 中的两个点不是打错了。如果我们想直接在一个数字上调用一个方法，比如上面例子中的 toString，那么我们需要在它后面放置两个点 ..。 如果我们放置一个点：123456.toString(36)，那么就会出现一个 error，因为 JavaScript 语法隐含了第一个点之后的部分为小数部分。如果我们再放一个点，那么 JavaScript 就知道小数部分为空，现在使用该方法。 也可以写成 (123456).toString(36)。
* 一个数字以其二进制的形式存储在内存中，一个 1 和 0 的序列。但是在十进制数字系统中看起来很简单的 0.1，0.2 这样的小数，实际上在二进制形式中是无限循环小数。 换句话说，什么是 0.1？0.1 就是 1 除以 10，1/10，即十分之一。在十进制数字系统中，这样的数字表示起来很容易。将其与三分之一进行比较：1/3。三分之一变成了无限循环小数 0.33333(3)。 在十进制数字系统中，可以保证以 10 的整数次幂作为除数能够正常工作，但是以 3 作为除数则不能。也是同样的原因，在二进制数字系统中，可以保证以 2 的整数次幂作为除数时能够正常工作，但 1/10 就变成了一个无限循环的二进制小数。 使用二进制数字系统无法 精确 存储 0.1 或 0.2，就像没有办法将三分之一存储为十进制小数一样。 IEEE-754 数字格式通过将数字舍入到最接近的可能数字来解决此问题。这些舍入规则通常不允许我们看到“极小的精度损失”，但是它确实存在。不仅仅是 JavaScript, 许多其他编程语言也存在同样的问题。 PHP，Java，C，Perl，Ruby 给出的也是完全相同的结果，因为它们基于的是相同的数字格式。
* 与 Object.is 进行比较: 有一个特殊的内建方法 Object.is，它类似于 === 一样对值进行比较，但它对于两种边缘情况更可靠： 它适用于 NaN：Object.is(NaN，NaN) === true，这是件好事。 值 0 和 -0 是不同的：Object.is(0，-0) === false，从技术上讲这是对的，因为在内部，数字的符号位可能会不同，即使其他所有位均为零。 在所有其他情况下，Object.is(a，b) 与 a === b 相同。 这种比较方式经常被用在 JavaScript 规范中。当内部算法需要比较两个值是否完全相同时，它使用 Object.is（内部称为 [SameValue](https://tc39.es/ecma262/#sec-samevalue) ）。
* 在 JavaScript 中，文本数据被以字符串形式存储，单个字符没有单独的类型。 字符串的内部格式始终是 [UTF-16](https://en.wikipedia.org/wiki/UTF-16), 它不依赖于页面编码。
* length 是一个属性: 掌握其他编程语言的人，有时会错误地调用 str.length() 而不是 str.length。这是行不通的。 请注意 str.length 是一个数字属性，而不是函数。后面不需要添加括号。
* 实际上，这意味着一件很简单的事儿：对于 32-bit 整数，~n 等于 -(n+1)。正如我们看到这样，只有当 n == -1 时，~n 才为零（适用于任何 32-bit 带符号的整数 n）。 因此，仅当 indexOf 的结果不是 -1 时，检查 if ( ~str.indexOf("...") ) 才为真。换句话说，当有匹配时。 人们用它来简写 indexOf 检查。通常不建议以非显而易见的方式使用语言特性，但这种特殊技巧在旧代码中仍被广泛使用，所以我们应该理解它。 只要记住：if (~str.indexOf(...)) 读作 “if found”。 确切地说，由于 ~ 运算符将大数字截断为 32 位，因此存在给出 0 的其他数字，最小的数字是 ~4294967295=0。这使得这种检查只有在字符串没有那么长的情况下才是正确的。 现在我们只会在旧的代码中看到这个技巧，因为现代 JavaScript 提供了 .includes 方法（见下文）。
* slice, substr, substring 使用哪一个？它们可以完成这项工作。形式上，substr 有一个小缺点：它不是在 JavaScript 核心规范中描述的，而是在附录 B 中，它涵盖了主要由于历史原因而存在的仅浏览器特性。因此，非浏览器环境可能无法支持它。但实际上它在任何地方都有效。 相较于其他两个变体，slice 稍微灵活一些，它允许以负值作为参数并且写法更简短。因此仅仅记住这三种方法中的 slice 就足够了。
* 请注意，代理对的各部分没有任何意义。因此，上述示例中的 alert 显示的实际上是垃圾信息。 技术角度来说，代理对也是可以通过它们的代码检测到的：如果一个字符的代码在 0xd800..0xdbff 范围内，那么它是代理对的第一部分。下一个字符（第二部分）必须在 0xdc00..0xdfff 范围中。这些范围是按照标准专门为代理对保留的。
* JavaScript 中的数组既可以用作队列，也可以用作栈。它们允许你从首端/末端来添加/删除元素。 这在计算机科学中，允许这样的操作的数据结构被称为 [双端队列（deque）](https://en.wikipedia.org/wiki/Double-ended_queue).
* 数组是一种特殊的对象。使用方括号来访问属性 arr\[0] 实际上是来自于对象的语法。它其实与 obj\[key] 相同，其中 arr 是对象，而数字用作键（key）。 它们扩展了对象，提供了特殊的方法来处理有序的数据集合以及 length 属性。但从本质上讲，它仍然是一个对象。 记住，在 JavaScript 中只有 8 种基本的数据类型（详见 数据类型 一章）。数组是一个对象，因此其行为也像一个对象。
* 但是数组真正特殊的是它们的内部实现。JavaScript 引擎尝试把这些元素一个接一个地存储在连续的内存区域，就像本章的插图显示的一样，而且还有一些其它的优化，以使数组运行得非常快。 但是，如果我们不像“有序集合”那样使用数组，而是像常规对象那样使用数组，这些就都不生效了。因为数组是基于对象的。我们可以给它们添加任何属性。 但是 Javascript 引擎会发现，我们在像使用常规对象一样使用数组，那么针对数组的优化就不再适用了，然后对应的优化就会被关闭，这些优化所带来的优势也就荡然无存了。
* 数组误用的几种方式: 添加一个非数字的属性，比如 arr.test = 5。 制造空洞，比如：添加 arr\[0]，然后添加 arr\[1000] (它们中间什么都没有)。 以倒序填充数组，比如 arr\[1000]，arr\[999] 等等。 请将数组视为作用于 有序数据 的特殊结构。它们为此提供了特殊的方法。数组在 JavaScript 引擎内部是经过特殊调整的，使得更好地作用于连续的有序数据，所以请以正确的方式使用数组。如果你需要任意键值，那很有可能实际上你需要的是常规对象 {}。
* 性能: push/pop 方法运行的比较快，而 shift/unshift 比较慢。
* 通常来说，我们不应该用 for..in 来处理数组。会有一些潜在问题存在： 
  * for..in 循环会遍历 所有属性，不仅仅是这些数字属性。 在浏览器和其它环境中有一种称为“类数组”的对象，它们 看似是数组。也就是说，它们有 length 和索引属性，但是也可能有其它的非数字的属性和方法，这通常是我们不需要的。for..in 循环会把它们都列出来。所以如果我们需要处理类数组对象，这些“额外”的属性就会存在问题。 
  * for..in 循环适用于普通对象，并且做了对应的优化。但是不适用于数组，因此速度要慢 10-100 倍。当然即使是这样也依然非常快。只有在遇到瓶颈时可能会有问题。但是我们仍然应该了解这其中的不同。
* 关于 “length”: 当我们修改数组的时候，length 属性会自动更新。准确来说，它实际上不是数组里元素的个数，而是最大的数字索引值加一。
* length 属性的另一个有意思的点是它是可写的。 如果我们手动增加它，则不会发生任何有趣的事儿。但是如果我们减少它，数组就会被截断。该过程是不可逆的。所以，清空数组最简单的方法就是：arr.length = 0;。
* 不要使用 == 比较数组：JavaScript 中的数组与其它一些编程语言的不同，不应该使用 == 运算符比较 JavaScript 中的数组。 该运算符不会对数组进行特殊处理，它会像处理任意对象那样处理数组。
* [arr.splice](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/splice) 方法可以说是处理数组的瑞士军刀。它可以做所有事情：添加，删除和插入元素。
* [arr.slice](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/slice) 方法比 arr.splice 简单得多。它会返回一个新数组，将所有从索引 start 到 end（不包括 end）的数组项复制到一个新的数组。start 和 end 都可以是负数，在这种情况下，从末尾计算索引。 它和字符串的 str.slice 方法有点像，就是把子字符串替换成子数组。
* [arr.concat](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/concat) 创建一个新数组，其中包含来自于其他数组和其他项的值。它接受任意数量的参数 —— 数组或值都可以。 结果是一个包含来自于 arr，然后是 arg1，arg2 的元素的新数组。 如果参数 argN 是一个数组，那么其中的所有元素都会被复制。否则，将复制参数本身。通常，它只复制数组中的元素。其他对象，即使它们看起来像数组一样，但仍然会被作为一个整体添加。……但是，如果类似数组的对象具有 Symbol.isConcatSpreadable 属性，那么它就会被 concat 当作一个数组来处理：此对象中的元素将被添加。
* [arr.forEach](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach) 方法允许为数组的每个元素都运行一个函数。该函数的结果（如果它有返回）会被抛弃和忽略。
* [arr.map](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/map) 方法是最有用和经常使用的方法之一。 它对数组的每个元素都调用函数，并返回结果数组。
* [arr.sort](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/sort) 方法对数组进行 原位（in-place） 排序，更改元素的顺序。(译注：原位是指在此数组内，而非生成一个新数组。) 它还返回排序后的数组，但是返回值通常会被忽略，因为修改了 arr 本身。 arr 可以是由任何内容组成的数组，对吗？它可能包含数字、字符串、对象或其他任何内容。我们有一组 一些元素。要对其进行排序，我们需要一个 排序函数 来确认如何比较这些元素。默认是按字符串进行排序的。 arr.sort(fn) 方法实现了通用的排序算法。我们不需要关心它的内部工作原理（大多数情况下都是经过 [快速排序](https://en.wikipedia.org/wiki/Quicksort) 或 [Timsort](https://en.wikipedia.org/wiki/Timsort) 算法优化的）。它将遍历数组，使用提供的函数比较其元素并对其重新排序，我们所需要的就是提供执行比较的函数 fn。
* 比较函数可以返回任何数字：实际上，比较函数只需要返回一个正数表示“大于”，一个负数表示“小于”。 通过这个原理我们可以编写更短的函数：`arr.sort(function(a, b) { return a - b; });`  这里使用箭头函数会更加简洁：`arr.sort( (a, b) => a - b );`.  
* 当我们需要遍历一个数组时 —— 我们可以使用 forEach，for 或 for..of。 当我们需要遍历并返回每个元素的数据时 —— 我们可以使用 map。 [arr.reduce](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce) 方法和 [arr.reduceRight](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight) 方法和上面的种类差不多，但稍微复杂一点。它们用于根据数组计算单个值。掌握这个知识点的最简单的方法就是通过示例。
* 大多数方法都支持 “thisArg”: 几乎所有调用函数的数组方法 —— 比如 find，filter，map，除了 sort 是一个特例，都接受一个可选的附加参数 thisArg。 上面的部分中没有解释该参数，因为该参数很少使用。但是为了完整性，我们需要讲讲它。
* [arr.some(fn)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/some)/[arr.every(fn)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/every) 检查数组。 与 map 类似，对数组的每个元素调用函数 fn。如果任何/所有结果为 true，则返回 true，否则返回 false。 这两个方法的行为类似于 || 和 && 运算符：如果 fn 返回一个真值，arr.some() 立即返回 true 并停止迭代其余数组项；如果 fn 返回一个假值，arr.every() 立即返回 false 并停止对其余数组项的迭代。
* Iterable object（可迭代对象）: 可迭代（Iterable） 对象是数组的泛化。这个概念是说任何对象都可以被定制为可在 for..of 循环中使用的对象。 数组是可迭代的。但不仅仅是数组。很多其他内建对象也都是可迭代的。例如字符串也是可迭代的。 如果从技术上讲，对象不是数组，而是表示某物的集合（列表，集合），for..of 是一个能够遍历它的很好的语法，因此，让我们来看看如何使其发挥作用。为了让对象可迭代（也就让 for..of 可以运行）我们需要为对象添加一个名为 Symbol.iterator 的方法（一个专门用于使对象可迭代的内建 symbol）。
* 无穷迭代器（iterator）: 无穷迭代器也是可能的。例如，将 range 设置为 range.to = Infinity，这时 range 则成为了无穷迭代器。或者我们可以创建一个可迭代对象，它生成一个无穷伪随机数序列。也是可能的。 next 没有什么限制，它可以返回越来越多的值，这是正常的。 当然，迭代这种对象的 for..of 循环将不会停止。但是我们可以通过使用 break 来停止它。
* 可迭代（iterable）和类数组（array-like）: 这两个官方术语看起来差不多，但其实大不相同。请确保你能够充分理解它们的含义，以免造成混淆。 Iterable 如上所述，是实现了 Symbol.iterator 方法的对象。 Array-like 是有索引和 length 属性的对象，所以它们看起来很像数组。 当我们将 JavaScript 用于编写在浏览器或任何其他环境中的实际任务时，我们可能会遇到可迭代对象或类数组对象，或两者兼有。有一个全局方法 [Array.from](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/from) 可以接受一个可迭代或类数组的值，并从中获取一个“真正的”数组。然后我们就可以对其调用数组方法了。
* map\[key] 不是使用 Map 的正确方式: 虽然 map\[key] 也有效，例如我们可以设置 map\[key] = 2，这样会将 map 视为 JavaScript 的 plain object，因此它暗含了所有相应的限制（仅支持 string/symbol 键等）。 所以我们应该使用 map 方法：set 和 get 等。
* Map 是怎么比较键的？ Map 使用 [SameValueZero](https://tc39.github.io/ecma262/#sec-samevaluezero) 算法来比较键是否相等。它和严格等于 === 差不多，但区别是 NaN 被看成是等于 NaN。所以 NaN 也可以被用作键。 这个算法不能被改变或者自定义。
* 链式调用: 每一次 map.set 调用都会返回 map 本身，所以我们可以进行“链式”调用：`map.set('1', 'str1').set(1, 'num1').set(true, 'bool1');`.
* 使用插入顺序: 迭代的顺序与插入值的顺序相同。与普通的 Object 不同，Map 保留了此顺序。
* 当创建一个 Map 后，我们可以传入一个带有键值对的数组（或其它可迭代对象）来进行初始化。如果我们想从一个已有的普通对象（plain object）来创建一个 Map，那么我们可以使用内建方法 [Object.entries(obj)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/entries), 该方法返回对象的键/值对数组，该数组格式完全按照 Map 所需的格式。[Object.fromEntries](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) 方法的作用是相反的：给定一个具有 \[key, value] 键值对的数组，它会根据给定数组创建一个对象。
* Set 迭代（iteration）: 注意一件有趣的事儿。forEach 的回调函数有三个参数：一个 value，然后是 同一个值 valueAgain，最后是目标对象。没错，同一个值在参数里出现了两次。 forEach 的回调函数有三个参数，是为了与 Map 兼容。当然，这看起来确实有些奇怪。但是这对在特定情况下轻松地用 Set 代替 Map 很有帮助，反之亦然。
* WeakMap 在这方面有着根本上的不同。它不会阻止垃圾回收机制对作为键的对象（key object）的回收。WeakMap 和 Map 的第一个不同点就是，WeakMap 的键必须是对象，不能是原始值。WeakMap 不支持迭代以及 keys()，values() 和 entries() 方法。所以没有办法获取 WeakMap 的所有键或值。为什么会有这种限制呢？这是技术的原因。如果一个对象丢失了其它所有引用（就像上面示例中的 john），那么它就会被垃圾回收机制自动回收。但是在从技术的角度并不能准确知道 何时会被回收。 这些都是由 JavaScript 引擎决定的。JavaScript 引擎可能会选择立即执行内存清理，如果现在正在发生很多删除操作，那么 JavaScript 引擎可能就会选择等一等，稍后再进行内存清理。因此，从技术上讲，WeakMap 的当前元素的数量是未知的。JavaScript 引擎可能清理了其中的垃圾，可能没清理，也可能清理了一部分。因此，暂不支持访问 WeakMap 的所有键/值的方法。WeakMap 和 WeakSet 最明显的局限性就是不能迭代，并且无法获取所有当前内容。那样可能会造成不便，但是并不会阻止 WeakMap/WeakSet 完成其主要工作 — 成为在其它地方管理/存储“额外”的对象数据。
* Object.keys(obj) 相对于 map.keys() 第一个区别是，对于对象我们使用的调用语法是 Object.keys(obj)，而不是 obj.keys()。 为什么会这样？主要原因是灵活性。请记住，在 JavaScript 中，对象是所有复杂结构的基础。因此，我们可能有一个自己创建的对象，比如 data，并实现了它自己的 data.values() 方法。同时，我们依然可以对它调用 Object.values(data) 方法。 第二个区别是 Object.* 方法返回的是“真正的”数组对象，而不只是一个可迭代项。这主要是历史原因。
* Object.keys/values/entries 会忽略 symbol 属性: 就像 for..in 循环一样，这些方法会忽略使用 Symbol(...) 作为键的属性。 通常这很方便。但是，如果我们也想要 Symbol 类型的键，那么这儿有一个单独的方法 [Object.getOwnPropertySymbols](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols), 它会返回一个只包含 Symbol 类型的键的数组。另外，还有一种方法 [Reflect.ownKeys(obj)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys), 它会返回 所有 键。
* 转换对象: 对象缺少数组存在的许多方法，例如 map 和 filter 等。 如果我们想应用它们，那么我们可以使用 Object.entries，然后使用 Object.fromEntries： 使用 Object.entries(obj) 从 obj 获取由键/值对组成的数组。 对该数组使用数组方法，例如 map，对这些键/值对进行转换。 对结果数组使用 Object.fromEntries(array) 方法，将结果转回成对象。乍一看，可能感觉有点困难，但是使用一两次之后就很容易理解了。我们可以通过这种方式建立强大的转换链。
  ```text
  let prices = {
    banana: 1,
    orange: 2,
    meat: 4,
  };
  
  let doublePrices = Object.fromEntries(
    // 将价格转换为数组，将每个键/值对映射为另一对
    // 然后通过 fromEntries 再将结果转换为对象
    Object.entries(prices).map(entry => [entry[0], entry[1] * 2])
  );
  
  alert(doublePrices.meat); // 8
  ```
* 解构赋值 是一种特殊的语法，它使我们可以将数组或对象“拆包”至一系列变量中，因为有时这样更方便。 解构操作对那些具有很多参数和默认值等的函数也很奏效。“解构”并不意味着“破坏”: 
这种语法叫做“解构赋值”，因为它通过将结构中的各元素复制到变量中来达到“解构”的目的。但数组本身是没有被修改的。忽略使用逗号的元素: 数组中不想要的元素也可以通过添加额外的逗号来把它丢弃。等号右侧可以是任何可迭代对象：……实际上，我们可以将其与任何可迭代对象一起使用，而不仅限于数组。赋值给等号左侧的任何内容：我们可以在等号左侧使用任何“可以被赋值的”东西。与 .entries() 方法进行循环操作：在前面的章节中我们已经见过了 [Object.entries(obj)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) 方法。 我们可以将 .entries() 方法与解构语法一同使用，来遍历一个对象的“键—值”对。
* 通常，如果数组比左边的列表长，那么“其余”的数组项会被省略。如果我们还想收集其余的数组项 —— 我们可以使用三个点 "..." 来再加一个参数以获取“其余”数组项。
* 如果数组比左边的变量列表短，这里也不会出现报错。缺少的值被认为是 undefined。如果我们想要一个“默认”值给未赋值的变量，我们可以使用 = 来提供。默认值可以是更加复杂的表达式甚至可以是函数调用，这些表达式或函数只会在这个变量未被赋值的时候才会被计算。
* 解构赋值同样适用于对象。在等号右侧应该有一个已经存在的对象，我们想把它拆分到变量中。等号左侧包含了对象相应属性的一个类对象“模式（pattern）”。在最简单的情况下，等号左侧的就是 {...} 中的变量名列表。如果我们想把一个属性赋值给另一个名字的变量，比如把 options.width 属性赋值给名为 w 的变量，那么我们可以使用冒号来设置变量名称。
* 如果对象拥有的属性数量比我们提供的变量数量还多，该怎么办？我们可以只取其中的某一些属性，然后把“剩余的”赋值到其他地方吗？ 我们可以使用剩余模式（pattern），就像我们对数组那样。一些较旧的浏览器不支持此功能（例如，使用 Babel 对其进行填充），但可以在现代浏览器中使用。
* 不使用 let 时的陷阱：在上面的示例中，变量都是在赋值中通过正确方式声明的：let {…} = {…}。当然，我们也可以使用已有的变量，而不用 let，但这里有一个陷阱。问题在于 JavaScript 把主代码流（即不在其他表达式中）的 {...} 当做一个代码块。因此，这里 JavaScript 假定我们有一个代码块，这就是报错的原因。我们需要解构它。 为了告诉 JavaScript 这不是一个代码块，我们可以把整个赋值表达式用括号 (...) 包起来。
* 智能函数参数：有时，一个函数有很多参数，其中大部分的参数都是可选的。在实际开发中存在一个问题就是你怎么记得住这么多参数的顺序。通常集成开发环境工具（IDE）会尽力帮助我们，特别是当代码有良好的文档注释的时候，但是…… 另一个问题就是，当大部分的参数采用默认值就好的情况下，怎么调用这个函数。这太难看了。而且，当我们处理更多参数的时候可读性会变得很差。 解构赋值语法前来救援！ 我们可以把所有参数当作一个对象来传递，然后函数马上把这个对象解构成多个变量。请注意，这种解构假定了 showMenu() 函数确实存在参数。如果我们想让所有的参数都使用默认值，那我们应该传递一个空对象。我们可以通过指定空对象 {} 为整个参数对象的默认值来解决这个问题。
* 不是 getYear()，而是 getFullYear(): 很多 JavaScript 引擎都实现了一个非标准化的方法 getYear()。不推荐使用这个方法。它有时候可能会返回 2 位的年份信息。永远都不要使用它。要获取年份就使用 getFullYear()。
* Date.now(): 如果我们仅仅想要测量时间间隔，我们不需要 Date 对象。 有一个特殊的方法 Date.now()，它会返回当前的时间戳。 它相当于 new Date().getTime()，但它不会创建中间的 Date 对象。因此它更快，而且不会对垃圾处理造成额外的压力。 这种方法很多时候因为方便，又或是因性能方面的考虑而被采用，例如使用 JavaScript 编写游戏或其他的特殊应用场景。
* 想象一下当运行 bench(diffSubtract) 的同时，CPU 还在并行处理其他事务，并且这也会占用资源。然而，运行 bench(diffGetTime) 的时候，并行处理的事务完成了。 这是对于现代多进程操作系统来说的一个非常真实的场景。 结果就是，第一个函数相比于第二个函数，缺少 CPU 资源。这可能导致错误的结论。 为了得到更加可靠的度量，整个度量测试包应该重新运行多次。
* 进行微度量测试时要小心: 现代的 JavaScript 引擎执行了很多优化。与“正常使用”相比，它们可能会改变“人为测试”的结果，特别是在我们对很细微的东西进行度量测试时，例如 operator 的工作方式或内建函数。因此，如果你想好好了解一下性能，请学习 JavaScript 引擎的工作原理。在那之后，你可能再也不需要微度量了。 关于 V8 引擎的大量文章，可以在 [http://mrale.ph](http://mrale.ph/) 找到。
* 和其他系统不同，JavaScript 中时间戳以毫秒为单位，而不是秒。 有时我们需要更加精准的时间度量。JavaScript 自身并没有测量微秒的方法（百万分之一秒），但大多数运行环境会提供。例如：浏览器有 [performance.now()](https://developer.mozilla.org/zh/docs/Web/API/Performance/now) 方法来给出从页面加载开始的以毫秒为单位的微秒数（精确到毫秒的小数点后三位），Node.js 有 microtime 模块以及其他方法。从技术上讲，几乎所有的设备和环境都允许获取更高精度的数值，只是不是通过 Date 对象。
* JSON 是语言无关的纯数据规范，因此一些特定于 JavaScript 的对象属性会被 JSON.stringify 跳过。即： 函数属性（方法）。 Symbol 类型的键和值。 存储 undefined 的属性。通常这很好。如果这不是我们想要的方式，那么我们很快就会看到如何自定义转换方式。 最棒的是支持嵌套对象转换，并且可以自动对其进行转换。
* JSON 可能会非常复杂，对象和数组可以包含其他对象和数组。但是它们必须遵循相同的 JSON 格式。此外，JSON 不支持注释。向 JSON 添加注释无效。 还有另一种名为 [JSON5](https://json5.org/) 的格式，它允许未加引号的键，也允许注释等。但这是一个独立的库，不在语言的规范中。 常规的 JSON 格式严格，并不是因为它的开发者很懒，而是为了实现简单，可靠且快速地实现解析算法。
* 递归通常更短: 递归解通常比迭代解更短。 在这儿，我们可以使用条件运算符 ? 而不是 if 语句，从而使 pow(x, n) 更简洁并且可读性依然很高。
* 任何递归都可以用循环来重写。通常循环变体更有效。 ……但有时重写很难，尤其是函数根据条件使用不同的子调用，然后合并它们的结果，或者分支比较复杂时。而且有些优化可能没有必要，完全不值得。 递归可以使代码更短，更易于理解和维护。并不是每个地方都需要优化，大多数时候我们需要一个好代码，这就是为什么要使用它。
* Rest 参数 ...: 在 JavaScript 中，无论函数是如何定义的，你都可以使用任意数量的参数调用函数。Rest 参数可以通过使用三个点 ... 并在后面跟着包含剩余参数的数组名称，来将它们包含在函数定义中。这些点的字面意思是“将剩余参数收集到一个数组中”。Rest 参数必须放到参数列表的末尾: Rest 参数会收集剩余的所有参数，因此下面这种用法没有意义，并且会导致错误
* “arguments” 变量: 有一个名为 arguments 的特殊的类数组对象，该对象按参数索引包含所有参数。
* 箭头函数是没有 "arguments": 如果我们在箭头函数中访问 arguments，访问到的 arguments 并不属于箭头函数，而是属于箭头函数外部的“普通”函数。我们已经知道，箭头函数没有自身的 this。现在我们知道了它们也没有特殊的 arguments 对象。
* 假如我们有一个数组 \[3, 5, 1]，我们该如何用它调用 Math.max 呢？ Spread 语法 来帮助你了！它看起来和 rest 参数很像，也使用 ...，但是二者的用途完全相反。 当在函数调用中使用 ...arr 时，它会把可迭代对象 arr “展开”到参数列表中。我们还可以通过这种方式传递多个可迭代对象: `alert( Math.max(...arr1, ...arr2) ); // 8`, 我们甚至还可以将 spread 语法与常规值结合使用：`alert( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25`, 并且，我们还可以使用 spread 语法来合并数组：`let merged = [0, ...arr, 2, ...arr2];`.
* 复制 array/object: 还记得我们 [之前讲过的](https://zh.javascript.info/object-copy#ke-long-yu-he-bing-objectassign) Object.assign() 吗？ 使用 spread 语法也可以做同样的事情（译注：也就是进行浅拷贝）。`let arrCopy = [...arr];`, `let objCopy = { ...obj };`, 这种方式比使用 let arrCopy = Object.assign([], arr) 来复制数组，或使用 let objCopy = Object.assign({}, obj) 来复制对象写起来要短得多。因此，只要情况允许，我们更喜欢使用它。
* 当我们在代码中看到 "..." 时，它要么是 rest 参数，要么就是 spread 语法。 有一个简单的方法可以区分它们： 若 ... 出现在函数参数列表的最后，那么它就是 rest 参数，它会把参数列表中剩余的参数收集到一个数组中。 若 ... 出现在函数调用或类似的表达式中，那它就是 spread 语法，它会把一个数组展开为列表。 使用场景： Rest 参数用于创建可接受任意数量参数的函数。 Spread 语法用于将数组传递给通常需要含有许多参数的列表的函数。 它们俩的出现帮助我们轻松地在列表和参数数组之间来回转换。 “旧式”的 arguments（类数组且可迭代的对象）也依然能够帮助我们获取函数调用中的所有参数。
* 词法环境是一个规范对象: “词法环境”是一个规范对象（specification object）：它仅仅是存在于 [编程语言规范](https://tc39.es/ecma262/#sec-lexical-environments) 中的“理论上”存在的，用于描述事物如何运作的对象。我们无法在代码中获取该对象并直接对其进行操作。 但 JavaScript 引擎同样可以优化它，比如清除未被使用的变量以节省内存和执行其他内部技巧等，但显性行为应该是和上述的无差。
* 在 JavaScript 中，每个运行的函数，代码块 {...} 以及整个脚本，都有一个被称为 词法环境（Lexical Environment） 的内部（隐藏）的关联对象。一个“变量”只是 环境记录 这个特殊的内部对象的一个属性。“获取或修改变量”意味着“获取或修改词法环境的一个属性”。一个函数其实也是一个值，就像变量一样。 不同之处在于函数声明的初始化会被立即完成。 当创建了一个词法环境（Lexical Environment）时，函数声明会立即变为即用型函数（不像 let 那样直到声明处才可用）。 这就是为什么我们可以在（函数声明）的定义之前调用函数声明。当代码要访问一个变量时 —— 首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推，直到全局词法环境。 如果在任何地方都找不到这个变量，那么在严格模式下就会报错（在非严格模式下，为了向下兼容，给未定义的变量赋值会创建一个全局变量）。
* 闭包: 开发者通常应该都知道“闭包”这个通用的编程术语。 [闭包](https://en.wikipedia.org/wiki/Closure_(computer_programming)) 是指内部函数总是可以访问其所在的外部函数中声明的变量和参数，即使在其外部函数被返回（寿命终结）了之后。在某些编程语言中，这是不可能的，或者应该以特殊的方式编写函数来实现。但是如上所述，在 JavaScript 中，所有函数都是天生闭包的（只有一个例外，将在 "[new Function](https://zh.javascript.info/new-function)" 语法 中讲到）。 也就是说：JavaScript 中的函数会自动通过隐藏的 \[\[Environment]] 属性记住创建它们的位置，所以它们都可以访问外部变量。 在面试时，前端开发者通常会被问到“什么是闭包？”，正确的回答应该是闭包的定义，并解释清楚为什么 JavaScript 中的所有函数都是闭包的，以及可能的关于 \[\[Environment]] 属性和词法环境原理的技术细节。
* 实际开发中的优化: 正如我们所看到的，理论上当函数可达时，它外部的所有变量也都将存在。 但在实际中，JavaScript 引擎会试图优化它。它们会分析变量的使用情况，如果从代码中可以明显看出有未使用的外部变量，那么就会将其删除。 在 V8（Chrome，Edge，Opera）中的一个重要的副作用是，此类变量在调试中将不可用。正如你所见的 —— No such variable! 理论上，它应该是可以访问的，但引擎把它优化掉了。 这可能会导致有趣的（如果不是那么耗时的）调试问题。其中之一 —— 我们可以看到的是一个同名的外部变量，而不是预期的变量。V8 引擎的这个特性你真的应该知道。如果你要使用 Chrome/Edge/Opera 进行代码调试，迟早会遇到这样的问题。 这不是调试器的 bug，而是 V8 的一个特别的特性。也许以后会被修改。你始终可以通过运行本文中的示例来进行检查。
* var 声明与 let 相似。大部分情况下，我们可以用 let 代替 var 或者 var 代替 let，都能达到预期的效果。但实际上 var 却是一头非常不同的，源自远古时代的怪兽。在现代脚本中一般不再使用它，但它仍然潜伏在旧脚本中。
* 人们将这种行为称为“提升”（英文为 “hoisting” 或 “raising”），因为所有的 var 都被“提升”到了函数的顶部。 所以，在上面的例子中，if (false) 分支永远都不会执行，但没关系，它里面的 var 在函数刚开始时就被处理了，所以在执行 (*) 那行代码时，变量是存在的。 声明会被提升，但是赋值不会。
* IIFE: 在之前，JavaScript 中只有 var 这一种声明变量的方式，并且这种方式声明的变量没有块级作用域，程序员们就发明了一种模仿块级作用域的方法。这种方法被称为“立即调用函数表达式”（immediately-invoked function expressions，IIFE）。 如今，我们不应该再使用 IIFE 了，但是你可以在旧脚本中找到它们。
* var 与 let/const 有两个主要的区别： var 声明的变量没有块级作用域，它们仅在当前函数内可见，或者全局可见（如果变量是在函数外声明的）。 var 变量声明在函数开头就会被处理（脚本启动对应全局变量）。 涉及全局对象时，还有一个非常小的差异，我们将在下一章中介绍。 这些差异使 var 在大多数情况下都比 let 更糟糕。块级作用域是这么好的一个东西。这就是 let 在几年前就被写入到标准中的原因，并且现在（与 const 一起）已经成为了声明变量的主要方式。
* 全局对象提供可在任何地方使用的变量和函数。默认情况下，这些全局变量内建于语言或环境中。 在浏览器中，它的名字是 “window”，对 Node.js 而言，它的名字是 “global”，其它环境可能用的是别的名字。 最近，globalThis 被作为全局对象的标准名称加入到了 JavaScript 中，所有环境都应该支持该名称。所有主流浏览器都支持它。 假设我们的环境是浏览器，我们将在这儿使用 “window”。如果你的脚本可能会用来在其他环境中运行，则最好使用 globalThis。
* 我们已经知道，在 JavaScript 中，函数就是值。 JavaScript 中的每个值都有一种类型，那么函数是什么类型呢？ 在 JavaScript 中，函数就是对象。 一个容易理解的方式是把函数想象成可被调用的“行为对象（action object）”。我们不仅可以调用它们，还能把它们当作对象来处理：增/删属性，按引用传递等。
* 函数对象包含一些便于使用的属性。 比如，一个函数的名字可以通过属性 “name” 来访问。还有另一个内建属性 “length”，它返回函数入参的个数。这种特别的情况就是所谓的 [多态性](https://en.wikipedia.org/wiki/Polymorphism_(computer_science)) —— 根据参数的类型，或者根据在我们的具体情景下的 length 来做不同的处理。这种思想在 JavaScript 的库里有应用。
* 属性不是变量：被赋值给函数的属性，比如 sayHi.counter = 0，不会 在函数内定义一个局部变量 counter。换句话说，属性 counter 和变量 let counter 是毫不相关的两个东西。 我们可以把函数当作对象，在它里面存储属性，但是这对它的执行没有任何影响。变量不是函数属性，反之亦然。它们之间是平行的。
* 函数声明没有这个东西：这里所讲的“内部名”特性只针对函数表达式，而不是函数声明。对于函数声明，没有用来添加“内部”名的语法。 有时，当我们需要一个可靠的内部名时，这就成为了你把函数声明重写成函数表达式的理由了。
* 函数可以带有额外的属性。很多知名的 JavaScript 库都充分利用了这个功能。 它们创建一个“主”函数，然后给它附加很多其它“辅助”函数。例如，[jQuery](https://jquery.com/) 库创建了一个名为 $ 的函数。[lodash](https://lodash.com/) 库创建一个 _ 函数，然后为其添加了 \_.add、_.keyBy 以及其它属性（想要了解更多内容，参查阅 [docs](https://lodash.com/docs) ）。实际上，它们这么做是为了减少对全局空间的污染，这样一个库就只会有一个全局变量。这样就降低了命名冲突的可能性。 所以，一个函数本身可以完成一项有用的工作，还可以在自身的属性中附带许多其他功能。
* "new Function" 语法: 还有一种创建函数的方法。它很少被使用，但有些时候只能选择它。与我们已知的其他方法相比，这种方法最大的不同在于，它实际上是通过运行时通过参数传递过来的字符串创建的。 以前的所有声明方法都需要我们 —— 程序员，在脚本中编写函数的代码。 但是 new Function 允许我们将任意字符串变为函数。例如，我们可以从服务器接收一个新的函数并执行它。使用 new Function 创建函数的应用场景非常特殊，比如在复杂的 Web 应用程序中，我们需要从服务器获取代码或者动态地从模板编译函数时才会使用。使用 new Function 创建的函数，它的 \[\[Environment]] 指向全局词法环境，而不是函数所在的外部词法环境。因此，我们不能在 new Function 中直接使用外部变量。不过这样是好事，这有助于降低我们代码出错的可能。并且，从代码架构上讲，显式地使用参数传值是一种更好的方法，并且避免了与使用压缩程序而产生冲突的问题。
* 有时我们并不想立即执行一个函数，而是等待特定一段时间之后再执行。这就是所谓的“计划调用（scheduling a call）”。 目前有两种方式可以实现： setTimeout 允许我们将函数推迟到一段时间间隔之后再执行。 setInterval 允许我们重复运行一个函数，从一段时间间隔之后开始运行，之后以该时间间隔连续重复运行该函数。 这两个方法并不在 JavaScript 的规范中。但是大多数运行环境都有内建的调度程序，并且提供了这些方法。目前来讲，所有浏览器以及 Node.js 都支持这两个方法。
* 传入一个函数，但不要执行它
新手开发者有时候会误将一对括号 () 加在函数后面：`setTimeout(sayHi(), 1000); ` 这样不行，因为 setTimeout 期望得到一个对函数的引用。而这里的 sayHi() 很明显是在执行函数，所以实际上传入 setTimeout 的是 函数的执行结果。在这个例子中，sayHi() 的执行结果是 undefined（也就是说函数没有返回任何结果），所以实际上什么也没有调度。
* alert 弹窗显示的时候计时器依然在进行计时: 在大多数浏览器中，包括 Chrome 和 Firefox，在显示 alert/confirm/prompt 弹窗时，内部的定时器仍旧会继续“嘀嗒”。 所以，在运行上面的代码时，如果在一定时间内没有关掉 alert 弹窗，那么在你关闭弹窗后，下一个 alert 会立即显示。两次 alert 之间的时间间隔将小于 2 秒。
* 周期性调度有两种方式: 一种是使用 setInterval，另外一种就是嵌套的 setTimeout: 嵌套的 setTimeout 要比 setInterval 灵活得多。采用这种方式可以根据当前执行结果来调度下一次调用，因此下一次调用可以与当前这一次不同。嵌套的 setTimeout 能够精确地设置两次执行之间的延时，而 setInterval 却不能。
* 垃圾回收和 setInterval/setTimeout 回调（callback）: 当一个函数传入 setInterval/setTimeout 时，将为其创建一个内部引用，并保存在调度程序中。这样，即使这个函数没有其他引用，也能防止垃圾回收器（GC）将其回收。对于 setInterval，传入的函数也是一直存在于内存中，直到 clearInterval 被调用。 这里还要提到一个副作用。如果函数引用了外部变量（译注：闭包），那么只要这个函数还存在，外部变量也会随之存在。它们可能比函数本身占用更多的内存。因此，当我们不再需要调度函数时，最好取消它，即使这是个（占用内存）很小的函数。
* 零延时的 setTimeout: 这儿有一种特殊的用法：setTimeout(func, 0)，或者仅仅是 setTimeout(func)。 这样调度可以让 func 尽快执行。但是只有在当前正在执行的脚本执行完成后，调度程序才会调用它。 也就是说，该函数被调度在当前脚本执行完成“之后”立即执行。
* 零延时实际上不为零（在浏览器中）:在浏览器环境下，嵌套定时器的运行频率是受限制的。根据 [HTML5 标准](https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers) 所讲：“经过 5 重嵌套定时器之后，时间间隔被强制设定为至少 4 毫秒”。 让我们用下面的示例来看看这到底是什么意思。其中 setTimeout 调用会以零延时重新调度自身的调用。每次调用都会在 times 数组中记录上一次调用的实际时间。那么真正的延迟是什么样的？让我们来看看：第一次，定时器是立即执行的（正如规范里所描述的那样），接下来我们可以看到 9, 15, 20, 24...。两次调用之间必须经过 4 毫秒以上的强制延时。（译注：这里作者没说清楚，timer 数组里存放的是每次定时器运行的时刻与 start 的差值，所以数字只会越来越大，实际上前后调用的延时是数组值的差值。示例中前几次都是 1，所以延时为 0） 如果我们使用 setInterval 而不是 setTimeout，也会发生类似的情况：setInterval(f) 会以零延时运行几次 f，然后以 4 毫秒以上的强制延时运行。 这个限制来自“远古时代”，并且许多脚本都依赖于此，所以这个机制也就存在至今。 对于服务端的 JavaScript，就没有这个限制，并且还有其他调度即时异步任务的方式。例如 Node.js 的 [setImmediate](https://nodejs.org/api/timers.html#timers_setimmediate_callback_args). 因此，这个提醒只是针对浏览器环境的。
* 请注意，所有的调度方法都不能 保证 确切的延时。 例如，浏览器内的计时器可能由于许多原因而变慢： CPU 过载。 浏览器页签处于后台模式。 笔记本电脑用的是电池供电（译注：使用电池供电会以降低性能为代价提升续航）。 所有这些因素，可能会将定时器的最小计时器分辨率（最小延迟）增加到 300ms 甚至 1000ms，具体以浏览器及其设置为准。
* 装饰器模式和转发，call/apply: JavaScript 在处理函数时提供了非凡的灵活性。它们可以被传递，用作对象，现在我们将看到如何在它们之间 转发（forward） 调用并 装饰（decorate） 它们。
* 透明缓存: cachingDecorator 是一个 装饰器（decorator）：一个特殊的函数，它接受另一个函数并改变它的行为。 其思想是，我们可以为任何函数调用 cachingDecorator，它将返回缓存包装器。这很棒啊，因为我们有很多函数可以使用这样的特性，而我们需要做的就是将 cachingDecorator 应用于它们。 通过将缓存与主函数代码分开，我们还可以使主函数代码变得更简单。上面提到的缓存装饰器不适用于对象方法。有一个特殊的内建函数方法 [func.call(context, …args)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Function/call), 它允许调用一个显式设置 this 的函数。
* 之前，对于单个参数 x，我们可以只使用 cache.set(x, result) 来保存结果，并使用 cache.get(x) 来检索并获取结果。但是现在，我们需要记住 参数组合 (min,max) 的结果。原生的 Map 仅将单个值作为键（key）。 这儿有许多解决方案可以实现（对于许多实际应用，第三种方式就足够了，所以我们就用这个吧）：
  1. 实现一个新的（或使用第三方的）类似 map 的更通用并且允许多个键的数据结构。
  2. 使用嵌套 map：cache.set(min) 将是一个存储（键值）对 (max, result) 的 Map。所以我们可以使用 cache.get(min).get(max) 来获取 result。
  3. 将两个值合并为一个。为了灵活性，我们可以允许为装饰器提供一个“哈希函数”，该函数知道如何将多个值合并为一个值。 
* 我们可以使用 [func.apply(this, arguments)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Function/apply) 代替 func.call(this, ...arguments)。call 和 apply 之间唯一的语法区别是，call 期望一个参数列表，而 apply 期望一个包含这些参数的类数组对象。只有一个关于 args 的细微的差别： Spread 语法 ... 允许将 可迭代对象 args 作为列表传递给 call。 apply 只接受 类数组 args。 ……对于即可迭代又是类数组的对象，例如一个真正的数组，我们使用 call 或 apply 均可，但是 apply 可能会更快，因为大多数 JavaScript 引擎在内部对其进行了优化。 将所有参数连同上下文一起传递给另一个函数被称为“呼叫转移（call forwarding）”。
* 借用一种方法： `function hash(args) { return args.join(); }`, ……不幸的是，这不行。因为我们正在调用 hash(arguments)，arguments 对象既是可迭代对象又是类数组对象，但它并不是真正的数组。不过，有一种简单的方法可以使用数组的 join 方法：`function hash() { alert( [].join.call(arguments) ); }; hash(1, 2);`, 这个技巧被称为 方法借用（method borrowing）。 我们从常规数组 [].join 中获取（借用）join 方法，并使用 [].join.call 在 arguments 的上下文中运行它。
* 装饰器和函数属性: 通常，用装饰的函数替换一个函数或一个方法是安全的，除了一件小东西。如果原始函数有属性，例如 func.calledCount 或其他，则装饰后的函数将不再提供这些属性。因为这是装饰器。因此，如果有人使用它们，那么就需要小心。一些包装器可能会提供自己的属性。例如，装饰器会计算一个函数被调用了多少次以及花费了多少时间，并通过包装器属性公开（expose）这些信息。 存在一种创建装饰器的方法，该装饰器可保留对函数属性的访问权限，但这需要使用特殊的 Proxy 对象来包装函数。我们将在后面的 [Proxy 和 Reflect](https://zh.javascript.info/proxy#proxy-apply) 中学习它。
* 函数绑定: 当将对象方法作为回调进行传递，例如传递给 setTimeout，这儿会存在一个常见的问题：“丢失 this”。这个需求很典型 —— 我们想将一个对象方法传递到别的地方（这里 —— 传递到调度程序），然后在该位置调用它。如何确保在正确的上下文中调用它？最简单的解决方案是使用一个包装函数。函数提供了一个内建方法 [bind](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Function/bind), 它可以绑定 this。func.bind(context) 的结果是一个特殊的类似于函数的“外来对象（exotic object）”，它可以像函数一样被调用，并且透明地（transparently）将调用传递给 func 并设定 this=context。 换句话说，boundFunc 调用就像绑定了 this 的 func。
* 便捷方法：bindAll: 如果一个对象有很多方法，并且我们都打算将它们都传递出去，那么我们可以在一个循环中完成所有方法的绑定。JavaScript 库还提供了方便批量绑定的函数，例如 lodash 中的 [_.bindAll(object, methodNames)](http://lodash.com/docs#bindAll).
* 偏函数（Partial functions）: 到现在为止，我们只在谈论绑定 this。让我们再深入一步。 我们不仅可以绑定 this，还可以绑定参数（arguments）。虽然很少这么做，但有时它可以派上用场。为什么我们通常会创建一个 [偏函数](https://en.wikipedia.org/wiki/Partial_application)? 好处是我们可以创建一个具有可读性高的名字（double，triple）的独立函数。我们可以使用它，并且不必每次都提供一个参数，因为参数是被绑定了的。 另一方面，当我们有一个非常通用的函数，并希望有一个通用型更低的该函数的变体时，偏函数会非常有用。
* 在没有上下文情况下的 partial: 当我们想绑定一些参数（arguments），但是这里没有上下文 this，应该怎么办？例如，对于一个对象方法。 原生的 bind 不允许这种情况。我们不可以省略上下文直接跳到参数（arguments）。 幸运的是，仅绑定参数（arguments）的函数 partial 比较容易实现。
* 深入理解箭头函数: 箭头函数不仅仅是编写简洁代码的“捷径”。它还具有非常特殊且有用的特性。JavaScript 的精髓在于创建一个函数并将其传递到某个地方。 在这样的函数中，我们通常不想离开当前上下文。这就是箭头函数的主战场啦。
* 不能对箭头函数进行 new 操作: 不具有 this 自然也就意味着另一个限制：箭头函数不能用作构造器（constructor）。不能用 new 调用它们。
* 箭头函数 VS bind: 箭头函数 => 和使用 .bind(this) 调用的常规函数之间有细微的差别： .bind(this) 创建了一个该函数的“绑定版本”。 箭头函数 => 没有创建任何绑定。箭头函数只是没有 this。this 的查找与常规变量的搜索方式完全相同：在外部词法环境中查找。
* 箭头函数： 没有 this; 没有 arguments; 不能使用 new 进行调用;它们也没有 super，但目前我们还没有学到它。我们将在 [类继承](https://zh.javascript.info/class-inheritance) 一章中学习它。 这是因为，箭头函数是针对那些没有自己的“上下文”，但在当前上下文中起作用的短代码的。并且箭头函数确实在这种使用场景中大放异彩。
* 属性标志和属性描述符: 对象属性（properties），除 value 外，还有三个特殊的特性（attributes），也就是所谓的“标志”：
  1. writable — 如果为 true，则值可以被修改，否则它是只可读的。
  2. enumerable — 如果为 true，则会被在循环中列出，否则不会被列出。
  3. configurable — 如果为 true，则此特性可以被删除，这些属性也可以被修改，否则不可以。
* 使属性变成不可配置是一条单行道。我们无法通过 defineProperty 再把它改回来。 请注意：configurable: false 防止更改和删除属性标志，但是允许更改对象的值。唯一可行的特性更改：writable true → false: 对于更改标志，有一个小例外。 对于不可配置的属性，我们可以将 writable: true 更改为 false，从而防止其值被修改（以添加另一层保护）。但无法反向行之。
* 设定一个全局的密封对象: 属性描述符在单个属性的级别上工作。 还有一些限制访问 整个 对象的方法。Object.preventExtensions(obj), Object.seal(obj), Object.freeze(obj) 等。
* 属性的 getter 和 setter：有两种类型的对象属性。 第一种是 数据属性。我们已经知道如何使用它们了。到目前为止，我们使用过的所有属性都是数据属性。 第二种类型的属性是新东西。它是 访问器属性（accessor properties）。它们本质上是用于获取和设置值的函数，但从外部代码来看就像常规属性。
* 从外表看，访问器属性看起来就像一个普通属性。这就是访问器属性的设计思想。我们不以函数的方式 调用 user.fullName，我们正常 读取 它：getter 在幕后运行。
* 在编程中，我们经常会想获取并扩展一些东西。 例如，我们有一个 user 对象及其属性和方法，并希望将 admin 和 guest 作为基于 user 稍加修改的变体。我们想重用 user 中的内容，而不是复制/重新实现它的方法，而只是在其之上构建一个新的对象。 原型继承（Prototypal inheritance） 这个语言特性能够帮助我们实现这一需求。
* 现在，如果我们从 longEar 中读取一些它不存在的内容，JavaScript 会先在 rabbit 中查找，然后在 animal 中查找。 这里只有两个限制： 引用不能形成闭环。如果我们试图在一个闭环中分配 \_\_proto__，JavaScript 会抛出错误。\_\_proto__ 的值可以是对象，也可以是 null。而其他的类型都会被忽略。 当然，这可能很显而易见，但是仍然要强调：只能有一个 \[\[Prototype]]。一个对象不能从其他两个对象获得继承。
* \_\_proto__ 是 \[\[Prototype]] 的因历史原因而留下来的 getter/setter: 初学者常犯一个普遍的错误，就是不知道 \_\_proto__ 和 \[\[Prototype]] 的区别。 请注意，\_\_proto__ 与内部的 \[\[Prototype]] 不一样。\_\_proto__ 是 \[\[Prototype]] 的 getter/setter。稍后，我们将看到在什么情况下理解它们很重要，在建立对 JavaScript 语言的理解时，让我们牢记这一点。\_\_proto__ 属性有点过时了。它的存在是出于历史的原因，现代编程语言建议我们应该使用函数 Object.getPrototypeOf/Object.setPrototypeOf 来取代 \_\_proto__ 去 get/set 原型。稍后我们将介绍这些函数。 根据规范，\_\_proto__ 必须仅受浏览器环境的支持。但实际上，包括服务端在内的所有环境都支持它，因此我们使用它是非常安全的。 由于 \_\_proto__ 标记在观感上更加明显，所以我们在后面的示例中将使用它。
* 写入不使用原型: 原型仅用于读取属性。 对于写入/删除操作可以直接在对象上进行。访问器（accessor）属性是一个例外，因为分配（assignment）操作是由 setter 函数处理的。因此，写入此类属性实际上与调用函数相同。
* “this” 的值: 在上面的例子中可能会出现一个有趣的问题：在 set fullName(value) 中 this 的值是什么？属性 this.name 和 this.surname 被写在哪里：在 user 还是 admin？ 答案很简单：this 根本不受原型的影响。 无论在哪里找到方法：在一个对象还是在原型中。在一个方法调用中，this 始终是点符号 . 前面的对象。这是一件非常重要的事儿，因为我们可能有一个带有很多方法的大对象，并且还有从其继承的对象。当继承的对象运行继承的方法时，它们将仅修改自己的状态，而不会修改大对象的状态。方法是共享的，但对象状态不是。
* 几乎所有其他键/值获取方法都忽略继承的属性: 几乎所有其他键/值获取方法，例如 Object.keys 和 Object.values 等，都会忽略继承的属性。 它们只会对对象自身进行操作。不考虑 继承自原型的属性。
* 请注意：JavaScript 从一开始就有了原型继承。这是 JavaScript 编程语言的核心特性之一。 但是在过去，没有直接对其进行访问的方式。唯一可靠的方法是本章中会介绍的构造函数的 "prototype" 属性。目前仍有许多脚本仍在使用它。
* F.prototype 仅用在 new F 时: F.prototype 属性仅在 new F 被调用时使用，它为新对象的 \[\[Prototype]] 赋值。 如果在创建之后，F.prototype 属性有了变化（F.prototype = <another object>），那么通过 new F 创建的新对象也将随之拥有新的对象作为 \[\[Prototype]]，但已经存在的对象将保持旧有的值。
* 当我们有一个对象，但不知道它使用了哪个构造器（例如它来自第三方库），并且我们需要创建另一个类似的对象时，用这种方法就很方便。 但是，关于 "constructor" 最重要的是…… ……JavaScript 自身并不能确保正确的 "constructor" 函数值。 是的，它存在于函数的默认 "prototype" 中，但仅此而已。之后会发生什么 —— 完全取决于我们。 特别是，如果我们将整个默认 prototype 替换掉，那么其中就不会有 "constructor" 了。因此，为了确保正确的 "constructor"，我们可以选择添加/删除属性到默认 "prototype"，而不是将其整个覆盖。或者，也可以手动重新创建 constructor 属性。
* "prototype" 属性在 JavaScript 自身的核心部分中被广泛地应用。所有的内建构造函数都用到了它。当 new Object() 被调用（或一个字面量对象 {...} 被创建），按照前面章节中我们学习过的规则，这个对象的 \[\[Prototype]] 属性被设置为 Object.prototype. 其他内建对象，像 Array、Date、Function 及其他，都在 prototype 上挂载了方法。 例如，当我们创建一个数组 \[1, 2, 3]，在内部会默认使用 new Array() 构造器。因此 Array.prototype 变成了这个数组的 prototype，并为这个数组提供数组的操作方法。这样内存的存储效率是很高的。 按照规范，所有的内建原型顶端都是 Object.prototype。这就是为什么有人说“一切都从对象继承而来”。
* 最复杂的事情发生在字符串、数字和布尔值上。 正如我们记忆中的那样，它们并不是对象。但是如果我们试图访问它们的属性，那么临时包装器对象将会通过内建的构造器 String、Number 和 Boolean 被创建。它们提供给我们操作字符串、数字和布尔值的方法然后消失。 这些对象对我们来说是无形地创建出来的。大多数引擎都会对其进行优化，但是规范中描述的就是通过这种方式。这些对象的方法也驻留在它们的 prototype 中，可以通过 String.prototype、Number.prototype 和 Boolean.prototype 进行获取。
* 值 null 和 undefined 没有对象包装器: 特殊值 null 和 undefined 比较特殊。它们没有对象包装器，所以它们没有方法和属性。并且它们也没有相应的原型。
* 更改原生原型: 原生的原型是可以被修改的。重要：原型是全局的，所以很容易造成冲突。如果有两个库都添加了 String.prototype.show 方法，那么其中的一个方法将被另一个覆盖。 所以，通常来说，修改原生原型被认为是一个很不好的想法。在现代编程中，只有一种情况下允许修改原生原型。那就是 polyfilling。
* 从原型中借用: 一些原生原型的方法通常会被借用。 例如，如果我们要创建类数组对象，则可能需要向其中复制一些 Array 方法。方法借用很灵活，它允许在需要时混合来自不同对象的方法。
* 内建原型可以被修改或被用新的方法填充。但是不建议更改它们。唯一允许的情况可能是，当我们添加一个还没有被 JavaScript 引擎支持，但已经被加入 JavaScript 规范的新标准时，才可能允许这样做。
* \_\_proto__ 被认为是过时且不推荐使用的（deprecated），这里的不推荐使用是指 JavaScript 规范中规定，proto 必须仅在浏览器环境下才能得到支持。 现代的方法有（应该使用这些方法来代替 \_\_proto__）：
  1. [Object.create(proto, \[descriptors])](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/create) —— 利用给定的 proto 作为 \[\[Prototype]] 和可选的属性描述来创建一个空对象。
  2. [Object.getPrototypeOf(obj)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf) —— 返回对象 obj 的 \[\[Prototype]]。
  3. [Object.setPrototypeOf(obj, proto)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf) —— 将对象 obj 的 \[\[Prototype]] 设置为 proto。
* 我们可以使用 Object.create 来实现比复制 for..in 循环中的属性更强大的对象克隆方式：`let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));`, 此调用可以对 obj 进行真正准确地拷贝，包括所有的属性：可枚举和不可枚举的，数据属性和 setters/getters —— 包括所有内容，并带有正确的 \[\[Prototype]]。
* 如果速度很重要，就请不要修改已存在的对象的 \[\[Prototype]]: 从技术上来讲，我们可以在任何时候 get/set \[\[Prototype]]。但是通常我们只在创建对象的时候设置它一次，自那之后不再修改：rabbit 继承自 animal，之后不再更改。 并且，JavaScript 引擎对此进行了高度优化。用 Object.setPrototypeOf 或 obj.\_\_proto__= “即时”更改原型是一个非常缓慢的操作，因为它破坏了对象属性访问操作的内部优化。因此，除非你知道自己在做什么，或者 JavaScript 的执行速度对你来说完全不重要，否则请避免使用它。
* 我们可以通过 Object.create(null) 来创建没有原型的对象。这样的对象被称为 “very plain” 或 “pure dictionary” 对象，因为它们甚至比通常的普通对象（plain object）{...} 还要简单，对于它们而言，使用 "\_\_proto__" 作为键是没有问题的。
* 类的方法之间没有逗号: 对于新手开发人员来说，常见的陷阱是在类的方法之间放置逗号，这会导致语法错误。 不要把这里的符号与对象字面量相混淆。在类中，不需要逗号。
* 不仅仅是语法糖: 人们常说 class 是一个语法糖（旨在使内容更易阅读，但不引入任何新内容的语法），因为我们实际上可以在不使用 class 的情况下声明相同的内容。这个定义的结果与使用类得到的结果基本相同。因此，这确实是将 class 视为一种定义构造器及其原型方法的语法糖的理由。 尽管，它们之间存在着重大差异： 
  1. 首先，通过 class 创建的函数具有特殊的内部属性标记 \[\[IsClassConstructor]]: true。因此，它与手动创建并不完全相同。 编程语言会在许多地方检查该属性。例如，与普通函数不同，必须使用 new 来调用它。
  2. 类方法不可枚举。 类定义将 "prototype" 中的所有方法的 enumerable 标志设置为 false。 这很好，因为如果我们对一个对象调用 for..in 方法，我们通常不希望 class 方法出现。 
  3. 类总是使用 use strict。 在类构造中的所有代码都将自动进入严格模式。
* Class 字段: 旧的浏览器可能需要 polyfill, 类字段（field）是最近才添加到语言中的。
* 类字段 click = () => {...} 是基于每一个对象被创建的，在这里对于每一个 Button 对象都有一个独立的方法，在内部都有一个指向此对象的 this。我们可以把 button.click 传递到任何地方，而且 this 的值总是正确的。 在浏览器环境中，它对于进行事件监听尤为有用。
* 在 extends 后允许任意表达式: 类语法不仅允许指定一个类，在 extends 后可以指定任意表达式。 例如，一个生成父类的函数调用：这里 class User 继承自 f("Hello") 的结果。 这对于高级编程模式，例如当我们根据许多条件使用函数生成类，并继承它们时来说可能很有用。
* 重写 constructor: 继承类的 constructor 必须调用 super(...)，并且 (!) 一定要在使用 this 之前调用。……但这是为什么呢？这里发生了什么？确实，这个要求看起来很奇怪。 当然，本文会给出一个解释。让我们深入细节，这样你就可以真正地理解发生了什么。 在 JavaScript 中，继承类（所谓的“派生构造器”，英文为 “derived constructor”）的构造函数与其他函数之间是有区别的。派生构造器具有特殊的内部属性 \[\[ConstructorKind]]:"derived"。这是一个特殊的内部标签。 该标签会影响它的 new 行为： 当通过 new 执行一个常规函数时，它将创建一个空对象，并将这个空对象赋值给 this。 但是当继承的 constructor 执行时，它不会执行此操作。它期望父类的 constructor 来完成这项工作。 因此，派生的 constructor 必须调用 super 才能执行其父类（base）的 constructor，否则 this 指向的那个对象将不会被创建。并且我们会收到一个报错。
* 重写类字段: 一个棘手的注意要点: 高阶要点, 这个要点假设你对类已经有了一定的经验，或许是在其他编程语言中。 这里提供了一个更好的视角来窥探这门语言，且解释了它的行为为什么可能会是 bugs 的来源(但不是非常频繁)。 如果你发现这难以理解，什么都别管，继续往下阅读，之后有机会再回来看。
* 为了提供解决多层继承无法向上提升的问题，JavaScript 为函数添加了一个特殊的内部属性：\[\[HomeObject]]。 当一个函数被定义为类或者对象方法时，它的 \[\[HomeObject]] 属性就成为了该对象。 然后 super 使用它来解析（resolve）父原型及其方法。
* 方法并不是“自由”的: 正如我们之前所知道的，函数通常都是“自由”的，并没有绑定到 JavaScript 中的对象。正因如此，它们可以在对象之间复制，并用另外一个 this 调用它。\[\[HomeObject]] 的存在违反了这个原则，因为方法记住了它们的对象。\[\[HomeObject]] 不能被更改，所以这个绑定是永久的。 在 JavaScript 语言中 \[\[HomeObject]] 仅被用于 super。所以，如果一个方法不使用 super，那么我们仍然可以视它为自由的并且可在对象之间复制。但是用了 super 再这样做可能就会出错。
* 方法，不是函数属性: \[\[HomeObject]] 是为类和普通对象中的方法定义的。但是对于对象而言，方法必须确切指定为 method()，而不是 "method: function()"。 这个差别对我们来说可能不重要，但是对 JavaScript 来说却非常重要。
* 静态方法被用于实现属于整个类的功能。它与具体的类实例无关。 举个例子， 一个用于进行比较的方法 Article.compare(article1, article2) 或一个工厂（factory）方法 Article.createTodays()。 在类生命中，它们都被用关键字 static 进行了标记。 静态属性被用于当我们想要存储类级别的数据时，而不是绑定到实例。
* 在 JavaScript 中，有两种类型的对象字段（属性和方法）： 公共的：可从任何地方访问。它们构成了外部接口。到目前为止，我们只使用了公共的属性和方法。 私有的：只能从类的内部访问。这些用于内部接口。 在许多其他编程语言中，还存在“受保护”的字段：只能从类的内部和基于其扩展的类的内部访问（例如私有的，但可以从继承的类进行访问）。它们对于内部接口也很有用。从某种意义上讲，它们比私有的属性和方法更为广泛，因为我们通常希望继承类来访问它们。 受保护的字段不是在语言级别的 Javascript 中实现的，但实际上它们非常方便，因为它们是在 Javascript 中模拟的类定义语法。受保护的属性通常以下划线 _ 作为前缀。 这不是在语言级别强制实施的，但是程序员之间有一个众所周知的约定，即不应该从外部访问此类型的属性和方法。
* Getter/setter 函数: 这里我们使用了 getter/setter 语法。 但大多数时候首选 get.../set... 函数，这看起来有点长，但函数更灵活。它们可以接受多个参数（即使我们现在还不需要）。 另一方面，get/set 语法更短，所以最终没有严格的规定，而是由你自己来决定。
* 这儿有一个马上就会被加到规范中的已完成的 Javascript 提案，它为[私有属性和方法提供语言级支持](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields). 私有属性和方法应该以 # 开头。它们只在类的内部可被访问。在语言级别，# 是该字段为私有的特殊标志。我们无法从外部或从继承的类中访问它。 私有字段与公共字段不会发生冲突。我们可以同时拥有私有的 #waterAmount 和公共的 waterAmount 字段。与受保护的字段不同，私有字段由语言本身强制执行。这是好事儿。但是如果我们继承自 CoffeeMachine，那么我们将无法直接访问 #waterAmount。我们需要依靠 waterAmount getter/setter：在许多情况下，这种限制太严重了。如果我们扩展 CoffeeMachine，则可能有正当理由访问其内部。这就是为什么大多数时候都会使用受保护字段，即使它们不受语言语法的支持。
* 私有字段不能通过 this\[name] 访问: 私有字段很特别。 正如我们所知道的，通常我们可以使用 this\[name] 访问字段。对于私有字段来说，这是不可能的：this\['#name'] 不起作用。这是确保私有性的语法限制。
* 扩展内建类: 内建的类，例如 Array，Map 等也都是可以扩展的（extendable）。
* 内建类没有静态方法继承: 通常，当一个类扩展另一个类时，静态方法和非静态方法都会被继承。 但内建类却是一个例外。它们相互间不继承静态方法。 例如，Array 和 Date 都继承自 Object，所以它们的实例都有来自 Object.prototype 的方法。但 Array.\[\[Prototype]] 并不指向 Object，所以它们没有例如 Array.keys()（或 Date.keys()）这些静态方法。正如你所看到的，Date 和 Object 之间没有连结。它们是独立的，只有 Date.prototype 继承自 Object.prototype，仅此而已。 与我们所了解的通过 extends 获得的继承相比，这是内建对象之间继承的一个重要区别。
* 类检查："instanceof": instanceof 操作符用于检查一个对象是否属于某个特定的 class。同时，它还考虑了继承。 在许多情况下，可能都需要进行此类检查。例如，它可以被用来构建一个 多态性（polymorphic） 的函数，该函数根据参数的类型对参数进行不同的处理。这里还要提到一个方法 [objA.isPrototypeOf(objB)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/object/isPrototypeOf), 如果 objA 处在 objB 的原型链中，则返回 true。所以，可以将 obj instanceof Class 检查改为 Class.prototype.isPrototypeOf(obj)。 这很有趣，但是 Class 的 constructor 自身是不参与检查的！检查过程只和原型链以及 Class.prototype 有关。
* 使用 Object.prototype.toString 方法来揭示类型: 这是通过 toString 方法实现的。但是这儿有一个隐藏的功能，该功能可以使 toString 实际上比这更强大。我们可以将其作为 typeof 的增强版或者 instanceof 的替代方法来使用。Symbol.toStringTag: 可以使用特殊的对象属性 Symbol.toStringTag 自定义对象的 toString 方法的行为。正如我们所看到的，输出结果恰好是 Symbol.toStringTag（如果存在），只不过被包裹进了 \[object ...] 里。 这样一来，我们手头上就有了个“磕了药似的 typeof”，不仅能检查原始数据类型，而且适用于内建对象，更可贵的是还支持自定义。 所以，如果我们想要获取内建对象的类型，并希望把该信息以字符串的形式返回，而不只是检查类型的话，我们可以用 {}.toString.call 替代 instanceof。
* 在 JavaScript 中构造一个 mixin 最简单的方式就是构造一个拥有实用方法的对象，以便我们可以轻松地将这些实用的方法合并到任何类的原型中。
* Mixin — 是一个通用的面向对象编程术语：一个包含其他类的方法的类。 一些其它编程语言允许多重继承。JavaScript 不支持多重继承，但是可以通过将方法拷贝到原型中来实现 mixin。 我们可以使用 mixin 作为一种通过添加多种行为（例如上文中所提到的事件处理）来扩充类的方法。 如果 Mixins 意外覆盖了现有类的方法，那么它们可能会成为一个冲突点。因此，通常应该仔细考虑 mixin 的命名方法，以最大程度地降低发生这种冲突的可能性。
* **不管你多么精通编程，有时我们的脚本总还是会出现错误。可能是因为我们的编写出错，或是与预期不同的用户输入，或是错误的服务端响应以及其他数千种原因。** 通常，如果发生错误，脚本就会“死亡”（立即停止），并在控制台将错误打印出来。 但是有一种语法结构 try...catch，它使我们可以“捕获（catch）”错误，因此脚本可以执行更合理的操作，而不是死掉。
* try...catch 仅对运行时的 error 有效: 要使得 try...catch 能工作，代码必须是可执行的。换句话说，它必须是有效的 JavaScript 代码。 如果代码包含语法错误，那么 try..catch 将无法正常工作。JavaScript 引擎首先会读取代码，然后运行它。在读取阶段发生的错误被称为“解析时间（parse-time）”错误，并且无法恢复（从该代码内部）。这是因为引擎无法理解该代码。 所以，try...catch 只能处理有效代码中出现的错误。这类错误被称为“运行时的错误（runtime errors）”，有时被称为“异常（exceptions）”。
* try...catch 同步工作：如果在“计划的（scheduled）”代码中发生异常，例如在 setTimeout 中，则 try...catch 不会捕获到异常。因为 try...catch 包裹了计划要执行的函数，该函数本身要稍后才执行，这时引擎已经离开了 try...catch 结构。 为了捕获到计划的（scheduled）函数中的异常，那么 try...catch 必须在这个函数内。
* 发生错误时，JavaScript 生成一个包含有关其详细信息的对象。然后将该对象作为参数传递给 catch。对于所有内建的 error，error 对象具有两个主要属性：
  1. name：Error 名称。例如，对于一个未定义的变量，名称是 "ReferenceError"。 
  2. message：关于 error 的详细文字描述。
  3. 还有其他非标准的属性在大多数环境中可用。其中被最广泛使用和支持的是： stack：当前的调用栈：用于调试目的的一个字符串，其中包含有关导致 error 的嵌套调用序列的信息。
* throw 操作符会生成一个 error 对象。技术上讲，我们可以将任何东西用作 error 对象。甚至可以是一个原始类型数据，例如数字或字符串，但最好使用对象，最好使用具有 name 和 message 属性的对象（某种程度上保持与内建 error 的兼容性）。 JavaScript 中有很多内建的标准 error 的构造器：Error，SyntaxError，ReferenceError，TypeError 等。我们也可以使用它们来创建 error 对象。
* 变量和 try...catch...finally 中的局部变量: 请注意，上面代码中的 result 和 diff 变量都是在 try...catch 之前 声明的。 否则，如果我们使用 let 在 try 块中声明变量，那么该变量将只在 try 块中可见。
* finally 和 return: finally 子句适用于 try...catch 的 任何 出口。这包括显式的 return。 在下面这个例子中，在 try 中有一个 return。在这种情况下，finally 会在控制转向外部代码前被执行。
* 全局 catch: 环境特定: 这个部分的内容并不是 JavaScript 核心的一部分。设想一下，在 try...catch 结构外有一个致命的 error，然后脚本死亡了。这个 error 就像编程错误或其他可怕的事儿那样。 有什么办法可以用来应对这种情况吗？我们可能想要记录这个 error，并向用户显示某些内容（通常用户看不到错误信息）等。 规范中没有相关内容，但是代码的执行环境一般会提供这种机制，因为它确实很有用。例如，Node.JS 有 process.on("uncaughtException")。在浏览器中，我们可以将将一个函数赋值给特殊的 [window.onerror](https://developer.mozilla.org/zh/docs/Web/API/GlobalEventHandlers/onerror) 属性，该函数将在发生未捕获的 error 时执行。
* 我们可以正常地从 Error 和其他内建的 error 类中进行继承，。我们只需要注意 name 属性以及不要忘了调用 super。 我们可以使用 instanceof 来检查特定的 error。但有时我们有来自第三方库的 error 对象，并且在这儿没有简单的方法来获取它的类。那么可以将 name 属性用于这一类的检查。 包装异常是一项广泛应用的技术：用于处理低级别异常并创建高级别 error 而不是各种低级别 error 的函数。在上面的示例中，低级别异常有时会成为该对象的属性，例如 err.cause，但这不是严格要求的。
* Promise 类有 6 种静态方法：
  1. Promise.all(promises) —— 等待所有 promise 都 resolve 时，返回存放它们结果的数组。如果给定的任意一个 promise 为 reject，那么它就会变成 Promise.all 的 error，所有其他 promise 的结果都会被忽略。
  2. Promise.allSettled(promises)（ES2020 新增方法）—— 等待所有 promise 都 settle 时，并以包含以下内容的对象数组的形式返回它们的结果：
    * status: "fulfilled" 或 "rejected"
    * value（如果 fulfilled）或 reason（如果 rejected）。
  3. Promise.race(promises) —— 等待第一个 settle 的 promise，并将其 result/error 作为结果返回。
  4. Promise.any(promises)（ES2021 新增方法）—— 等待第一个 fulfilled 的 promise，并将其结果作为结果返回。如果所有 promise 都 rejected，Promise.any 则会抛出 AggregateError 错误类型的 error 实例。
  5. Promise.resolve(value) —— 使用给定 value 创建一个 resolved 的 promise。
  6. Promise.reject(error) —— 使用给定 error 创建一个 rejected 的 promise。
* Promisification 是一种很好的方法，特别是在你使用 async/await 的时候（请看下一章），但不是回调的完全替代。 请记住，一个 promise 可能只有一个结果，但从技术上讲，一个回调可能被调用很多次。 因此，promisification 仅适用于调用一次回调的函数。进一步的调用将被忽略。
* Promise 处理始终是异步的，因为所有 promise 行为都会通过内部的 “promise jobs” 队列，也被称为“微任务队列”（V8 术语）。 因此，.then/catch/finally 处理程序（handler）总是在当前代码完成后才会被调用。 如果我们需要确保一段代码在 .then/catch/finally 之后被执行，我们可以将它添加到链式调用的 .then 中。 在大多数 JavaScript 引擎中（包括浏览器和 Node.js），微任务（microtask）的概念与“事件循环（event loop）”和“宏任务（macrotasks）”紧密相关。由于这些概念跟 promise 没有直接关系，所以我们将在本教程另外一部分的 [事件循环：微任务和宏任务](https://zh.javascript.info/event-loop) 一章中对它们进行介绍。
* 函数前面的关键字 async 有两个作用： 让这个函数总是返回一个 promise。 允许在该函数内使用 await。 Promise 前的关键字 await 使 JavaScript 引擎等待该 promise settle，然后： 如果有 error，就会抛出异常 —— 就像那里调用了 throw error 一样。 否则，就返回结果。 这两个关键字一起提供了一个很好的用来编写异步代码的框架，这种代码易于阅读也易于编写。 有了 async/await 之后，我们就几乎不需要使用 promise.then/catch，但是不要忘了它们是基于 promise 的，因为有些时候（例如在最外层作用域）我们不得不使用这些方法。并且，当我们需要同时等待需要任务时，Promise.all 是很好用的。
* Reference Type 是语言内部的一个类型。 读取一个属性，例如在 obj.method() 中，. 返回的准确来说不是属性的值，而是一个特殊的 “Reference Type” 值，其中储存着属性的值和它的来源对象。 这是为了随后的方法调用 () 获取来源对象，然后将 this 设为它。 对于所有其它操作，Reference Type 会自动变成属性的值（在我们这个情况下是一个函数）。 这整个机制对我们是不可见的。它仅在一些微妙的情况下才重要，例如使用表达式从对象动态地获取一个方法时。
* DOM 不仅仅用于浏览器: DOM 规范解释了文档的结构，并提供了操作文档的对象。有的非浏览器设备也使用 DOM。 例如，下载 HTML 文件并对其进行处理的服务器端脚本也可以使用 DOM。但它们可能仅支持部分规范中的内容。
* 用于样式的 CSSOM: 另外也有一份针对 CSS 规则和样式表的、单独的规范 [CSS Object Model (CSSOM)](https://www.w3.org/TR/cssom-1/), 这份规范解释了如何将 CSS 表示为对象，以及如何读写这些对象。 当我们修改文档的样式规则时，CSSOM 与 DOM 是一起使用的。但实际上，很少需要 CSSOM，因为我们很少需要从 JavaScript 中修改 CSS 规则（我们通常只是添加/移除一些 CSS 类，而不是直接修改其中的 CSS 规则），但这也是可行的。
* 函数 alert/confirm/prompt 也是 BOM 的一部分：它们与文档（document）没有直接关系，但它代表了与用户通信的纯浏览器方法。
* 规范: BOM 是通用 HTML 规范 的一部分。 是的，你没听错。在 [https://html.spec.whatwg.org](https://html.spec.whatwg.org/) 中的 HTML 规范不仅是关于“HTML 语言”（标签，特性）的，还涵盖了一堆对象、方法和浏览器特定的 DOM 扩展。这就是“广义的 HTML”。此外，某些部分也有其他的规范，它们被列在 [https://spec.whatwg.org](https://spec.whatwg.org) 中。
* 空格和换行符都是完全有效的字符，就像字母和数字。它们形成文本节点并成为 DOM 的一部分。所以，例如，在上面的示例中，<head> 标签中的 <title> 标签前面包含了一些空格，并且该文本变成了一个 #text 节点（它只包含一个换行符和一些空格）。 只有两个顶级排除项： 
  * 由于历史原因，<head> 之前的空格和换行符均被忽略。 
  * 如果我们在 </body> 之后放置一些东西，那么它会被自动移动到 body 内，并处于 body 中的最下方，因为 HTML 规范要求所有内容必须位于 <body> 内。所以 </body> 之后不能有空格。
* 字符串开头/结尾处的空格，以及只有空格的文本节点，通常会被工具隐藏: 与 DOM 一起使用的浏览器工具（即将介绍）通常不会在文本的开始/结尾显示空格，并且在标签之间也不会显示空文本节点（换行符）。 开发者工具通过这种方式节省屏幕空间。 在本教程中，如果这些空格和空文本节点无关紧要时，我们在后面出现的关于 DOM 的示意图中会忽略它们。
* HTML 中的所有内容，甚至注释，都会成为 DOM 的一部分。 甚至 HTML 开头的 <!DOCTYPE...> 指令也是一个 DOM 节点。它在 DOM 树中位于 <html> 之前。很少有人知道这一点。我们不会触及那个节点，我们甚至不会在图表中绘制它，但它确实就在那里。 表示整个文档的 document 对象，在形式上也是一个 DOM 节点。 一共有 [12 种节点类型](https://dom.spec.whatwg.org/#node). 实际上，我们通常用到的是其中的 4 种：
  1. document — DOM 的“入口点”。
  2. 元素节点 — HTML 标签，树构建块。
  3. 文本节点 — 包含文本。
  4. 注释 — 有时我们可以将一些信息放入其中，它不会显示，但 JS 可以从 DOM 中读取它。
* 在浏览器调试器工具的右侧部分有以下子选项卡：
  * Styles — 我们可以看到按规则应用于当前元素的 CSS 规则，包括内建规则（灰色）。几乎所有内容都可以就地编辑，包括下面的方框的 dimension/margin/padding。
  * Computed — 按属性查看应用于元素的 CSS：对于每个属性，我们可以都可以看到赋予它的规则（包括 CSS 继承等）。
  * Event Listeners — 查看附加到 DOM 元素的事件侦听器（我们将在本教程的下一部分介绍它们）。
* 在我们处理 DOM 时，我们可能还希望对其应用 JavaScript。例如：获取一个节点并运行一些代码来修改它，以查看结果。以下是在元素（Elements）选项卡和控制台（Console）之间切换的一些技巧。 首先：
  * 在元素（Elements）选项卡中选择第一个 <li>。
  * 按下 Esc — 它将在元素（Elements）选项卡下方打开控制台（Console）。
  * 现在最后选中的元素可以通过 $0 来进行操作，先前选择的是 $1，等。 我们可以对它们执行一些命令。例如，$0.style.background = 'red' 使选定的列表项（list item）变成红色。
* 在这里，我们介绍了基础知识，入门最常用和最重要的行为。在 [https://developers.google.cn/web/tools/chrome-devtools](https://developers.google.cn/web/tools/chrome-devtools) 上有关于 Chrome 开发者工具的详细文档说明。学习这些工具的最佳方式就是到处点一点看一看，阅读菜单：大多数选项都很明显。而后，当你大致了解它们后，请阅读文档并学习其余内容。
* 在 DOM 的世界中，null 就意味着“不存在”: 在 DOM 中，null 值就意味着“不存在”或者“没有这个节点”。
* DOM 集合是只读的: DOM 集合，甚至可以说本章中列出的 所有 导航（navigation）属性都是只读的。 我们不能通过类似 childNodes\[i\] = ... 的操作来替换一个子节点。 修改子节点需要使用其它方法。我们将会在下一章中看到它们。
* DOM 集合是实时的: 除小部分例外，几乎所有的 DOM 集合都是 实时 的。换句话说，它们反映了 DOM 的当前状态。 如果我们保留一个对 elem.childNodes 的引用，然后向 DOM 中添加/移除节点，那么这些节点的更新会自动出现在集合中。
* 不要使用 for..in 来遍历集合: 可以使用 for..of 对集合进行迭代。但有时候人们会尝试使用 for..in 来迭代集合。 请不要这么做。for..in 循环遍历的是所有可枚举的（enumerable）属性。集合还有一些“额外的”很少被用到的属性，通常这些属性也是我们不期望得到的。
* 请不要使用以 id 命名的全局变量来访问元素: [在规范中](http://www.whatwg.org/specs/web-apps/current-work/#dom-window-nameditem) 对此行为进行了描述，所以它是一种标准。但这是注意考虑到兼容性才支持的。 浏览器尝试通过混合 JavaScript 和 DOM 的命名空间来帮助我们。对于内联到 HTML 中的简单脚本来说，这还行，但是通常来说，这不是一件好事。因为这可能会造成命名冲突。另外，当人们阅读 JavaScript 代码且看不到对应的 HTML 时，变量的来源就会不明显。 在本教程中，我们只会在元素来源非常明显时，为了简洁起见，才会使用 id 直接引用对应的元素。 在实际开发中，document.getElementById 是首选方法。
* id 必须是唯一的: id 必须是唯一的。在文档中，只能有一个元素带有给定的 id。 如果有多个元素都带有同一个 id，那么使用它的方法的行为是不可预测的，例如 document.getElementById 可能会随机返回其中一个元素。因此，请遵守规则，保持 id 的唯一性。
* 不要忘记字母 "s"！  新手开发者有时会忘记字符 "s"。也就是说，他们会调用 getElementByTagName 而不是 getElementsByTagName。 getElementById 中没有字母 "s"，是因为它只返回单个元素。但是 getElementsByTagName 返回的是元素的集合，所以里面有 "s"。
* 所有的 "getElementsBy*" 方法都会返回一个 实时的（live） 集合。这样的集合始终反映的是文档的当前状态，并且在文档发生更改时会“自动更新”。相反，querySelectorAll 返回的是一个 静态的 集合。就像元素的固定数组。
* console.dir(elem) 与 console.log(elem): 大多数浏览器在其开发者工具中都支持这两个命令：console.log 和 console.dir。它们将它们的参数输出到控制台中。对于 JavaScript 对象，这些命令通常做的是相同的事。 但对于 DOM 元素，它们是不同的： console.log(elem) 显示元素的 DOM 树。 console.dir(elem) 将元素显示为 DOM 对象，非常适合探索其属性。 你可以在 document.body 上尝试一下。
* 规范中的 IDL: 在规范中，DOM 类不是使用 JavaScript 来描述的，而是一种特殊的 [接口描述语言（Interface description language）](https://en.wikipedia.org/wiki/Interface_description_language), 简写为 IDL，它通常很容易理解。 在 IDL 中，所有属性以其类型开头。例如，DOMString 和 boolean 等。
* 当浏览器加载页面时，它会“读取”（或者称之为：“解析”）HTML 并从中生成 DOM 对象。对于元素节点，大多数标准的 HTML 特性（attributes）会自动变成 DOM 对象的属性（properties）。（译注：attribute 和 property 两词意思相近，为作区分，全文将 attribute 译为“特性”，property 译为“属性”，请读者注意区分。） 例如，如果标签是 <body id="page">，那么 DOM 对象就会有 body.id="page"。 但特性—属性映射并不是一一对应的！在 HTML 中，标签可能拥有特性（attributes）。当浏览器解析 HTML 文本，并根据标签创建 DOM 对象时，浏览器会辨别 标准的 特性并以此创建 DOM 属性。 所以，当一个元素有 id 或其他 标准的 特性，那么就会生成对应的 DOM 属性。但是非 标准的 特性则不会。请注意，一个元素的标准的特性对于另一个元素可能是未知的。例如 "type" 是 <input> 的一个标准的特性（ [HTMLInputElement](https://html.spec.whatwg.org/#htmlinputelement) ），但对于 <body>（ [HTMLBodyElement](https://html.spec.whatwg.org/#htmlbodyelement) ）来说则不是。规范中对相应元素类的标准的属性进行了详细的描述。
* 所以，如果一个特性不是标准的，那么就没有相对应的 DOM 属性。那我们有什么方法来访问这些特性吗？ 当然。所有特性都可以通过使用以下方法进行访问：
  * elem.hasAttribute(name) — 检查特性是否存在。
  * elem.getAttribute(name) — 获取这个特性值。
  * elem.setAttribute(name, value) — 设置这个特性值。
  * elem.removeAttribute(name) — 移除这个特性。
* DOM 属性是多类型的: DOM 属性不总是字符串类型的。例如，input.checked 属性（对于 checkbox 的）是布尔型的。还有其他的例子。style 特性是字符串类型的，但 style 属性是一个对象。
* 尽管大多数 DOM 属性都是字符串类型的。 有一种非常少见的情况，即使一个 DOM 属性是字符串类型的，但它可能和 HTML 特性也是不同的。例如，href DOM 属性一直是一个 完整的 URL，即使该特性包含一个相对路径或者包含一个 #hash。
* 当编写 HTML 时，我们会用到很多标准的特性。但是非标准的，自定义的呢？首先，让我们看看它们是否有用？用来做什么？ 有时，非标准的特性常常用于将自定义的数据从 HTML 传递到 JavaScript，或者用于为 JavaScript “标记” HTML 元素。但是自定义的特性也存在问题。如果我们出于我们的目的使用了非标准的特性，之后它被引入到了标准中并有了其自己的用途，该怎么办？HTML 语言是在不断发展的，并且更多的特性出现在了标准中，以满足开发者的需求。在这种情况下，自定义的属性可能会产生意料不到的影响。 为了避免冲突，存在 [data-*](https://html.spec.whatwg.org/#embedding-custom-non-visible-data-with-the-data-*-attributes) 特性。 **所有以 “data-” 开头的特性均被保留供程序员使用。它们可在 dataset 属性中使用。** 例如，如果一个 elem 有一个名为 "data-about" 的特性，那么可以通过 elem.dataset.about 取到它。像 data-order-state 这样的多词特性可以以驼峰式进行调用：dataset.orderState。使用 data-* 特性是一种合法且安全的传递自定义数据的方式。 请注意，我们不仅可以读取数据，还可以修改数据属性（data-attributes）。然后 CSS 会更新相应的视图。
* 如何再插入一条类似的消息？ 我们可以创建一个函数，并将代码放在其中。但是另一种方法是 克隆 现有的 div，并修改其中的文本（如果需要）。 当我们有一个很大的元素时，克隆的方式可能更快更简单。 调用 elem.cloneNode(true) 来创建元素的一个“深”克隆 — 具有所有特性（attribute）和子元素。如果我们调用 elem.cloneNode(false)，那克隆就不包括子元素。
* JavaScript 既可以修改类，也可以修改 style 属性。 相较于将样式写入 style 属性，我们应该首选通过 CSS 类的方式来添加样式。仅当类“无法处理”时，才应选择使用 style 属性的方式。
* elem.style 属性是一个对象，它对应于 "style" 特性（attribute）中所写的内容。elem.style.width="100px" 的效果等价于我们在 style 特性中有一个 width:100px 字符串。 对于多词（multi-word）属性，使用驼峰式 camelCase.
* 有时我们想要分配一个样式属性，稍后移除它。 例如，为了隐藏一个元素，我们可以设置 elem.style.display = "none"。 然后，稍后我们可能想要移除 style.display，就像它没有被设置一样。这里不应该使用 delete elem.style.display，而应该使用 elem.style.display = "" 将其赋值为空。
* 用 style.cssText 进行完全的重写: 通常，我们使用 style.* 来对各个样式属性进行赋值。我们不能像这样的 div.style="color: red; width: 100px" 设置完整的属性，因为 div.style 是一个对象，并且它是只读的。 想要以字符串的形式设置完整的样式，可以使用特殊属性 style.cssText. 我们很少使用这个属性，因为这样的赋值会删除所有现有样式：它不是进行添加，而是替换它们。有时可能会删除所需的内容。但是，当我们知道我们不会删除现有样式时，可以安全地将其用于新元素。 可以通过设置一个特性（attribute）来实现同样的效果：div.setAttribute('style', 'color: red...')。
* 计算值和解析值: 在 [CSS](https://drafts.csswg.org/cssom/#resolved-values) 中有两个概念： 计算 (computed) 样式值是所有 CSS 规则和 CSS 继承都应用后的值，这是 CSS 级联（cascade）的结果。它看起来像 height:1em 或 font-size:125%。 解析 (resolved) 样式值是最终应用于元素的样式值值。诸如 1em 或 125% 这样的值是相对的。浏览器将使用计算（computed）值，并使所有单位均为固定的，且为绝对单位，例如：height:20px 或 font-size:16px。对于几何属性，解析（resolved）值可能具有浮点，例如：width:50.5px。 很久以前，创建了 getComputedStyle 来获取计算（computed）值，但事实证明，解析（resolved）值要方便得多，标准也因此发生了变化。 所以，现在 getComputedStyle 实际上返回的是属性的解析值（resolved）。
* 应用于 :visited 链接的样式被隐藏了！ 可以使用 CSS 伪类 :visited 对被访问过的链接进行着色。 但 getComputedStyle 没有给出访问该颜色的方式，因为否则，任意页面都可以通过在页面上创建它，并通过检查样式来确定用户是否访问了某链接。 JavaScript 看不到 :visited 所应用的样式。此外，CSS 中也有一个限制，即禁止在 :visited 中应用更改几何形状的样式。这是为了确保一个不好的页面无法测试链接是否被访问，进而窥探隐私。
* JavaScript 中有许多属性可让我们读取有关元素宽度、高度和其他几何特征的信息。这些属性的值在技术上讲是数字，但这些数字其实是“像素（pixel）”，因此它们是像素测量值。
* scrollLeft/scrollTop 是可修改的: 大多数几何属性是只读的，但是 scrollLeft/scrollTop 是可修改的，并且浏览器会滚动该元素。 如果你点击下面的元素，则会执行代码 elem.scrollTop += 10。这使得元素内容向下滚动 10px。将 scrollTop 设置为 0 或一个大的值，例如 1e9，将会使元素滚动到顶部/底部。
* 不是 window.innerWidth/innerHeight: 浏览器也支持像 window.innerWidth/innerHeight 这样的属性。它们看起来像我们想要的，那为什么不使用它们呢？ 如果这里存在一个滚动条，并且滚动条占用了一些空间，那么 clientWidth/clientHeight 会提供没有滚动条（减去它）的 width/height。换句话说，它们返回的是可用于内容的文档的可见部分的 width/height。 window.innerWidth/innerHeight 包括了滚动条。 在大多数情况下，我们需要 可用 的窗口宽度以绘制或放置某些东西。也就是说，在滚动条内（如果有）。所以，我们应该使用 documentElement.clientHeight/clientWidth。
* DOCTYPE 很重要: 请注意：当 HTML 中没有 <!DOCTYPE HTML> 时，顶层级（top-level）几何属性的工作方式可能就会有所不同。可能会出现一些稀奇古怪的情况。 在现代 HTML 中，我们始终都应该写 DOCTYPE。
* 从理论上讲，由于根文档元素是 document.documentElement，并且它包围了所有内容，因此我们可以通过使用 documentElement.scrollWidth/scrollHeight 来测量文档的完整大小。 但是在该元素上，对于整个文档，这些属性均无法正常工作。在 Chrome/Safari/Opera 中，如果没有滚动条，documentElement.scrollHeight 甚至可能小于 documentElement.clientHeight！很奇怪，对吧？为什么这样？最好不要问。这些不一致来源于远古时代，而不是“聪明”的逻辑。
* 必须在 DOM 完全构建好之后才能通过 JavaScript 滚动页面。 例如，如果我们尝试通过 <head> 中的脚本滚动页面，它将无法正常工作。
* 禁止滚动: 有时候我们需要使文档“不可滚动”。例如，当我们需要用一条需要立即引起注意的大消息来覆盖文档时，我们希望访问者与该消息而不是与文档进行交互。 要使文档不可滚动，只需要设置 document.body.style.overflow = "hidden"。该页面将“冻结”在其当前滚动位置上。
* 要移动页面的元素，我们应该先熟悉坐标。 大多数 JavaScript 方法处理的是以下两种坐标系中的一个：
  * 相对于窗口 — 类似于 position:fixed，从窗口的顶部/左侧边缘计算得出。 我们将这些坐标表示为 clientX/clientY，当我们研究事件属性时，就会明白为什么使用这种名称来表示坐标。 
  * 相对于文档 — 与文档根（document root）中的 position:absolute 类似，从文档的顶部/左侧边缘计算得出。 我们将它们表示为 pageX/pageY。
* 为什么需要派生（derived）属性？如果有了 x/y，为什么还要还会存在 top/left？ 从数学上讲，一个矩形是使用其起点 (x,y) 和方向向量 (width,height) 唯一定义的。因此，其它派生属性是为了方便起见。 从技术上讲，width/height 可能为负数，从而允许“定向（directed）”矩形，例如代表带有正确标记的开始和结束的鼠标选择。 负的 width/height 值表示矩形从其右下角开始，然后向左上方“增长”。 这是一个矩形，其 width 和 height 均为负数（例如 width=-200，height=-100）：正如你所看到的，在这个例子中，left/top 与 x/y 不相等。 但是实际上，elem.getBoundingClientRect() 总是返回正数的 width/height，这里我们提及负的 width/height 只是为了帮助你理解，为什么这些看起来重复的属性，实际上并不是重复的。
* 对于在窗口之外的坐标，elementFromPoint 返回 null: 方法 document.elementFromPoint(x,y) 只对在可见区域内的坐标 (x,y) 起作用。 如果任何坐标为负或者超过了窗口的 width/height，那么该方法就会返回 null。 在大多数情况下，这种行为并不是一个问题，但是我们应该记住这一点。
* 事件处理程序: 事件 是某事发生的信号。所有的 DOM 节点都生成这样的信号（但事件不仅限于 DOM）。 为了对事件作出响应，我们可以分配一个 处理程序（handler）—— 一个在事件发生时运行的函数。 处理程序是在发生用户行为（action）时运行 JavaScript 代码的一种方式。
* 访问元素：this: 处理程序中的 this 的值是对应的元素。就是处理程序所在的那个元素。
* 我们可以将一个现存的函数用作处理程序：但要注意：函数应该是以 sayThanks 的形式进行赋值，而不是 sayThanks()。如果我们添加了括号，那么 sayThanks() 就变成了一个函数调用。所以，最后一行代码实际上获得的是函数执行的 结果，即 undefined（因为这个函数没有返回值）。此代码不会工作。……但在标记（markup）中，我们确实需要括号。这个区别很容易解释。当浏览器读取 HTML 特性（attribute）时，浏览器将会使用 特性中的内容 创建一个处理程序。
* addEventListener: 上述分配处理程序的方式的根本问题是 —— 我们不能为一个事件分配多个处理程序。 假设，在我们点击了一个按钮时，我们代码中的一部分想要高亮显示这个按钮，另一部分则想要显示一条消息。 我们想为此事件分配两个处理程序。但是，新的 DOM 属性将覆盖现有的 DOM 属性。Web 标准的开发者很早就了解到了这一点，并提出了一种使用特殊方法 addEventListener 和 removeEventListener 来管理处理程序的替代方法。它们没有这样的问题。
* 移除需要相同的函数：要移除处理程序，我们需要传入与分配的函数完全相同的函数。请注意 —— 如果我们不将函数存储在一个变量中，那么我们就无法移除它。由 addEventListener 分配的处理程序将无法被“读回”。
* 多次调用 addEventListener 允许添加多个处理程序，我们可以 同时 使用 DOM 属性和 addEventListener 来设置处理程序。但通常我们只使用其中一种方式。
* 对于某些事件，只能通过 addEventListener 设置处理程序：有些事件无法通过 DOM 属性进行分配。只能使用 addEventListener。 例如，DOMContentLoaded 事件，该事件在文档加载完成并且 DOM 构建完成时触发。所以 addEventListener 更通用。虽然这样的事件是特例而不是规则。
* 为了正确处理事件，我们需要更深入地了解发生了什么。不仅仅是 “click” 或 “keydown”，还包括鼠标指针的坐标是什么？按下了哪个键？等等。 当事件发生时，浏览器会创建一个 event 对象，将详细信息放入其中，并将其作为参数传递给处理程序。
* event 对象在 HTML 处理程序中也可用：如果我们在 HTML 中分配了一个处理程序，那么我们也可以使用 event 对象。这是可能的，因为当浏览器读取特性（attribute）时，它会创建像这样的处理程序：function(event) { alert(event.type) }。也就是说：它的第一个参数是 "event"，而主体取自于该特性（attribute）。
* 对象处理程序：handleEvent：我们不仅可以分配函数，还可以使用 addEventListener 将一个对象分配为事件处理程序。当事件发生时，就会调用该对象的 handleEvent 方法。正如我们所看到的，当 addEventListener 接收一个对象作为处理程序时，在事件发生时，它就会调用 obj.handleEvent(event) 来处理事件。我们也可以对此使用一个类。handleEvent 方法不必通过自身完成所有的工作。它可以调用其他特定于事件的方法。
* 冒泡：冒泡（bubbling）原理很简单。 当一个事件发生在一个元素上，它会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，然后一直向上到其他祖先上的处理程序。
* 几乎 所有事件都会冒泡。这句话中的关键词是“几乎”。 例如，focus 事件不会冒泡。同样，我们以后还会遇到其他例子。但这仍然是例外，而不是规则，大多数事件的确都是冒泡的。
* 父元素上的处理程序始终可以获取事件实际发生位置的详细信息。 引发事件的那个嵌套层级最深的元素被称为目标元素,可以通过 event.target 访问。 注意与 this（=event.currentTarget）之间的区别：
  * event.target —— 是引发事件的“目标”元素，它在冒泡过程中不会发生变化。
  * this —— 是“当前”元素，其中有一个当前正在运行的处理程序。
* 停止冒泡: 冒泡事件从目标元素开始向上冒泡。通常，它会一直上升到 <html>，然后再到 document 对象，有些事件甚至会到达 window，它们会调用路径上所有的处理程序。 但是任意处理程序都可以决定事件已经被完全处理，并停止冒泡。 用于停止冒泡的方法是 event.stopPropagation()。
* event.stopImmediatePropagation(): 如果一个元素在一个事件上有多个处理程序，即使其中一个停止冒泡，其他处理程序仍会执行。 换句话说，event.stopPropagation() 停止向上移动，但是当前元素上的其他处理程序都会继续运行。 有一个 event.stopImmediatePropagation() 方法，可以用于停止冒泡，并阻止当前元素上的处理程序运行。使用该方法之后，其他处理程序就不会被执行。
* 不要在没有需要的情况下停止冒泡！ 冒泡很方便。不要在没有真实需求时阻止它：除非是显而易见的，并且在架构上经过深思熟虑的。 有时 event.stopPropagation() 会产生隐藏的陷阱，以后可能会成为问题。通常，没有真正的必要去阻止冒泡。一项看似需要阻止冒泡的任务，可以通过其他方法解决。其中之一就是使用自定义事件，稍后我们会介绍它们此外，我们还可以将我们的数据写入一个处理程序中的 event 对象，并在另一个处理程序中读取该数据，这样我们就可以向父处理程序传递有关下层处理程序的信息。
* 事件处理的另一个阶段被称为“捕获（capturing）”。它很少被用在实际开发中，但有时是有用的。 [DOM 事件标准](http://www.w3.org/TR/DOM-Level-3-Events/) 描述了事件传播的 3 个阶段：
  * 捕获阶段（Capturing phase）—— 事件（从 Window）向下走近元素。
  * 目标阶段（Target phase）—— 事件到达目标元素。
  * 冒泡阶段（Bubbling phase）—— 事件从元素上开始冒泡。
* 捕获和冒泡允许我们实现一种被称为 事件委托 的强大的事件处理模式。 这个想法是，如果我们有许多以类似方式处理的元素，那么就不必为每个元素分配一个处理程序 —— 而是将单个处理程序放在它们的共同祖先上。 在处理程序中，我们获取 event.target 以查看事件实际发生的位置并进行处理。
* “行为”模式: 我们还可以使用事件委托将“行为（behavior）”以 声明方式 添加到具有特殊特性（attribute）和类的元素中。 行为模式分为两个部分：
  * 我们将自定义特性添加到描述其行为的元素。
  * 用文档范围级的处理程序追踪事件，如果事件发生在具有特定特性的元素上 —— 则执行行为（action）。
* 阻止浏览器行为: 有两种方式来告诉浏览器我们不希望它执行默认行为：
  * 主流的方式是使用 event 对象。有一个 event.preventDefault() 方法。
  * 如果处理程序是使用 on<event>（而不是 addEventListener）分配的，那返回 false 也同样有效。
* 保持语义，不要滥用: 从技术上来说，通过阻止默认行为并添加 JavaScript，我们可以自定义任何元素的行为。例如，我们可以使链接 <a> 像按钮一样工作，而按钮 <button> 也可以像链接那样工作（重定向到另一个 URL 等）。 但我们通常应该保留 HTML 元素的语义。例如 <a> 应该表现为导航（navigation），而不是按钮。 除了“只是一件好事”之外，这还会使你的 HTML 具有更好的可访问性。 另外，如果我们考虑使用带有 <a> 的示例，那么请注意：浏览器允许我们在新窗口中打开此类链接（通过右键单击它们以及其他方式）。大家都喜欢这么做。但是，如果我们使用 JavaScript 让按钮行为表现得像链接，甚至使用 CSS 将其样式设置成看起来也像链接，即使这样，但仍然无法在按钮上使用特定于 <a> 的浏览器功能。
* 创建自定义事件: 我们不仅可以分配事件处理程序，还可以从 JavaScript 生成事件。 自定义事件可用于创建“图形组件”。例如，我们自己的基于 JavaScript 的菜单的根元素可能会触发 open（打开菜单），select（有一项被选中）等事件来告诉菜单发生了什么。另一个代码可能会监听事件，并观察菜单发生了什么。 我们不仅可以生成出于自身目的而创建的全新事件，还可以生成例如 click 和 mousedown 等内建事件。这可能会有助于自动化测试。
* event.isTrusted: 有一种方法可以区分“真实”用户事件和通过脚本生成的事件。 对于来自真实用户操作的事件，event.isTrusted 属性为 true，对于脚本生成的事件，event.isTrusted 属性为 false。
* 尽管技术上可以生成像 click 或 keydown 这样的浏览器事件，但我们还是应谨慎使用它们。 我们不应该生成浏览器事件，因为这是运行处理程序的一种怪异（hacky）方式。大多数时候，这都是糟糕的架构。 可以生成原生事件： 如果第三方程序库不提供其他交互方式，那么这是使第三方程序库工作所需的一种肮脏手段。 对于自动化测试，要在脚本中“点击按钮”并查看接口是否正确响应。 使用我们自己的名称的自定义事件通常是出于架构的目的而创建的，以指示发生在菜单（menu），滑块（slider），轮播（carousel）等内部发生了什么。
* 防止复制: 如果我们想禁用选择以保护我们页面的内容不被复制粘贴，那么我们可以使用另一个事件：oncopy。如果你试图在 <div> 中复制一段文本，这是行不通的，因为默认行为 oncopy 被阻止了。 当然，用户可以访问页面的 HTML 源码，并且可以从那里获取内容，但并不是每个人都知道如何做到这一点。
* **根据浏览器的逻辑，鼠标指针随时可能位于单个元素上 —— 嵌套最多的那个元素（z-index 最大的那个）。** 因此，如果它转到另一个元素（甚至是一个后代），那么它将离开前一个元素。 请注意事件处理的另一个重要的细节。 后代的 mouseover 事件会冒泡。因此，如果 #parent 具有 mouseover 处理程序，它将被触发。
* 我们讲了 mouseover，mouseout，mousemove，mouseenter 和 mouseleave 事件。 以下这些内容要注意： 快速移动鼠标可能会跳过中间元素。 mouseover/out 和 mouseenter/leave 事件还有一个附加属性：relatedTarget。这就是我们来自/到的元素，是对 target 的补充。 即使我们从父元素转到子元素时，也会触发 mouseover/out 事件。浏览器假定鼠标一次只会位于一个元素上 —— 最深的那个。 mouseenter/leave 事件在这方面不同：它们仅在鼠标进入和离开元素时才触发。并且它们不会冒泡。
* 拖放（Drag’n’Drop）是一个很赞的界面解决方案。取某件东西并将其拖放是执行许多东西的一种简单明了的方式，从复制和移动文档（如在文件管理器中）到订购（将物品放入购物车）。 在现代 HTML 标准中有一个 [关于拖放的部分](https://html.spec.whatwg.org/multipage/interaction.html#dnd), 其中包含了例如 dragstart 和 dragend 等特殊事件。 这些事件使我们能够支持特殊类型的拖放，例如处理从 OS 文件管理器中拖动文件，并将其拖放到浏览器窗口中。之后，JavaScript 便可以访问此类文件中的内容。 但是，原生的拖放事件也有其局限性。例如，我们无法阻止从特定区域的拖动。并且，我们无法将拖动变成“水平”或“竖直”的。还有很多其他使用它们无法完成的拖放任务。并且，移动设备对此类事件的支持非常有限。有一些在此基础上已经将体系结构构建好的框架：DragZone，Droppable，Draggable 及其他 class。它们中的大多数做的都是与上述类似的事情，所以现在你应该很容易理解它们了。或者自己动手实现。正如你所看到的，其实挺简单的，有时候比基于第三方解决方案进行改写还容易。
* 让我们先做一个简短的概览，以便你对指针事件及其在其它事件类型中所处位置有个粗略认识。 很早以前，只存在鼠标事件。 后来，触屏设备开始普及，尤其是手机和平板电脑。为了使现有的脚本仍能正常工作，它们生成（现在仍生成）鼠标事件。例如，轻触屏幕就会生成 mousedown 事件。因此，触摸设备可以很好地与网页配合使用。 但是，触摸设备比鼠标具有更多的功能。例如，我们可以同时触控多点（多点触控）。然而，鼠标事件并没有相关属性来处理这种多点触控。 因此，引入了触摸事件，例如 touchstart、touchend 和 touchmove，它们具有特定于触摸的属性（这里不再赘述这些特性，因为指针事件更加完善）。 不过这还是不够完美。因为很多其他输入设备（如触控笔）都有自己的特性。而且同时维护两份分别处理鼠标事件和触摸事件的代码，显得有些笨重了。 为了解决这些问题，人们引入了全新的规范「指针事件」。它为各种指针输入设备提供了一套统一的事件。 目前，各大主流浏览器已经支持了 [Pointer Events Level 2](https://www.w3.org/TR/pointerevents2/) 标准，版本更新的 [Pointer Events Level 3](https://w3c.github.io/pointerevents/) 已经发布，并且大多数情况下与 Pointer Events Level 2 兼容。 因此，除非你写的代码需要兼容旧版本的浏览器，例如 IE 10 或 Safari 12 或更低的版本，否则无需继续使用鼠标事件或触摸事件 —— 我们可以使用指针事件。 这样，你的代码就可以在触摸设备和鼠标设备上都能正常工作了。
* 在代码中用 pointer<event> 替换 mouse<event>: 我们可以把代码中的 mouse<event> 都替换成 pointer<event>，程序仍然正常兼容鼠标设备。 替换之后，程序对触屏设备的支持会“魔法般”地提升。但是，我们可能需要在 CSS 中的某些地方添加 touch-action: none。
* 指针事件允许我们通过一份代码，同时处理鼠标、触摸和触控笔事件。 指针事件是鼠标事件的拓展。我们可以在事件名称中用 pointer 替换 mouse 来让我们的代码既能继续支持鼠标，也能更好地支持其他类型的设备。 对于浏览器可能会决定进行劫持并自行处理的拖放和复杂的触控交互 —— 请记住取消事件的默认操作，并在 CSS 中为涉及到的元素设置 touch-action: none。 指针事件还额外具备以下能力： 基于 pointerId 和 isPrimary 的多点触控支持。 针对特定设备的属性，例如 pressure 和 width/height 等。 指针捕获：我们可以把 pointerup/pointercancel 之前的所有指针事件重定向到一个特定的元素。 目前，指针事件已经被各大主流浏览器支持，尤其是如果不需要支持 IE10 和 Safari 12 以下的版本，我们可以放心地使用它们。不过即便是针对这些老式浏览器，也可以通过 polyfill 来让它们支持指针事件。
* 大小写敏感："KeyZ"，不是 "keyZ": 这是显而易见的，但人们仍会搞错。 请规避错误类型：它是 KeyZ，而不是 keyZ。像 event.code=="keyZ" 这样的检查不起作用："Key" 的首字母必须大写。
* 遗存: 过去曾经有一个 keypress 事件，还有事件对象的 keyCode、charCode 和 which 属性。 大多数浏览器对它们都存在兼容性问题，以致使该规范的开发者不得不弃用它们并创建新的现代的事件（本文上面所讲的这些事件），除此之外别无选择。旧的代码仍然有效，因为浏览器还在支持它们，但现在完全没必要再使用它们。
* 按一个按键总是会产生一个键盘事件，无论是符号键，还是例如 Shift 或 Ctrl 等特殊按键。唯一的例外是有时会出现在笔记本电脑的键盘上的 Fn 键。它没有键盘事件，因为它通常是被在比 OS 更低的级别上实现的。 键盘事件： keydown —— 在按下键时（如果长按按键，则将自动重复）， keyup —— 释放按键时。 键盘事件的主要属性： code —— “按键代码”（"KeyA"，"ArrowLeft" 等），特定于键盘上按键的物理位置。 key —— 字符（"A"，"a" 等），对于非字符（non-character）的按键，通常具有与 code 相同的值。 过去，键盘事件有时会被用于跟踪表单字段中的用户输入。这并不可靠，因为输入可能来自各种来源。我们有 input 和 change 事件来处理任何输入（稍后我们会在 [事件：change，input，cut，copy，paste](https://zh.javascript.info/events-change-input) 一章中进行介绍）。它们在任何类型的输入（包括复制粘贴或语音识别）后触发。 当我们真的想要键盘时，我们应该使用键盘事件。例如，对热键或特殊键作出反应。
* scroll 事件允许对页面或元素滚动作出反应。我们可以在这里做一些有用的事情。 例如：
  * 根据用户在文档中的位置显示/隐藏其他控件或信息。
  * 当用户向下滚动到页面末端时加载更多数据。
* 防止滚动: 我们如何使某些东西变成不可滚动？ 我们不能通过在 onscroll 监听器中使用 event.preventDefault() 来阻止滚动，因为它会在滚动发生 之后 才触发。 但是我们可以在导致滚动的事件上，例如在 pageUp 和 pageDown 的 keydown 事件上，使用 event.preventDefault() 来阻止滚动。 如果我们向这些事件中添加事件处理程序，并向其中添加 event.preventDefault()，那么滚动就不会开始。 启动滚动的方式有很多，使用 CSS 的 overflow 属性更加可靠。
* 更简短的表示方式：form.name: 还有一个更简短的表示方式：我们可以通过 form\[index/name\] 来访问元素。 换句话说，我们可以将 form.elements.login 写成 form.login。 这也有效，但是会有一个小问题：如果我们访问一个元素，然后修改它的 name，之后它仍然可以被通过旧的 name 访问到（当然也能通过新的 name 访问）。这通常来说并不是一个问题，因为我们很少修改表单元素的名字。
* 使用 textarea.value 而不是 textarea.innerHTML: 请注意，即使 <textarea>...</textarea> 将它们的 value 作为嵌套的 HTML 标签来保存，我们也绝不应该使用 textarea.innerHTML 来访问它。 它仅存储最初在页面上的 HTML，而不是存储的当前 value。
* 当用户点击某个元素或使用键盘上的 Tab 键选中时，该元素将会获得聚焦（focus）。还有一个 HTML 特性（attribute）autofocus 可以让焦点在网页加载时默认落在一个元素上，此外还有其它途径可以获得焦点。 聚焦到一个元素通常意味着：“准备在此处接受数据”，所以，这正是我们可以运行代码以初始化所需功能的时刻。 失去焦点的时刻（“blur”）可能更为重要。它可能发生在用户点击页面的其它地方，或者按下 Tab 键跳转到下一个表单字段，亦或是其它途径的时候。 失去焦点通常意味着：“数据已经输入完成”，所以我们可以运行代码来检查它，甚至可以将其保存到服务器上，或进行其他操作。
* JavaScript 导致的焦点丢失: 很多种原因可以导致焦点丢失。 其中之一就是用户点击了其它位置。当然 JavaScript 自身也可能导致焦点丢失，例如： 一个 alert 会将焦点移至自身，因此会导致元素失去焦点（触发 blur 事件），而当 alert 对话框被取消时，焦点又回重新回到原元素上（触发 focus 事件）。 如果一个元素被从 DOM 中移除，那么也会导致焦点丢失。如果稍后它被重新插入到 DOM，焦点也不会回到它身上。 这些特性有时候会导致 focus/blur 处理程序发生异常 —— 在不需要它们时触发。 最好的秘诀就是在使用这些事件时小心点。如果我们想要跟踪用户导致的焦点丢失，则应该避免自己造成的焦点丢失。
* focus/blur 委托: focus 和 blur 事件不会向上冒泡。这里有两个解决方案。 方案一，有一个遗留下来的有趣的特性（feature）：focus/blur 不会向上冒泡，但会在捕获阶段向下传播。方案二，可以使用 focusin 和 focusout 事件 —— 与 focus/blur 事件完全一样，只是它们会冒泡。 值得注意的是，必须使用 elem.addEventListener 来分配它们，而不是 on<event>。
* 如果我们想要处理对 <input> 的每次更改，那么此事件是最佳选择。 另一方面，input 事件不会在那些不涉及值更改的键盘输入或其他行为上触发，例如在输入时按方向键 ⇦ ⇨。无法阻止 oninput 中的任何事件: 当输入值更改后，就会触发 input 事件。 所以，我们无法使用 event.preventDefault() —— 已经太迟了，不会起任何作用了。
* 事件：cut，copy，paste: 这些事件发生于剪切/拷贝/粘贴一个值的时候。 它们属于 [ClipboardEvent](https://www.w3.org/TR/clipboard-apis/#clipboard-event-interfaces) 类，并提供了对剪切/拷贝/粘贴的数据的访问方法。 我们也可以使用 event.preventDefault() 来中止行为，然后什么都不会被复制/粘贴。我们不仅可以复制/粘贴文本，也可以复制/粘贴其他各种内容。例如，我们可以在操作系统的文件管理器中复制一个文件并进行粘贴。 这是因为 clipboardData 实现了 DataTransfer 接口，通常用于拖放和复制/粘贴。这超出了本文所讨论的范围，但你可以在 [DataTransfer](https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface) 规范 中进行详细了解。 另外，还有一个可以访问剪切板的异步 API：navigator.clipboard，详见 [Clipboard API 和事件规范](https://www.w3.org/TR/clipboard-apis/), [火狐浏览器（Firefox）尚未支持](https://caniuse.com/async-clipboard).
* 提交表单时，会触发 submit 事件，它通常用于在将表单发送到服务器之前对表单进行校验，或者中止提交，并使用 JavaScript 来处理表单。 form.submit() 方法允许从 JavaScript 启动表单发送。我们可以使用此方法动态地创建表单，并将其发送到服务器。
* 提交表单主要有两种方式： 第一种 —— 点击 <input type="submit"> 或 <input type="image">。 第二种 —— 在 input 字段中按下 Enter 键。 这两个行为都会触发表单的 submit 事件。处理程序可以检查数据，如果有错误，就显示出来，并调用 event.preventDefault()，这样表单就不会被发送到服务器了。
* submit 和 click 的关系: 在输入框中使用 Enter 发送表单时，会在 <input type="submit"> 上触发一次 click 事件。 这很有趣，因为实际上根本没有点击。
* 如果要手动将表单提交到服务器，我们可以调用 form.submit()。 这样就不会产生 submit 事件。这里假设如果开发人员调用 form.submit()，就意味着此脚本已经进行了所有相关处理。 有时该方法被用来手动创建和发送表单。
* HTML 页面的生命周期包含三个重要事件：
  * DOMContentLoaded —— 浏览器已完全加载 HTML，并构建了 DOM 树，但像 \<img\> 和样式表之类的外部资源可能尚未加载完成。
  * load —— 浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等。
  * beforeunload/unload —— 当用户正在离开页面时。
* 每个事件都是有用的：
  * DOMContentLoaded 事件 —— DOM 已经就绪，因此处理程序可以查找 DOM 节点，并初始化接口。
  * load 事件 —— 外部资源已加载完成，样式已被应用，图片大小也已知了。
  * beforeunload 事件 —— 用户正在离开：我们可以检查用户是否保存了更改，并询问他是否真的要离开。
  * unload 事件 —— 用户几乎已经离开了，但是我们仍然可以启动一些操作，例如发送统计数据。
* 不会阻塞 DOMContentLoaded 的脚本: 此规则有两个例外： 具有 async 特性（attribute）的脚本不会阻塞 DOMContentLoaded，[稍后](https://zh.javascript.info/script-async-defer) 我们会讲到。 使用 document.createElement('script') 动态生成并添加到网页的脚本也不会阻塞 DOMContentLoaded。
* 浏览器内建的自动填充: Firefox，Chrome 和 Opera 都会在 DOMContentLoaded 中自动填充表单。 例如，如果页面有一个带有登录名和密码的表单，并且浏览器记住了这些值，那么在 DOMContentLoaded 上，浏览器会尝试自动填充它们（如果得到了用户允许）。 因此，如果 DOMContentLoaded 被需要加载很长时间的脚本延迟触发，那么自动填充也会等待。你可能在某些网站上看到过（如果你使用浏览器自动填充）—— 登录名/密码字段不会立即自动填充，而是在页面被完全加载前会延迟填充。这实际上是 DOMContentLoaded 事件之前的延迟。
* 如果我们在文档加载完成之后设置 DOMContentLoaded 事件处理程序，会发生什么？ 很自然地，它永远不会运行。 在某些情况下，我们不确定文档是否已经准备就绪。我们希望我们的函数在 DOM 加载完成时执行，无论现在还是以后。 document.readyState 属性可以为我们提供当前加载状态的信息。 它有 3 个可能值： loading —— 文档正在被加载。 interactive —— 文档被全部读取。 complete —— 文档被全部读取，并且所有资源（例如图片等）都已加载完成。 所以，我们可以检查 document.readyState 并设置一个处理程序，或在代码准备就绪时立即执行它。
* 现代的网站中，脚本往往比 HTML 更“重”：它们的大小通常更大，处理时间也更长。 当浏览器加载 HTML 时遇到 <script>...</script> 标签，浏览器就不能继续构建 DOM。它必须立刻执行此脚本。对于外部脚本 <script src="..."></script> 也是一样的：浏览器必须等脚本下载完，并执行结束，之后才能继续处理剩余的页面。 这会导致两个重要的问题：
  * 脚本不能访问到位于它们下面的 DOM 元素，因此，脚本无法给它们添加处理程序等。
  * 如果页面顶部有一个笨重的脚本，它会“阻塞页面”。在该脚本下载并执行结束前，用户都不能看到页面内容
* defer: defer 特性告诉浏览器不要等待脚本。相反，浏览器将继续处理 HTML，构建 DOM。脚本会“在后台”下载，然后等 DOM 构建完成后，脚本才会执行。具有 defer 特性的脚本保持其相对顺序，就像常规脚本一样。 defer 特性仅适用于外部脚本: 如果 <script> 脚本没有 src，则会忽略 defer 特性。
* async 特性与 defer 有些类似。它也能够让脚本不阻塞页面。但是，在行为上二者有着重要的区别。 async 特性意味着脚本是完全独立的：
  * 浏览器不会因 async 脚本而阻塞（与 defer 类似）。
  * 其他脚本不会等待 async 脚本加载完成，同样，async 脚本也不会等待其他脚本。
  * DOMContentLoaded 和异步脚本不会彼此等待：
    * DOMContentLoaded 可能会发生在异步脚本之前（如果异步脚本在页面完成后才加载完成）
    * DOMContentLoaded 也可能发生在异步脚本之后（如果异步脚本很短，或者是从 HTTP 缓存中加载的）
* 换句话说，async 脚本会在后台加载，并在加载就绪时运行。DOM 和其他脚本不会等待它们，它们也不会等待其它的东西。async 脚本就是一个会在加载完成时执行的完全独立的脚本。就这么简单，现在明白了吧？当我们将独立的第三方脚本集成到页面时，此时采用异步加载方式是非常棒的：计数器，广告等，因为它们不依赖于我们的脚本，我们的脚本也不应该等待它们。
* 在实际开发中，defer 用于需要整个 DOM 的脚本，和/或脚本的相对执行顺序很重要的时候。 async 用于独立脚本，例如计数器或广告，这些脚本的相对执行顺序无关紧要。
* 没有脚本的页面应该也是可用的：请注意：如果你使用的是 defer 或 async，那么用于将在脚本加载完成 之前 先看到页面。 在这种情况下，某些图形组件可能尚未初始化完成。 因此，请记得添加一个“正在加载”的提示，并禁用尚不可用的按钮。以让用户可以清楚地看到，他现在可以在页面上做什么，以及还有什么是正在准备中的。
* 浏览器允许我们跟踪外部资源的加载 —— 脚本，iframe，图片等。 这里有两个事件：
  * onload —— 成功加载，
  * onerror —— 出现 error。
* onload/onerror 事件仅跟踪加载本身。 在脚本处理和执行期间可能发生的 error 超出了这些事件跟踪的范围。也就是说：如果脚本成功加载，则即使脚本中有编程 error，也会触发 onload 事件。如果要跟踪脚本 error，可以使用 window.onerror 全局处理程序。
* **要允许跨源访问，<script> 标签需要具有 crossorigin 特性（attribute），并且远程服务器必须提供特殊的 header。** 这里有三个级别的跨源访问：
  * 无 crossorigin 特性 —— 禁止访问。 
  * crossorigin="anonymous" —— 如果服务器的响应带有包含 * 或我们的源（origin）的 header Access-Control-Allow-Origin，则允许访问。浏览器不会将授权信息和 cookie 发送到远程服务器。 
  * crossorigin="use-credentials" —— 如果服务器发送回带有我们的源的 header Access-Control-Allow-Origin 和 Access-Control-Allow-Credentials: true，则允许访问。浏览器会将授权信息和 cookie 发送到远程服务器。
* MutationObserver 是一个内建对象，它观察 DOM 元素，并在检测到更改时触发回调。MutationObserver 可以对 DOM 的变化作出反应 —— 特性（attribute），文本内容，添加/删除元素。 我们可以用它来跟踪代码其他部分引入的更改，以及与第三方脚本集成。 MutationObserver 可以跟踪任何更改。config “要观察的内容”选项用于优化，避免不必要的回调调用以节省资源。
* 浏览器中 JavaScript 的执行流程和 Node.js 中的流程都是基于 事件循环 的。 理解事件循环的工作方式对于代码优化很重要，有时对于正确的架构也很重要。事件循环 的概念非常简单。它是一个在 JavaScript 引擎等待任务，执行任务和进入休眠状态等待更多任务这几个状态之间转换的无限循环。 引擎的一般算法： 
  1. 当有任务时： 从最先进入的任务开始执行。
  2. 休眠直到出现任务，然后转到第 1 步。
* 事件循环 的两个细节：
  * 引擎执行任务时永远不会进行渲染（render）。如果任务执行需要很长一段时间也没关系。仅在任务完成后才会绘制对 DOM 的更改。
  * 如果一项任务执行花费的时间过长，浏览器将无法执行其他任务，例如处理用户事件。因此，在一定时间后，浏览器会抛出一个如“页面未响应”之类的警报，建议你终止这个任务。这种情况常发生在有大量复杂的计算或导致死循环的程序错误时。
* Web Workers: 对于不应该阻塞事件循环的耗时长的繁重计算任务，我们可以使用 [Web Workers](https://html.spec.whatwg.org/multipage/workers.html). 这是在另一个并行线程中运行代码的方式。 Web Workers 可以与主线程交换消息，但是它们具有自己的变量和事件循环。 Web Workers 没有访问 DOM 的权限，因此，它们对于同时使用多个 CPU 内核的计算非常有用。
* 阻止弹窗: 在过去，很多恶意网站经常滥用弹窗。一个不好的页面可能会打开大量带有广告的弹窗。因此，现在大多数浏览器都会通过阻止弹窗来保护用户。 如果弹窗是在用户触发的事件处理程序（如 onclick）之外调用的，大多数浏览器都会阻止此类弹窗。
* 这种方式可以在某种程度上保护用户免受非必要的弹窗的影响，但是并没有完全阻止该功能。 如果弹窗是从 onclick 打开的，但是在 setTimeout 之后，该怎么办？这有点棘手。 试试运行一下这段代码：`setTimeout(() => window.open('http://google.com'), 3000);`, 这个弹窗在 Chrome 中会被打开，但是在 Firefox 中会被阻止。 ……如果我们减少延迟，则弹窗在 Firefox 中也会被打开： `setTimeout(() => window.open('http://google.com'), 1000);`, 区别在于 Firefox 可以接受 2000ms 或更短的延迟，但是超过这个时间 —— 则移除“信任”。所以，第一个弹窗被阻止，而第二个却没有。
* 同源策略: 只有在窗口是同源的时，窗口才能自由访问彼此的内容（相同的协议://domain:port）。 否则，例如，如果主窗口来自于 site.com，弹窗来自于 gmail.com，则处于安全性考虑，这两个窗口不能访问彼此的内容。有关详细信息，请参见 [跨窗口通信](https://zh.javascript.info/cross-window-communication) 一章。
* 关闭弹窗: 关闭一个窗口：win.close()。 检查一个窗口是否被关闭：win.closed。 从技术上讲，close() 方法可用于任何 window，但是如果 window 不是通过 window.open() 创建的，那么大多数浏览器都会忽略 window.close()。因此，close() 只对弹窗起作用。 如果窗口被关闭了，那么 closed 属性则为 true。这对于检查弹窗（或主窗口）是否仍处于打开状态很有用。用户可以随时关闭它，我们的代码应该考虑到这种可能性。
* 有一些方法可以移动一个窗口，或者调整一个窗口的大小：仅对于弹窗: 为了防止滥用，浏览器通常会阻止这些方法。它们仅在我们打开的，没有其他选项卡的弹窗中能够可靠地工作。
* 没有最小化/最大化: JavaScript 无法最小化或者最大化一个窗口。这些操作系统级别的功能对于前端开发者而言是隐藏的。 移动或者调整大小的方法不适用于最小化/最大化的窗口。
* “同源”策略规定：
  * 如果我们有对另外一个窗口（例如，一个使用 window.open 创建的弹窗，或者一个窗口中的 iframe）的引用，并且该窗口是同源的，那么我们就具有对该窗口的全部访问权限。
  * 否则，如果该窗口不是同源的，那么我们就无法访问该窗口中的内容：变量，文档，任何东西。唯一的例外是 location：我们可以修改它（进而重定向用户）。但是我们无法读取 location（因此，我们无法看到用户当前所处的位置，也就不会泄漏任何信息）。
* 根据定义，两个具有不同域的 URL 具有不同的源。 但是，如果窗口的二级域相同，例如 john.site.com，peter.site.com 和 site.com（它们共同的二级域是 site.com），我们可以使浏览器忽略该差异，使得它们可以被作为“同源”的来对待，以便进行跨窗口通信。 为了做到这一点，每个这样的窗口都应该执行下面这行代码：`document.domain = 'site.com';`, 这样就可以了。现在它们可以无限制地进行交互了。但是再强调一遍，这仅适用于具有相同二级域的页面。
* 请注意："sandbox" 特性的目的仅是 添加更多 限制。它无法移除这些限制。尤其是，如果 iframe 来自其他源，则无法放宽同源策略。
* 我们以 Facebook 为例，解释点击劫持是如何完成的：
  1. 访问者被恶意页面吸引。怎样吸引的不重要。
  2. 页面上有一个看起来无害的链接（例如：“变得富有”或者“点我，超好玩！”）。
  3. 恶意页面在该链接上方放置了一个透明的 <iframe>，其 src 来自于 facebook.com，这使得“点赞”按钮恰好位于该链接上面。这通常是通过 z-index 实现的。
  4. 用户尝试点击该链接时，实际上点击的是“点赞”按钮。
* 点击劫持是对点击事件，而非键盘事件: 此攻击仅影响鼠标行为（或者类似的行为，例如在手机上的点击）。 键盘输入很难重定向。从技术上讲，我们可以用 iframe 的文本区域覆盖原有的文本区域实现攻击。因此，当访问者试图聚焦页面中的输入时，实际上聚焦的是 iframe 中的输入。 但是这里有个问题。访问者键入的所有内容都会被隐藏，因为该 iframe 是不可见的。 当用户无法在屏幕上看到自己输入的字符时，通常会停止打字。
* 点击劫持是一种“诱骗”用户在不知情的情况下点击恶意网站的方式。如果是重要的点击操作，这是非常危险的。 黑客可以通过信息发布指向他的恶意页面的链接，或者通过某些手段引诱访问者访问他的页面。当然还有很多其他变体。 一方面 —— 这种攻击方式是“浅层”的：黑客所做的只是拦截一次点击。但另一方面，如果黑客知道在点击之后将出现另一个控件，则他们可能还会使用狡猾的消息来迫使用户也点击它们。 这种攻击相当危险，因为在设计交互界面时，我们通常不会考虑到可能会有黑客代表用户点击界面。所以，在许多意想不到的地方可能发现攻击漏洞。 
  * 建议在那些不希望被在 frame 中查看的页面上（或整个网站上）使用 X-Frame-Options: SAMEORIGIN。 
  * 如果我们希望允许在 frame 中显示我们的页面，那我们使用一个 <div> 对整个页面进行遮盖，这样也是安全的。
* 与其他语言相比，JavaScript 中的二进制数据是以非标准方式实现的。但是，当我们理清楚以后，一切就会变得相当简单了。 **基本的二进制对象是 ArrayBuffer —— 对固定长度的连续内存空间的引用。**
* ArrayBuffer 不是某种东西的数组, 让我们先澄清一个可能的误区。ArrayBuffer 与 Array 没有任何共同之处：
  * 它的长度是固定的，我们无法增加或减少它的长度。
  * 它正好占用了内存中的那么多空间。
  * 要访问单个字节，需要另一个“视图”对象，而不是 buffer\[index\]。
* 所有这些视图（Uint8Array，Uint32Array 等）的通用术语是 [TypedArray](https://tc39.github.io/ecma262/#sec-typedarray-objects). 它们都享有同一组方法和属性。 请注意，没有名为 TypedArray 的构造器，它只是表示 ArrayBuffer 上的视图之一的通用总称术语：Int8Array，Uint8Array 及其他，很快就会有完整列表。 当你看到 new TypedArray 之类的内容时，它表示 new Int8Array、new Uint8Array 及其他中之一。 类型化数组的行为类似于常规数组：具有索引，并且是可迭代的。 一个类型化数组的构造器（无论是 Int8Array 或 Float64Array，都无关紧要），其行为各不相同，并且取决于参数类型。
* 没有 int8 或类似的单值类型: 请注意，尽管有类似 Int8Array 这样的名称，但 JavaScript 中并没有像 int，或 int8 这样的单值类型。 这是合乎逻辑的，因为 Int8Array 不是这些单值的数组，而是 ArrayBuffer 上的视图。
* 如果二进制数据实际上是一个字符串怎么办？例如，我们收到了一个包含文本数据的文件。 内建的 [TextDecoder](https://encoding.spec.whatwg.org/#interface-textdecoder) 对象在给定缓冲区（buffer）和编码格式（encoding）的情况下，能够将值读取到实际的 JavaScript 字符串中。
* TextEncoder 做相反的事情 —— 将字符串转换为字节。语法为：`let encoder = new TextEncoder();`, 只支持 utf-8 编码。
* arrayBuffer 和视图（view）都是 ECMA 标准的一部分，是 JavaScript 的一部分。 在浏览器中，还有其他更高级的对象，特别是 Blob，在 [File API](https://www.w3.org/TR/FileAPI/) 中有相关描述。 Blob 由一个可选的字符串 type（通常是 MIME 类型）和 blobParts 组成 —— 一系列其他 Blob 对象，字符串和 BufferSource。
* Blob 对象是不可改变的: 我们无法直接在 Blob 中更改数据，但我们可以通过 slice 获得 Blob 的多个部分，从这些部分创建新的 Blob 对象，将它们组成新的 Blob，等。 这种行为类似于 JavaScript 字符串：我们无法更改字符串中的字符，但可以生成一个新的改动过的字符串。
* Blob 转换为 base64: URL.createObjectURL 的一个替代方法是，将 Blob 转换为 base64-编码的字符串。 这种编码将二进制数据表示为一个由 0 到 64 的 ASCII 码组成的字符串，非常安全且“可读“。更重要的是 —— 我们可以在 [“data-url”](https://developer.mozilla.org/zh/docs/Web/http/Data_URIs) 中使用此编码。 “data-url” 的形式为 data:\[<mediatype>\]\[;base64\],<data>。我们可以在任何地方使用这种 url，和使用“常规” url 一样。
* [File](https://www.w3.org/TR/FileAPI/#dfn-file) 对象继承自 Blob，并扩展了与文件系统相关的功能。
* [FileReader](https://www.w3.org/TR/FileAPI/#dfn-filereader) 是一个对象，其唯一目的是从 Blob（因此也从 File）对象中读取数据。 它使用事件来传递数据，因为从磁盘读取数据可能比较费时间。
* FileReader 用于 blob: 正如我们在 [Blob](https://zh.javascript.info/blob) 一章中所提到的，FileReader 不仅可读取文件，还可读取任何 blob。 我们可以使用它将 blob 转换为其他格式：
  * readAsArrayBuffer(blob) —— 转换为 ArrayBuffer，
  * readAsText(blob, \[encoding\]) —— 转换为字符串（TextDecoder 的一个替代方案），
  * readAsDataURL(blob) —— 转换为 base64 的 data url。
* 在 Web Workers 中可以使用 FileReaderSync: 对于 Web Worker，还有一种同步的 FileReader 变体，称为 [FileReaderSync](https://www.w3.org/TR/FileAPI/#FileReaderSync). 它的读取方法 read* 不会生成事件，但是会像常规函数那样返回一个结果。 不过，这仅在 Web Worker 中可用，因为在读取文件的时候，同步调用会有延迟，而在 Web Worker 中，这种延迟并不是很重要。它不会影响页面。
* 对于来自 JavaScript 的网络请求，有一个总称术语 “AJAX”（Asynchronous JavaScript And XML 的简称）。但是，我们不必使用 XML：这个术语诞生于很久以前，所以这个词一直在那儿。 有很多方式可以向服务器发送网络请求，并从服务器获取信息。 fetch() 方法是一种现代通用的方法，那么我们就从它开始吧。旧版本的浏览器不支持它（可以 polyfill），但是它在现代浏览器中的支持情况很好。
* [FormData](https://xhr.spec.whatwg.org/#interface-formdata) 对象用于捕获 HTML 表单，并使用 fetch 或其他网络方法提交。 我们可以从 HTML 表单创建 new FormData(form)，也可以创建一个完全没有表单的对象，然后使用以下方法附加字段：
  * formData.append(name, value)
  * formData.append(name, blob, fileName)
  * formData.set(name, value)
  * formData.set(name, blob, fileName)
* fetch 方法允许去跟踪 下载 进度。 请注意：到目前为止，fetch 方法无法跟踪 上传 进度。对于这个目的，请使用 [XMLHttpRequest](https://zh.javascript.info/xmlhttprequest), 我们在后面章节会讲到。 要跟踪下载进度，我们可以使用 response.body 属性。它是 ReadableStream —— 一个特殊的对象，它可以逐块（chunk）提供 body。在 [Streams API](https://streams.spec.whatwg.org/#rs-class) 规范中有对 ReadableStream 的详细描述。 与 response.text()，response.json() 和其他方法不同，response.body 给予了对进度读取的完全控制，我们可以随时计算下载了多少。
* AbortController 是一个简单的对象，当 abort() 方法被调用时，会在自身的 signal 属性上生成 abort 事件（并将 signal.aborted 设置为 true）。 fetch 与之集成：我们将 signal 属性作为可选参数（option）进行传递，之后 fetch 会监听它，因此它能够中止 fetch。 我们可以在我们的代码中使用 AbortController。“调用 abort()” → “监听 abort 事件”交互简单且通用。即使没有 fetch，我们也可以使用它。
* 如果我们向另一个网站发送 fetch 请求，则该请求可能会失败。这里的核心概念是 源（origin）—— 域（domain）/端口（port）/协议（protocol）的组合。 跨源请求 —— 那些发送到其他域（即使是子域）、协议或端口的请求 —— 需要来自远程端的特殊 header。 这个策略被称为 “CORS”：跨源资源共享（Cross-Origin Resource Sharing）。
* 这是所有可能的 fetch 选项及其默认值（注释中标注了可选值）的完整列表：
  ```text
  let promise = fetch(url, {
    method: "GET", // POST，PUT，DELETE，等。
    headers: {
      // 内容类型 header 值通常是自动设置的
      // 取决于 request body
      "Content-Type": "text/plain;charset=UTF-8"
    },
    body: undefined // string，FormData，Blob，BufferSource，或 URLSearchParams
    referrer: "about:client", // 或 "" 以不发送 Referer header，
    // 或者是当前源的 url
    referrerPolicy: "no-referrer-when-downgrade", // no-referrer，origin，same-origin...
    mode: "cors", // same-origin，no-cors
    credentials: "same-origin", // omit，include
    cache: "default", // no-store，reload，no-cache，force-cache，或 only-if-cached
    redirect: "follow", // manual，error
    integrity: "", // 一个 hash，像 "sha256-abcdef1234567890"
    keepalive: false, // true
    signal: undefined, // AbortController 来中止请求
    window: window // null
  });
  ```
* 内建的 [URL](https://url.spec.whatwg.org/#api) 类提供了用于创建和解析 URL 的便捷接口。 没有任何一个网络方法一定需要使用 URL 对象，字符串就足够了。所以从技术上讲，我们并不是必须使用 URL。但是有些时候 URL 对象真的很有用。我们可以将 URL 对象传递给网络（和大多数其他）方法，而不是字符串: 我们可以在 fetch 或 XMLHttpRequest 中使用 URL 对象，几乎可以在任何需要 URL 字符串的地方都能使用 URL 对象。 通常，URL 对象可以替代字符串传递给任何方法，因为大多数方法都会执行字符串转换，这会将 URL 对象转换为具有完整 URL 的字符串。
* 假设，我们想要创建一个具有给定搜索参数的 url，例如：`https://google.com/search?query=JavaScript`. 我们可以在 URL 字符串中提供它们。……但是，如果参数中包含空格，非拉丁字母等（具体参见下文），参数就需要被编码。 因此，有一个 URL 属性用于解决这个问题：url.searchParams，[URLSearchParams](https://url.spec.whatwg.org/#urlsearchparams) 类型的对象。 它为搜索参数提供了简便的方法：
  * append(name, value) —— 按照 name 添加参数，
  * delete(name) —— 按照 name 移除参数，
  * get(name) —— 按照 name 获取参数，
  * getAll(name) —— 获取相同 name 的所有参数（这是可行的，例如 ?user=John&user=Pete），
  * has(name) —— 按照 name 检查参数是否存在，
  * set(name, value) —— set/replace 参数，
  * sort() —— 按 name 对参数进行排序，很少使用，
  * ……并且它是可迭代的，类似于 Map。
* 我们可以看到，encodeURI 没有对 & 进行编码，因为它对于整个 URL 来说是合法的字符。 但是，我们应该编码在搜索参数中的 & 字符，否则，我们将得到 q=Rock&Roll —— 实际上是 q=Rock 加上某个晦涩的参数 Roll。不符合预期。 因此，对于每个搜索参数，我们应该使用 encodeURIComponent，以将其正确地插入到 URL 字符串中。最安全的方式是对 name 和 value 都进行编码，除非我们能够绝对确保它只包含允许的字符。
* 在现代 Web 开发中，出于以下三种原因，我们还在使用 XMLHttpRequest：
  * 历史原因：我们需要支持现有的使用了 XMLHttpRequest 的脚本。
  * 我们需要兼容旧浏览器，并且不想用 polyfill（例如为了使脚本更小）。
  * 我们需要做一些 fetch 目前无法做到的事情，例如跟踪上传进度。
* Header 的限制: 一些 header 是由浏览器专门管理的，例如 Referer 和 Host。 完整列表请见 [规范](http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader-method). 为了用户安全和请求的正确性，XMLHttpRequest 不允许更改它们。
* 不能移除 header: XMLHttpRequest 的另一个特点是不能撤销 setRequestHeader。 一旦设置了 header，就无法撤销了。其他调用会向 header 中添加信息，但不会覆盖它。
* 长轮询是与服务器保持持久连接的最简单的方式，它不使用任何特定的协议，例如 WebSocket 或者 Server Sent Event。 它很容易实现，在很多场景下也很好用。
* 服务器应该可以处理许多挂起的连接: 服务器架构必须能够处理许多挂起的连接。 某些服务器架构是每个连接对应一个进程，导致进程数和连接数一样多，而每个进程都会消耗相当多的内存。因此，过多的连接会消耗掉全部内存。 使用像 PHP 和 Ruby 语言编写的后端程序会经常遇到这个问题。 使用 Node.js 编写的服务端程序通常不会出现此类问题。 也就是说，这不是编程语言的问题。大多数现代编程语言，包括 PHP 和 Ruby，都允许实现更适当的后端程序。只是请确保你的服务器架构在同时有很多连接的情况下能够正常工作。
* 在消息很少的情况下，长轮询很有效。 如果消息比较频繁，那么上面描绘的请求-接收（requesting-receiving）消息的图表就会变成锯状状（saw-like）。 每个消息都是一个单独的请求，并带有 header，身份验证开销（authentication overhead）等。 因此，在这种情况下，首选另一种方法，例如：[Websocket](https://zh.javascript.info/websocket) 或 [Server Sent Events](https://zh.javascript.info/server-sent-events).
* 在 [RFC 6455](http://tools.ietf.org/html/rfc6455) 规范中描述的 WebSocket 协议提供了一种在浏览器和服务器之间建立持久连接来交换数据的方法。数据可以作为“数据包”在两个方向上传递，而不会断开连接和其他 HTTP 请求。 对于需要连续数据交换的服务，例如网络游戏，实时交易系统等，WebSocket 尤其有用。
* 始终使用 wss://    wss:// 协议不仅是被加密的，而且更可靠。 因为 ws:// 数据不是加密的，对于任何中间人来说其数据都是可见的。并且，旧的代理服务器不了解 WebSocket，它们可能会因为看到“奇怪的” header 而中止连接。 另一方面，wss:// 是基于 TLS 的 WebSocket，类似于 HTTPS 是基于 TLS 的 HTTP），传输安全层在发送方对数据进行了加密，在接收方进行解密。因此，数据包是通过代理加密传输的。它们看不到传输的里面的内容，且会让这些数据通过。
* 无法模拟 WebSocket 握手: 我们不能使用 XMLHttpRequest 或 fetch 来进行这种 HTTP 请求，因为不允许 JavaScript 设置这些 header。
* WebSocket 是一种在浏览器和服务器之间建立持久连接的现代方式。
  * WebSocket 没有跨源限制。
  * 浏览器对 WebSocket 支持很好。
  * 可以发送/接收字符串和二进制数据。
* WebSocket 自身并不包含重新连接（reconnection），身份验证（authentication）和很多其他高级机制。因此，有针对于此的客户端/服务端的库，并且也可以手动实现这些功能。 有时为了将 WebSocket 集成到现有项目中，人们将主 HTTP 服务器与 WebSocket 服务器并行运行，并且它们之间共享同一个数据库。对于 WebSocket 请求使用一个通向 WebSocket 服务器的子域 wss://ws.site.com，而 https://site.com 则通向主 HTTP 服务器。 当然，其他集成方式也是可行的。
* 与 WebSocket 相比，EventSource 是与服务器通信的一种不那么强大的方式。 我们为什么要使用它？ 主要原因：简单。在很多应用中，WebSocket 有点大材小用。 我们需要从服务器接收一个数据流：可能是聊天消息或者市场价格等。这正是 EventSource 所擅长的。它还支持自动重新连接，而在 WebSocket 中这个功能需要我们手动实现。此外，它是一个普通的旧的 HTTP，不是一个新协议。
* EventSource 对象自动建立一个持久的连接，并允许服务器通过这个连接发送消息。 它提供了：
  * 在可调的 retry 超时内自动重新连接。
  * 用于恢复事件的消息 id，重新连接后，最后接收到的标识符被在 Last-Event-ID header 中发送出去。
  * 当前状态位于 readyState 属性中。
* 这使得 EventSource 成为 WebSocket 的一个可行的替代方案，因为 WebSocket 更低级（low-level），且缺乏这样的内建功能（尽管它们可以被实现）。 在很多实际应用中，EventSource 的功能就已经够用了。 EventSource 在所有现代浏览器（除了 IE）中都得到了支持。
* Cookie 是直接存储在浏览器中的一小串数据。它们是 HTTP 协议的一部分，由 [RFC 6265](https://tools.ietf.org/html/rfc6265) 规范定义。 Cookie 通常是由 Web 服务器使用响应 Set-Cookie HTTP-header 设置的。然后浏览器使用 Cookie HTTP-header 将它们自动添加到（几乎）每个对相同域的请求中。 最常见的用处之一就是身份验证：
  * 登录后，服务器在响应中使用 Set-Cookie HTTP-header 来设置具有唯一“会话标识符（session identifier）”的 cookie。
  * 下次如果请求是由相同域发起的，浏览器会使用 Cookie HTTP-header 通过网络发送 cookie。
  * 所以服务器知道是谁发起了请求。
* 限制: 存在一些限制： encodeURIComponent 编码后的 name=value 对，大小不能超过 4KB。因此，我们不能在一个 cookie 中保存大的东西。 每个域的 cookie 总数不得超过 20+ 左右，具体限制取决于浏览器。
* httpOnly: 这个选项和 JavaScript 没有关系，但是我们必须为了完整性也提一下它。 Web 服务器使用 Set-Cookie header 来设置 cookie。并且，它可以设置 httpOnly 选项。 这个选项禁止任何 JavaScript 访问 cookie。我们使用 document.cookie 看不到此类 cookie，也无法对此类 cookie 进行操作。 这是一种预防措施，当黑客将自己的 JavaScript 代码注入网页，并等待用户访问该页面时发起攻击，而这个选项可以防止此时的这种攻击。这应该是不可能发生的，黑客应该无法将他们的代码注入我们的网站，但是网站有可能存在 bug，使得黑客能够实现这样的操作。 通常来说，如果发生了这种情况，并且用户访问了带有黑客 JavaScript 代码的页面，黑客代码将执行并通过 document.cookie 获取到包含用户身份验证信息的 cookie。这就很糟糕了。 但是，如果 cookie 设置了 httpOnly，那么 document.cookie 则看不到 cookie，所以它受到了保护。
* 更新或删除必须使用相同的路径和域: 请注意：当我们更新或删除一个 cookie 时，我们应该使用和设置 cookie 时相同的路径和域选项。
* 请注意：如果我们加载了一个来自第三方域的脚本，例如 <script src="https://google-analytics.com/analytics.js">，并且该脚本使用 document.cookie 设置了 cookie，那么此类 cookie 就不是第三方的。 如果一个脚本设置了一个 cookie，那么无论脚本来自何处 —— 这个 cookie 都属于当前网页的域。
* 网站为了遵循 GDPR 通常有两种做法。你一定已经在网站中看到过它们了：
  * 如果一个网站想要仅为已经经过身份验证的用户设置跟踪的 cookie。 为此，注册表单中必须要有一个复选框，例如“接受隐私政策”（描述怎么使用 cookie），用户必须勾选它，然后网站就可以自由设置身份验证 cookie 了。
  * 如果一个网站想要为所有人设置跟踪的 cookie。 为了合法地这样做，网站为每个新用户显示一个模态“初始屏幕”，并要求他们同意设置 cookie。之后网站就可以设置 cookie，并可以让用户看到网站内容了。不过，这可能会使新用户感到反感。没有人喜欢看到“必须点击”的模态初始屏幕而不是网站内容。但是 GDPR 要求必须得到用户明确地准许。
* Web 存储对象 localStorage 和 sessionStorage 允许我们在浏览器中保存键/值对。
  * key 和 value 都必须为字符串。
  * 存储大小限制为 5MB+，具体取决于浏览器。
  * 它们不会过期。
  * 数据绑定到源（域/端口/协议）。
* 我们无法打开旧版本的数据库: 如果当前用户的数据库版本比 open 调用的版本更高（比如当前的数据库版本为 3，我们却尝试运行 open(...2)，就会产生错误并触发 openRequest.onerror）。 这很罕见，但这样的事情可能会在用户加载了一个过时的 JavaScript 代码时发生（例如用户从一个代理缓存中加载 JS）。在这种情况下，代码是过时的，但数据库却是最新的。 为了避免这样的错误产生，我们应当检查 db.version 并建议用户重新加载页面。使用正确的 HTTP 缓存头（header）来避免之前缓存的旧代码被加载，这样你就永远不会遇到此类问题。
* 要在 IndexedDB 中存储某些内容，我们需要一个 对象库。 对象库是 IndexedDB 的核心概念，在其他数据库中对应的对象称为“表”或“集合”。它是储存数据的地方。一个数据库可能有多个存储区：一个用于存储用户数据，另一个用于商品，等等。 尽管被命名为“对象库”，但也可以存储原始类型。 几乎可以存储任何值，包括复杂的对象。 IndexedDB 使用 [标准序列化算法](https://www.w3.org/TR/html53/infrastructure.html#section-structuredserializeforstorage) 来克隆和存储对象。类似于 JSON.stringify，不过功能更加强大，能够存储更多的数据类型。 有一种对象不能被存储：循环引用的对象。此类对象不可序列化，也不能进行 JSON.stringify。 库中的每个值都必须有唯一的键 key。 键的类型必须为数字、日期、字符串、二进制或数组。它是唯一的标识符，所以我们可以通过键来搜索/删除/更新值。
* 为什么会有不同类型的事务？性能是事务需要标记为 readonly 和 readwrite 的原因。 许多 readonly 事务能够同时访问同一存储区，但 readwrite 事务不能。因为 readwrite 事务会“锁定”存储区进行写操作。下一个事务必须等待前一个事务完成，才能访问相同的存储区。
* 但正如前面提到的，一个事务可能有多个相关的请求，这些请求必须全部成功或全部失败。那么我们如何将事务标记为已完成，并不再请求呢？ 简短的回答是：没有。 在下一个版本 3.0 规范中，可能会有一种手动方式来完成事务，但目前在 2.0 中还没有。IndexedDB 规范的作者认为事务应该是短期的。主要是性能原因。
* 对象库始终是有序的: 对象库按键对值进行内部排序。 因此，请求的返回值，是按照键的顺序排列的。
* 贝塞尔曲线用于计算机图形绘制形状，CSS 动画和许多其他地方。 它们其实非常简单，值得学习一次并且在矢量图形和高级动画的世界里非常受用。[贝塞尔曲线](https://en.wikipedia.org/wiki/B%C3%A9zier_curve) 由控制点定义。 [德卡斯特里奥算法](https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm) 与曲线的数学定义相同，但直观地显示了曲线是如何被建立的。
* 如何通过给定点绘制曲线？ 我们使用控制点制作贝塞尔曲线。正如我们所见，它们并不在曲线上。或者更准确地说，第一个和最后一个在曲线上，但其它的不在。 有时我们有另一种任务：绘制一条曲线通过几个点，让它们都在一条平滑曲线上。这种任务叫插值，这里我们不覆盖讲解它。 这些曲线有数学方程式，例如拉格朗日多项式。 在计算机图形中样条插值通常用于构建连接多个点的平滑曲线。
* CSS 动画可以在不借助 Javascript 的情况下做出一些简单的动画效果。 你也可以通过 Javascript 控制 CSS 动画，使用少量的代码，就能让动画表现更加出色。
* CSS 过渡的理念非常简单，我们只需要定义某一个属性以及如何动态地表现其变化。当属性变化时，浏览器将会绘制出相应的过渡动画。 也就是说：我们只需要改变某个属性，然后所有流畅的动画都由浏览器生成。
* CSS 动画允许你为一个或者多个属性的变化创建丝滑流畅（也可能不是）的过渡动画。 它们适用于大多数的动画需求。我们也可以使用 JavaScript 创建动画，下一章将会详细讲解相关内容。 相对于 JavaScript 动画，CSS 动画存在的特点如下：
  * 优点: 简单的事，简单地做。 快速，而且对 CPU 造成的压力很小。
  * 不足: JavaScript 动画更加灵活。它们可以实现任何动画逻辑，比如某个元素的爆炸效果。 不仅仅只是属性的变化。我们还可以在 JavaScript 中生成新元素用于动画。
* JavaScript 动画可以处理 CSS 无法处理的事情。 例如，沿着具有与 Bezier 曲线不同的时序函数的复杂路径移动，或者实现画布上的动画。
* JavaScript 动画应该通过 requestAnimationFrame 实现。该内建方法允许设置回调函数，以便在浏览器准备重绘时运行。那通常很快，但确切的时间取决于浏览器。 当页面在后台时，根本没有重绘，因此回调将不会运行：动画将被暂停并且不会消耗资源。那很棒。当然我们可以改进它，增加更多花里胡哨的东西，但 JavaScript 动画不是经常用到。它们用于做一些有趣和不标准的事情。因此，您大可在必要时再添加所需的功能。 JavaScript 动画可以使用任何时序函数。我们介绍了很多例子和变换，使它们更加通用。与 CSS 不同，我们不仅限于 Bezier 曲线。 draw 也是如此：我们可以将任何东西动画化，而不仅仅是 CSS 属性。
* 这一部分我们将会讲述关于「Web Components」的一系列现代标准。 到目前为止，这些标准仍然在制定中。其中一些特性已经被很好地支持并集成到了现代 HTML/DOM 标准中，但是还有部分特性仍然处在草案阶段。你可以在任何浏览器中尝试一些例子，Google Chrome 可能是对这些新特性支持得最好的浏览器。猜测可能是因为 Google 公司的人本身就是很多相关标准的支持者。
* 众所周知，开发复杂软件的原则是：不要让软件复杂。 如果某个部分变得复杂了 —— 将其拆分成更简单的部分，再以最简明的方式组合起来。 只有让复杂的事情简单化的架构才是好架构。 我们可以把用户界面拆分为若干可视化组件：每个组件都在页面上占有一块位置，可以执行一个明确的任务，并且可以和其他组件区分开。
* Custom element 名称必须包括一个短横线 - Custom element 名称必须包括一个短横线 -, 比如 my-element 和 super-button 都是有效的元素名，但 myelement 并不是。 这是为了确保 custom element 和内建 HTML 元素之间不会发生命名冲突。
* Shadow DOM 为封装而生。它可以让一个组件拥有自己的「影子」DOM 树，这个 DOM 树不能在主文档中被任意访问，可能拥有局部样式规则，还有其他特性。你是否曾经思考过复杂的浏览器控件是如何被创建和添加样式的？浏览器在内部使用 DOM/CSS 来绘制它们。这个 DOM 结构一般来说对我们是隐藏的，但我们可以在开发者工具里面看见它。比如，在 Chrome 里，我们需要打开「Show user agent shadow DOM」选项。
* 内建的 \<template\> 元素用来存储 HTML 模板。浏览器将忽略它的内容，仅检查语法的有效性，但是我们可以在 JavaScript 中访问和使用它来创建其他元素。 从理论上讲，我们可以在 HTML 中的任何位置创建不可见元素来储存 HTML 模板。那 \<template\> 元素有什么优势？ 首先，其内容可以是任何有效的HTML，即使它通常需要特定的封闭标签。
* 模板的 content 属性可看作 [DocumentFragment](https://zh.javascript.info/modifying-document#document-fragment) —— 一种特殊的 DOM 节点。 我们可以将其视为普通的DOM节点，除了它有一个特殊属性：将其插入某个位置时，会被插入的则是其子节点。
* \<template\> 总结一下：
  * \<template\> 的内容可以是任何语法正确的 HTML。
  * \<template\> 内容被视为“超出文档范围”，因此它不会产生任何影响。
  * 我们可以在JavaScript 中访问 template.content ，将其克隆以在新组件中重复使用。
* \<template\> 标签非常独特，因为：
  * 浏览器将检查其中的HTML语法（与在脚本中使用模板字符串不同）。
  * 但允许使用任何顶级 HTML 标签，即使没有适当包装元素的无意义的元素（例如 <tr> ）。
  * 其内容是交互式的：插入其文档后，脚本会运行， <video autoplay> 会自动播放。
* \<template\> 元素不具有任何迭代机制，数据绑定或变量替换的功能，但我们可以在其基础上实现这些功能。
* 



















































































































































































































































































































































































































