# [现代 JavaScript 教程](https://zh.javascript.info/)

## 散装笔记

* 兼容性表: JavaScript 是一门还在发展中的语言，定期会添加一些新的功能。要查看它们在基于浏览器的引擎及其他引擎中的支持情况，请看：
  * <http://caniuse.com> —— 每个功能的支持表，例如，查看哪个引擎支持现代加密（cryptography）函数：<http://caniuse.com/#feat=cryptography>。
  * <https://kangax.github.io/compat-table> —— 一份列有语言功能以及引擎是否支持这些功能的表格。
* 多行输入：通常，当我们向控制台输入一行代码后，按 Enter，这行代码就会立即执行。如果想要插入多行代码，请按 Shift+Enter 来进行换行。这样就可以输入长片段的 JavaScript 代码了。
* 即使语句被换行符分隔了，我们依然建议在它们之间加分号。这个规则被社区广泛采用。我们再次强调一下 —— 大部分时候可以省略分号，但是最好不要省略分号，尤其对新手来说。
* "use strict": 这个指令看上去像一个字符串 "use strict" 或者 'use strict'。当它处于脚本文件的顶部时，则整个脚本文件都将以“现代”模式进行工作。
* 当你使用 开发者控制台 运行代码时，请注意它默认是不启动 use strict 的。 有时，当 use strict 会对代码产生一些影响时，你会得到错误的结果。 那么，怎么在控制台中启用 use strict 呢？ 首先，你可以尝试搭配使用 Shift+Enter 按键去输入多行代码，然后将 use strict 放在代码最顶部，就像这样:
  ```text
  'use strict'; <Shift+Enter 换行>
  //  ...你的代码
  <按下 Enter 以运行>
  ```
* 我们应该使用 “use strict” 吗？因此，目前我们欢迎将 "use strict"; 写在脚本的顶部。稍后，当你的代码全都写在了 class 和 module 中时，你则可以将 "use strict"; 这行代码省略掉。
* 函数式语言: 有趣的是，也存在禁止更改变量值的 函数式 编程语言。比如 Scala 或 Erlang。 在这种类型的语言中，一旦值保存在盒子中，就永远存在。如果你试图保存其他值，它会强制创建一个新盒子（声明一个新变量），无法重用之前的变量。虽然第一次看上去有点奇怪，但是这些语言有很大的发展潜力。不仅如此，在某些领域，比如并行计算，这个限制有一定的好处。研究这样的一门语言（即使不打算很快就用上它）有助于开阔视野。
* **重用还是新建？最后一点，有一些懒惰的程序员，倾向于重用现有的变量，而不是声明一个新的变量。 结果是，这个变量就像是被扔进不同东西盒子，但没有改变它的贴纸。现在里面是什么？谁知道呢。我们需要靠近一点，仔细检查才能知道。 这样的程序员节省了一点变量声明的时间，但却在调试代码的时候损失数十倍时间。 额外声明一个变量绝对是利大于弊的。 现代的 JavaScript 压缩器和浏览器都能够很好地对代码进行优化，所以不会产生性能问题。为不同的值使用不同的变量可以帮助引擎对代码进行优化。**
* 数学运算是安全的: 在 JavaScript 中做数学运算是安全的。我们可以做任何事：除以 0，将非数字字符串视为数字，等等。脚本永远不会因为一个致命的错误（“死亡”）而停止。最坏的情况下，我们会得到 NaN 的结果。
* BigInt 兼容性问题：目前 Firefox/Chrome/Edge/Safari 已经支持 BigInt 了，但 IE 还没有。你可以查看 [MDN BigInt 兼容性表](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt#Browser_compatibility) 以了解哪些版本的浏览器已经支持 BigInt 了。
* 反引号是 功能扩展 引号。它们允许我们通过将变量和表达式包装在 ${…} 中，来将它们嵌入到字符串中。${…} 内的表达式会被计算，计算结果会成为字符串的一部分。可以在 ${…} 内放置任何东西：诸如名为 name 的变量，或者诸如 1 + 2 的算数表达式，或者其他一些更复杂的。
* JavaScript 中的 null 仅仅是一个代表“无”、“空”或“值未知”的特殊值。
* 如果一个变量已被声明，但未被赋值，那么它的值就是 undefined.
* object 类型是一个特殊的类型。其他所有的数据类型都被称为“原始类型”，因为它们的值只包含一个单独的内容（字符串、数字或者其他）。相反，object 则用于储存数据集合和更复杂的实体。
* typeof null 的结果为 "object"。这是官方承认的 typeof 的错误，这个问题来自于 JavaScript 语言的早期阶段，并为了兼容性而保留了下来。null 绝对不是一个 object。null 有自己的类型，它是一个特殊值。typeof 的行为在这里是错误的。
* typeof alert 的结果是 "function"，因为 alert 在 JavaScript 语言中是一个函数。我们会在下一章学习函数，那时我们会了解到，在 JavaScript 语言中没有一个特别的 “function” 类型。函数隶属于 object 类型。但是 typeof 会对函数区分对待，并返回 "function"。这也是来自于 JavaScript 语言早期的问题。从技术上讲，这种行为是不正确的，但在实际编程中却非常方便。
* prompt: 显示信息要求用户输入文本。点击确定返回文本，点击取消或按下 Esc 键返回 null。
* confirm: 显示信息等待用户点击确定或取消。点击确定返回 true，点击取消或按下 Esc 键返回 false。
* 我们也可以显式地调用 String(value) 来将 value 转换为字符串类型; 我们也可以使用 Number(value) 显式地将这个 value 转换为 number 类型; 我们也可以通过调用 Boolean(value) 显式地进行转换布尔值。
* 请注意：包含 0 的字符串 "0" 是 true; 一些编程语言（比如 PHP）视 "0" 为 false。但在 JavaScript 中，非空的字符串总是 true。
* 逗号运算符 , 是最少见最不常使用的运算符之一。有时候它会被用来写更简短的代码，因此为了能够理解代码，我们需要了解它。逗号运算符能让我们处理多个语句，使用 , 将它们分开。每个语句都运行了，但是只有最后的语句的结果会被返回。为什么我们需要这样一个运算符，它只返回最后一个值呢？有时候，人们会使用它把几个行为放在一行上来进行复杂的运算。这样的技巧在许多 JavaScript 框架中都有使用，这也是为什么我们提到它。但是通常它并不能提升代码的可读性，使用它之前，我们要想清楚。
* 严格相等运算符 === 在进行比较时不会做任何的类型转换。
* 对 null 和 undefined 进行比较:当使用 null 或 undefined 与其他值进行比较时，其返回结果常常出乎你的意料。 当使用严格相等 === 比较二者时它们不相等，因为它们属于不同的类型。当使用非严格相等 == 比较二者时 JavaScript 存在一个特殊的规则，会判定它们相等。它们俩就像“一对恋人”，仅仅等于对方而不等于其他任何的值（只在非严格相等下成立）。
* 或运算寻找第一个真值: `result = value1 || value2 || value3;` 从左到右依次计算操作数。 处理每一个操作数时，都将其转化为布尔值。如果结果是 true，就停止计算，返回这个操作数的初始值。 如果所有的操作数都被计算过（也就是，转换结果都是 false），则返回最后一个操作数。
* 与运算寻找第一个假值: `result = value1 && value2 && value3;` 从左到右依次计算操作数。 在处理每一个操作数时，都将其转化为布尔值。如果结果是 false，就停止计算，并返回这个操作数的初始值。 如果所有的操作数都被计算过（例如都是真值），则返回最后一个操作数。
* 两个非运算 !! 有时候用来将某个值转化为布尔类型: `alert( !!"non-empty string" ); // true`, `alert( !!null ); // false`, 也就是，第一个非运算将该值转化为布尔类型并取反，第二个非运算再次取反。最后我们就得到了一个任意值到布尔值的转化。
* 空值合并运算符 '??': a ?? b 的结果是：如果 a 是已定义的，则结果为 a，如果 a 不是已定义的，则结果为 b。 换句话说，如果第一个参数不是 null/undefined，则 ?? 返回第一个参数。否则，返回第二个参数。空值合并运算符并不是什么全新的东西。它只是一种获得两者中的第一个“已定义的”值的不错的语法。另一方面，空值合并运算符 ?? 是最近才被添加到 JavaScript 中的，它的出现是因为人们对 || 不太满意。 它们之间重要的区别是： || 返回第一个 真 值。 ?? 返回第一个 已定义的 值。出于安全原因，JavaScript 禁止将 ?? 运算符与 && 和 || 运算符一起使用，除非使用括号明确指定了优先级。这个限制无疑是值得商榷的，它被添加到语言规范中是为了避免人们从 || 切换到 ?? 时的编程错误。 可以明确地使用括号来解决这个问题。
* break/continue 支持循环前的标签。标签是 break/continue 跳出嵌套循环以转到外部的唯一方法。
* 全局变量：任何函数之外声明的变量，例如上述代码中的外部变量 userName，都被称为 全局 变量。 全局变量在任意函数中都是可见的（除非被局部变量遮蔽）。 减少全局变量的使用是一种很好的做法。现代的代码有很少甚至没有全局变量。大多数变量存在于它们的函数中。但是有时候，全局变量能够用于存储项目级别的数据。
* 空值的 return 或没有 return 的函数返回值为 undefined：如果函数无返回值，它就会像返回 undefined 一样。
* 不要在 return 与返回值之间添加新行：对于 return 的长表达式，可能你会很想将其放在单独一行，但这不行，因为 JavaScript 默认会在 return 之后加上分号。因此，实际上它的返回值变成了空值。 如果我们想要将返回的表达式写成跨多行的形式，那么应该在 return 的同一行开始写此表达式。
* 一个函数 —— 一个行为：一个函数应该只包含函数名所指定的功能，而不是做更多与函数名无关的功能。 两个独立的行为通常需要两个函数，即使它们通常被一起调用（在这种情况下，我们可以创建第三个函数来调用这两个函数）。 有几个违反这一规则的例子： getAge —— 如果它通过 alert 将 age 显示出来，那就有问题了（只应该是获取）。 createForm —— 如果它包含修改文档的操作，例如向文档添加一个表单，那就有问题了（只应该创建表单并返回）。 checkPermission —— 如果它显示 access granted/denied 消息，那就有问题了（只应执行检查并返回结果）。 这些例子假设函数名前缀具有通用的含义。你和你的团队可以自定义这些函数名前缀的含义，但是通常都没有太大的不同。无论怎样，你都应该对函数名前缀的含义、带特定前缀的函数可以做什么以及不可以做什么有深刻的了解。所有相同前缀的函数都应该遵守相同的规则。并且，团队成员应该形成共识。
* 非常短的函数命名：常用的函数有时会有非常短的名字。 例如，[jQuery](http://jquery.com/) 框架用 $ 定义一个函数。[LoDash](http://lodash.com/) 库的核心函数用 _ 命名。 这些都是例外，一般而言，函数名应简明扼要且具有描述性。
* 函数是一个值：重申一次：无论函数是如何创建的，函数都是一个值。在某些编程语言中，只要提到函数的名称都会导致函数的调用执行，但 JavaScript 可不是这样。 在 JavaScript 中，函数是一个值，所以我们可以把它当成值对待。
* 回调函数：让我们多举几个例子，看看如何将函数作为值来传递以及如何使用函数表达式。 我们写一个包含三个参数的函数 ask(question, yes, no).
  ```text
  function ask(question, yes, no) {
    if (confirm(question)) yes()
    else no();
  }
  
  ask(
    "Do you agree?",
    function() { alert("You agreed."); },
    function() { alert("You canceled the execution."); }
  );
  ```
* 一个函数是表示一个“行为”的值：字符串或数字等常规值代表 数据。 函数可以被视为一个 行为（action）。 我们可以在变量之间传递它们，并在需要时运行。
* 什么时候选择函数声明与函数表达式？根据经验，当我们需要声明一个函数时，首先考虑函数声明语法。它能够为组织代码提供更多的灵活性。因为我们可以在声明这些函数之前调用这些函数。 这对代码可读性也更好，因为在代码中查找 function f(…) {…} 比 let f = function(…) {…} 更容易。函数声明更“醒目”。 ……但是，如果由于某种原因而导致函数声明不适合我们（我们刚刚看过上面的例子），那么应该使用函数表达式。
* 一开始，箭头函数可能看起来并不熟悉，也不容易读懂，但一旦我们看习惯了之后，这种情况很快就会改变。 箭头函数对于简单的单行行为（action）来说非常方便，尤其是当我们懒得打太多字的时候。对于一行代码的函数来说，箭头函数是相当方便的。它具体有两种：不带花括号：(...args) => expression — 右侧是一个表达式：函数计算表达式并返回其结果。 带花括号：(...args) => { body } — 花括号允许我们在函数中编写多个语句，但是我们需要显式地 return 来返回一些内容。
* 条件断点：在行号上 右键单击 允许你创建一个 条件 断点。只有当给定的表达式为真（即满足条件）时才会被触发。当我们需要在特定的变量值或参数的情况下暂停程序执行时，这种调试方法就很有用了。
* Continue to here: 在代码中的某一行上右键，在显示的关联菜单（context menu）中点击一个非常有用的名为 “Continue to here” 的选项。 当你想要向前移动很多步到某一行为止，但是又懒得设置一个断点时非常的方便。
* 没有什么规则是“必须”的：没有什么规则是“刻在石头上”的。这些是风格偏好，而不是宗教教条。
* 分号：每一个语句后面都应该有一个分号。即使它可以被跳过。 有一些编程语言的分号确实是可选的，那些语言中也很少使用分号。但是在 JavaScript 中，极少数情况下，换行符有时不会被解释为分号，这时代码就容易出错。更多内容请参阅 [代码结构](https://zh.javascript.info/structure#semicolon) 一章的内容。 如果你是一个有经验的 JavaScript 程序员，你可以选择像 [StandardJS](https://standardjs.com/readme-zhcn.html) 这样的无分号的代码风格。否则，最好使用分号以避免可能出现的陷阱。大多数开发人员都应该使用分号。
* 本章描述的（和提到的代码风格指南中的）所有语法规则，都旨在帮助你提高代码可读性。它们都是值得商榷的。 当我们思考如何写“更好”的代码的时候，我们应该问自己的问题是：“什么可以让代码可读性更高，更容易被理解？”和“什么可以帮助我们避免错误？”这些是我们讨论和选择代码风格时要牢记的主要原则。 阅读流行的代码风格指南，可以帮助你了解有关代码风格的变化趋势和最佳实践的最新想法。
* 好的注释：所以，解释性注释通常来说都是不好的。那么哪一种注释才是好的呢？ 
  * 描述架构：对组件进行高层次的整体概括，它们如何相互作用、各种情况下的控制流程是什么样的……简而言之 —— 代码的鸟瞰图。有一个专门用于构建代码的高层次架构图，以对代码进行解释的特殊编程语言 [UML](http://wikipedia.org/wiki/Unified_Modeling_Language), 绝对值得学习。 
  * 记录函数的参数和用法：有一个专门用于记录函数的语法 [JSDoc](http://en.wikipedia.org/wiki/JSDoc): 用法、参数和返回值。这种注释可以帮助我们理解函数的目的，并且不需要研究其内部的实现代码，就可以直接正确地使用它。
  * 为什么任务以这种方式解决？写了什么代码很重要。但是为什么 不 那样写可能对于理解正在发生什么更重要。为什么任务是通过这种方式解决的？代码并没有给出答案。 如果有很多种方法都可以解决这个问题，为什么偏偏是这一种？尤其当它不是最显而易见的那一种的时候。解决方案的注释非常的重要。它们可以帮助你以正确的方式继续开发。
  * 代码有哪些巧妙的特性？它们被用在了什么地方？ 如果代码存在任何巧妙和不显而易见的方法，那绝对需要注释。
* 自动化测试意味着测试是独立于代码的。它们以各种方式运行我们的函数，并将结果与预期结果进行比较。
* 在 BDD 中，规范先行，实现在后。最后我们同时拥有了规范和代码。有了规范，我们可以安全地改进、修改甚至重写函数，并确保它仍然正确地工作。 这在一个函数会被用在多个地方的大型项目中尤其重要。当我们改变这样一个函数时，没有办法手动检查每个使用它们的地方是否仍旧正确。自动化测试则有助于避免这样的问题！ 如果这个项目被测试代码覆盖了，就不会出现这种问题。在任何修改之后，我们都可以运行测试，并在几秒钟内看到大量的检查。 另外，一个经过良好测试的代码通常都有更好的架构。 当然，这是因为覆盖了自动化测试的代码更容易修改和改进。但还有另一个原因。 要编写测试，代码的组织方式应确保每个函数都有一个清晰描述的任务、定义良好的输入和输出。这意味着从一开始就有一个好的架构。 在实际开发中有时候可能并不容易，有时很难在写实际代码之前编写规范，因为还不清楚它应该如何表现。但一般来说，编写测试使得开发更快更稳定。
* 作为程序员，我们希望使用最新的特性。好东西越多越好！ 另一方面，如何让我们现代的代码在还不支持最新特性的旧引擎上工作？ 有两个工作可以做到这一点： 转译器（Transpilers）。 垫片（Polyfills）。
* 通常，开发者会在自己的计算机上运行转译器，然后将转译后的代码部署到服务器。 说到名字，[Babel](https://babeljs.io/) 是最著名的转译器之一。 现代项目构建系统，例如 [webpack](http://webpack.github.io/), 提供了在每次代码更改时自动运行转译器的方法，因此很容易将代码转译集成到开发过程中。
* JavaScript 是一种高度动态的语言，脚本可以添加/修改任何函数，甚至包括内建函数。 两个有趣的 polyfill 库： [core js](https://github.com/zloirock/core-js) 支持了很多特性，允许只包含需要的特性。 [polyfill.io](http://polyfill.io/) 提供带有 polyfill 的脚本的服务，具体取决于特性和用户的浏览器。
* 谷歌的 Chrome 浏览器通常是对最新的语言特性的支持情况最好的浏览器，如果教程的示例运行失败，请尝试使用 Chrome 浏览器。不过，教程中的大多数示例都适用于任意的现代浏览器。
* 方括号: 对于多词属性，点操作就不能用了。JavaScript 理解不了。它认为我们在处理 user.likes，然后在遇到意外的 birds 时给出了语法错误。 点符号要求 key 是有效的变量标识符。这意味着：不包含空格，不以数字开头，也不包含特殊字符（允许使用 $ 和 _）。 有另一种方法，就是使用方括号，可用于任何字符串
* 现在一切都可行了。请注意方括号中的字符串要放在引号中，单引号或双引号都可以。 方括号同样提供了一种可以通过任意表达式来获取属性名的方法 —— 跟语义上的字符串不同。 在这里，变量 key 可以是程序运行时计算得到的，也可以是根据用户的输入得到的。然后我们可以用它来访问属性。这给了我们很大的灵活性。
* 计算属性：当创建一个对象时，我们可以在对象字面量中使用方括号。这叫做 计算属性。计算属性的含义很简单：\[fruit\] 含义是属性名应该从 fruit 变量中获取。 所以，如果一个用户输入 "apple"，bag 将变为 {apple: 5}。
* 方括号比点符号更强大。它允许任何属性名和变量，但写起来也更加麻烦。所以，大部分时间里，当属性名是已知且简单的时候，就使用点符号。如果我们需要一些更复杂的内容，那么就用方括号。
* 属性值简写：在实际开发中，我们通常用已存在的变量当做属性名。属性名跟变量名一样。这种通过变量生成属性的应用场景很常见，在这有一种特殊的 属性值缩写 方法，使属性名变得更短。 可以用 name 来代替 name:name
* 属性名称限制：我们已经知道，变量名不能是编程语言的某个保留字，如 “for”、“let”、“return” 等…… 但对象的属性名并不受此限制。简而言之，属性命名没有限制。属性名可以是任何字符串或者 symbol（一种特殊的标志符类型，将在后面介绍）。 其他类型会被自动地转换为字符串。 例如，当数字 0 被用作对象的属性的键时，会被转换为字符串 "0"
* 属性存在性测试，“in” 操作符：相比于其他语言，JavaScript 的对象有一个需要注意的特性：能够被访问任何属性。即使属性不存在也不会报错！ 读取不存在的属性只会得到 undefined。所以我们可以很容易地判断一个属性是否存在。这里还有一个特别的，检查属性是否存在的操作符 "in"。请注意，in 的左边必须是 属性名。通常是一个带引号的字符串。 如果我们省略引号，就意味着左边是一个变量，它应该包含要判断的实际属性名。为何会有 in 运算符呢？与 undefined 进行比较来判断还不够吗？ 确实，大部分情况下与 undefined 进行比较来判断就可以了。但有一个例外情况，这种比对方式会有问题，但 in 运算符的判断结果仍是对的。 那就是属性存在，但存储的值是 undefined 的时候。
* 像对象一样排序：对象有顺序吗？换句话说，如果我们遍历一个对象，我们获取属性的顺序是和属性添加时的顺序相同吗？这靠谱吗？ 简短的回答是：“有特别的顺序”：整数属性会被进行排序，其他属性则按照创建的顺序显示。
* 整数属性？那是什么？这里的“整数属性”指的是一个可以在不做任何更改的情况下与一个整数进行相互转换的字符串。 所以，“49” 是一个整数属性名，因为我们把它转换成整数，再转换回来，它还是一样的。但是 “+49” 和 “1.2” 就不行了。……此外，如果属性名不是整数，那它们就按照创建时的顺序来排序。
* 深层克隆: 为了解决这个问题，我们应该使用一个拷贝循环来检查 user[key] 的每个值，如果它是一个对象，那么也复制它的结构。这就是所谓的“深拷贝”。 我们可以使用递归来实现它。或者为了不重复造轮子，采用现有的实现，例如 [lodash](https://lodash.com/) 库的 [_.cloneDeep(obj)](https://lodash.com/docs#cloneDeep).
* [垃圾回收](https://zh.javascript.info/garbage-collection): JavaScript 中主要的内存管理概念是 可达性。 **这里有大量图说明可达性概念。**  一些优化建议： 
  * 分代收集（Generational collection）—— 对象被分成两组：“新的”和“旧的”。许多对象出现，完成它们的工作并很快死去，它们可以很快被清理。那些长期存活的对象会变得“老旧”，而且被检查的频次也会减少。 
  * 增量收集（Incremental collection）—— 如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟。所以引擎试图将垃圾收集工作分成几部分来做。然后将这几部分会逐一进行处理。这需要它们之间有额外的标记来追踪变化，但是这样会有许多微小的延迟而不是一个大的延迟。 
  * 闲时收集（Idle-time collection）—— 垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。
* 



































































































































































































































































































































































































































