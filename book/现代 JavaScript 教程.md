# [现代 JavaScript 教程](https://zh.javascript.info/)

## 散装笔记

* 兼容性表: JavaScript 是一门还在发展中的语言，定期会添加一些新的功能。要查看它们在基于浏览器的引擎及其他引擎中的支持情况，请看：
  * <http://caniuse.com> —— 每个功能的支持表，例如，查看哪个引擎支持现代加密（cryptography）函数：<http://caniuse.com/#feat=cryptography>。
  * <https://kangax.github.io/compat-table> —— 一份列有语言功能以及引擎是否支持这些功能的表格。
* 多行输入：通常，当我们向控制台输入一行代码后，按 Enter，这行代码就会立即执行。如果想要插入多行代码，请按 Shift+Enter 来进行换行。这样就可以输入长片段的 JavaScript 代码了。
* 即使语句被换行符分隔了，我们依然建议在它们之间加分号。这个规则被社区广泛采用。我们再次强调一下 —— 大部分时候可以省略分号，但是最好不要省略分号，尤其对新手来说。
* "use strict": 这个指令看上去像一个字符串 "use strict" 或者 'use strict'。当它处于脚本文件的顶部时，则整个脚本文件都将以“现代”模式进行工作。
* 当你使用 开发者控制台 运行代码时，请注意它默认是不启动 use strict 的。 有时，当 use strict 会对代码产生一些影响时，你会得到错误的结果。 那么，怎么在控制台中启用 use strict 呢？ 首先，你可以尝试搭配使用 Shift+Enter 按键去输入多行代码，然后将 use strict 放在代码最顶部，就像这样:
  ```text
  'use strict'; <Shift+Enter 换行>
  //  ...你的代码
  <按下 Enter 以运行>
  ```
* 我们应该使用 “use strict” 吗？因此，目前我们欢迎将 "use strict"; 写在脚本的顶部。稍后，当你的代码全都写在了 class 和 module 中时，你则可以将 "use strict"; 这行代码省略掉。
* 函数式语言: 有趣的是，也存在禁止更改变量值的 函数式 编程语言。比如 Scala 或 Erlang。 在这种类型的语言中，一旦值保存在盒子中，就永远存在。如果你试图保存其他值，它会强制创建一个新盒子（声明一个新变量），无法重用之前的变量。虽然第一次看上去有点奇怪，但是这些语言有很大的发展潜力。不仅如此，在某些领域，比如并行计算，这个限制有一定的好处。研究这样的一门语言（即使不打算很快就用上它）有助于开阔视野。
* **重用还是新建？最后一点，有一些懒惰的程序员，倾向于重用现有的变量，而不是声明一个新的变量。 结果是，这个变量就像是被扔进不同东西盒子，但没有改变它的贴纸。现在里面是什么？谁知道呢。我们需要靠近一点，仔细检查才能知道。 这样的程序员节省了一点变量声明的时间，但却在调试代码的时候损失数十倍时间。 额外声明一个变量绝对是利大于弊的。 现代的 JavaScript 压缩器和浏览器都能够很好地对代码进行优化，所以不会产生性能问题。为不同的值使用不同的变量可以帮助引擎对代码进行优化。**
* 数学运算是安全的: 在 JavaScript 中做数学运算是安全的。我们可以做任何事：除以 0，将非数字字符串视为数字，等等。脚本永远不会因为一个致命的错误（“死亡”）而停止。最坏的情况下，我们会得到 NaN 的结果。
* BigInt 兼容性问题：目前 Firefox/Chrome/Edge/Safari 已经支持 BigInt 了，但 IE 还没有。你可以查看 [MDN BigInt 兼容性表](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt#Browser_compatibility) 以了解哪些版本的浏览器已经支持 BigInt 了。
* 反引号是 功能扩展 引号。它们允许我们通过将变量和表达式包装在 ${…} 中，来将它们嵌入到字符串中。${…} 内的表达式会被计算，计算结果会成为字符串的一部分。可以在 ${…} 内放置任何东西：诸如名为 name 的变量，或者诸如 1 + 2 的算数表达式，或者其他一些更复杂的。
* JavaScript 中的 null 仅仅是一个代表“无”、“空”或“值未知”的特殊值。
* 如果一个变量已被声明，但未被赋值，那么它的值就是 undefined.
* object 类型是一个特殊的类型。其他所有的数据类型都被称为“原始类型”，因为它们的值只包含一个单独的内容（字符串、数字或者其他）。相反，object 则用于储存数据集合和更复杂的实体。
* typeof null 的结果为 "object"。这是官方承认的 typeof 的错误，这个问题来自于 JavaScript 语言的早期阶段，并为了兼容性而保留了下来。null 绝对不是一个 object。null 有自己的类型，它是一个特殊值。typeof 的行为在这里是错误的。
* typeof alert 的结果是 "function"，因为 alert 在 JavaScript 语言中是一个函数。我们会在下一章学习函数，那时我们会了解到，在 JavaScript 语言中没有一个特别的 “function” 类型。函数隶属于 object 类型。但是 typeof 会对函数区分对待，并返回 "function"。这也是来自于 JavaScript 语言早期的问题。从技术上讲，这种行为是不正确的，但在实际编程中却非常方便。
* prompt: 显示信息要求用户输入文本。点击确定返回文本，点击取消或按下 Esc 键返回 null。
* confirm: 显示信息等待用户点击确定或取消。点击确定返回 true，点击取消或按下 Esc 键返回 false。
* 我们也可以显式地调用 String(value) 来将 value 转换为字符串类型; 我们也可以使用 Number(value) 显式地将这个 value 转换为 number 类型; 我们也可以通过调用 Boolean(value) 显式地进行转换布尔值。
* 请注意：包含 0 的字符串 "0" 是 true; 一些编程语言（比如 PHP）视 "0" 为 false。但在 JavaScript 中，非空的字符串总是 true。
* 逗号运算符 , 是最少见最不常使用的运算符之一。有时候它会被用来写更简短的代码，因此为了能够理解代码，我们需要了解它。逗号运算符能让我们处理多个语句，使用 , 将它们分开。每个语句都运行了，但是只有最后的语句的结果会被返回。为什么我们需要这样一个运算符，它只返回最后一个值呢？有时候，人们会使用它把几个行为放在一行上来进行复杂的运算。这样的技巧在许多 JavaScript 框架中都有使用，这也是为什么我们提到它。但是通常它并不能提升代码的可读性，使用它之前，我们要想清楚。
* 严格相等运算符 === 在进行比较时不会做任何的类型转换。
* 对 null 和 undefined 进行比较:当使用 null 或 undefined 与其他值进行比较时，其返回结果常常出乎你的意料。 当使用严格相等 === 比较二者时它们不相等，因为它们属于不同的类型。当使用非严格相等 == 比较二者时 JavaScript 存在一个特殊的规则，会判定它们相等。它们俩就像“一对恋人”，仅仅等于对方而不等于其他任何的值（只在非严格相等下成立）。
* 或运算寻找第一个真值: `result = value1 || value2 || value3;` 从左到右依次计算操作数。 处理每一个操作数时，都将其转化为布尔值。如果结果是 true，就停止计算，返回这个操作数的初始值。 如果所有的操作数都被计算过（也就是，转换结果都是 false），则返回最后一个操作数。
* 与运算寻找第一个假值: `result = value1 && value2 && value3;` 从左到右依次计算操作数。 在处理每一个操作数时，都将其转化为布尔值。如果结果是 false，就停止计算，并返回这个操作数的初始值。 如果所有的操作数都被计算过（例如都是真值），则返回最后一个操作数。
* 两个非运算 !! 有时候用来将某个值转化为布尔类型: `alert( !!"non-empty string" ); // true`, `alert( !!null ); // false`, 也就是，第一个非运算将该值转化为布尔类型并取反，第二个非运算再次取反。最后我们就得到了一个任意值到布尔值的转化。
* 空值合并运算符 '??': a ?? b 的结果是：如果 a 是已定义的，则结果为 a，如果 a 不是已定义的，则结果为 b。 换句话说，如果第一个参数不是 null/undefined，则 ?? 返回第一个参数。否则，返回第二个参数。空值合并运算符并不是什么全新的东西。它只是一种获得两者中的第一个“已定义的”值的不错的语法。另一方面，空值合并运算符 ?? 是最近才被添加到 JavaScript 中的，它的出现是因为人们对 || 不太满意。 它们之间重要的区别是： || 返回第一个 真 值。 ?? 返回第一个 已定义的 值。
* 




































































































































































































































































































































































































































